<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FundFlow - Êô∫ËÉΩÂü∫ÈáëÁõëÊéßÁ≥ªÁªü</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #3b82f6; --primary-dark: #2563eb; --primary-light: #60a5fa; --primary-ultra-light: #dbeafe; --success: #ef4444; --danger: #10b981; --warning: #f59e0b; --purple: #8b5cf6; --purple-dark: #7c3aed; --gray-50: #fafafa; --gray-100: #f5f5f5; --gray-200: #e5e5e5; --gray-300: #d4d4d4; --gray-400: #a3a3a3; --gray-500: #737373; --gray-600: #525252; --gray-700: #404040; --gray-800: #262626; --gray-900: #171717; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #f0fdf4 100%); color: var(--gray-900); overflow-x: hidden; }
        .app-container { display: flex; height: 100vh; position: relative; }
        
        /* ÁßªÂä®Á´ØËèúÂçïÊåâÈíÆ */
        .mobile-menu-btn { display: none; position: fixed; top: 20px; left: 20px; z-index: 1001; width: 48px; height: 48px; background: white; border: 2px solid var(--gray-200); border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1); flex-direction: column; align-items: center; justify-content: center; gap: 4px; }
        .mobile-menu-btn span { width: 24px; height: 3px; background: var(--gray-700); border-radius: 2px; transition: all 0.3s; }
        .mobile-menu-btn.active span:nth-child(1) { transform: rotate(45deg) translate(6px, 6px); }
        .mobile-menu-btn.active span:nth-child(2) { opacity: 0; }
        .mobile-menu-btn.active span:nth-child(3) { transform: rotate(-45deg) translate(6px, -6px); }
        
        .sidebar { width: 420px; background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border-right: 1px solid rgba(229, 229, 229, 0.6); display: flex; flex-direction: column; overflow: hidden; box-shadow: 4px 0 20px rgba(0, 0, 0, 0.03); transition: transform 0.3s; }
        .sidebar-header { padding: 20px 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .logo-card { background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #ec4899 100%); border-radius: 16px; padding: 14px 20px; color: white; box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3), 0 2px 8px rgba(139, 92, 246, 0.2); position: relative; overflow: hidden; }
        .logo-card::before { content: ''; position: absolute; top: -50%; right: -30px; width: 140px; height: 200%; background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0) 100%); transform: rotate(20deg); animation: shimmer 3s infinite; }
        @keyframes shimmer { 0% { transform: translateX(-100%) rotate(20deg); } 100% { transform: translateX(300%) rotate(20deg); } }
        .logo-content { position: relative; z-index: 1; }
        .logo-summary { position: absolute; top: 10px; right: 12px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px; font-size: 0.9rem; color: rgba(255,255,255,0.95); font-weight: 700; }
        .logo-summary .line { display: grid; grid-template-columns: auto auto; column-gap: 8px; align-items: baseline; }
        .logo-summary .line > span:first-child { justify-self: end; }
        .logo-summary .line > span:last-child { justify-self: end; text-align: right; font-variant-numeric: tabular-nums; min-width: 92px; }
        .logo-summary .label { opacity: 0.9; font-weight: 600; }
        .logo-icon { width: 32px; height: 32px; background: rgba(255, 255, 255, 0.25); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.125rem; margin-bottom: 6px; backdrop-filter: blur(10px); }
        .logo { font-size: 1.125rem; font-weight: 800; letter-spacing: -0.02em; margin-bottom: 4px; }
        .logo-subtitle { font-size: 0.75rem; opacity: 0.95; font-weight: 500; display: flex; align-items: center; gap: 8px; }
        .status-indicator { width: 7px; height: 7px; background: #10b981; border-radius: 50%; animation: pulse 2s infinite; box-shadow: 0 0 10px #10b981; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.15); } }
        
        /* Â∏ÇÂú∫ÊåáÊï∞ */
        .market-indices { padding: 0; background: transparent; border: none; }
        .indices-toggle { width: 100%; padding: 16px 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border: none; border-bottom: 1px solid rgba(229, 229, 229, 0.6); cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s; }
        .indices-toggle:hover { background: rgba(249, 250, 251, 0.95); }
        .indices-toggle-left { display: flex; align-items: center; gap: 10px; }
        .indices-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); text-transform: uppercase; letter-spacing: 0.08em; display: flex; align-items: center; gap: 8px; margin: 0; }
        .indices-arrow { font-size: 0.875rem; color: var(--gray-500); transition: transform 0.3s; }
        .indices-arrow.open { transform: rotate(180deg); }
        .indices-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .indices-content.open { max-height: 2000px; }
        .indices-inner { padding: 16px 20px; }
        
        /* ‰øÆÂ§çÔºöÂº∫Âà∂3ÂàóÂ∏ÉÂ±Ä */
        .indices-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; } 
        
        .index-card { background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(249,250,251,0.9) 100%); border: 1.5px solid var(--gray-200); border-radius: 12px; padding: 12px 10px; transition: all 0.3s; cursor: pointer; display: flex; flex-direction: column; justify-content: space-between; min-height: 80px; }
        .index-card:hover { border-color: var(--primary-light); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.12); }
        .index-card.positive { background: linear-gradient(135deg, rgba(254, 242, 242, 0.9) 0%, rgba(255, 255, 255, 0.9) 100%); border-color: rgba(239, 68, 68, 0.3); }
        .index-card.negative { background: linear-gradient(135deg, rgba(236, 253, 245, 0.9) 0%, rgba(255, 255, 255, 0.9) 100%); border-color: rgba(16, 185, 129, 0.3); }
        .index-card.selected { border-color: var(--primary); box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2); grid-column: span 3; } /* ÈÄâ‰∏≠Êó∂Âç†Êª°‰∏ÄË°å */
        
        .index-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px; }
        .index-name { font-size: 0.75rem; font-weight: 700; color: var(--gray-800); display: flex; align-items: center; gap: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
        .index-status-badge { font-size: 0.6rem; padding: 1px 4px; border-radius: 4px; background: var(--gray-100); color: var(--gray-500); font-weight: normal; margin-left: auto; display: none;}
        .index-card.closed .index-status-badge { display: inline-block; }
        .index-flag { font-size: 0.875rem; }
        
        .index-body { display: flex; flex-direction: column; align-items: flex-start; }
        .index-value { font-size: 1rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: var(--gray-900); line-height: 1.2; margin-bottom: 2px; }
        .index-change { font-size: 0.75rem; font-weight: 700; display: flex; align-items: center; gap: 2px; }
        .index-card.positive .index-change { color: #dc2626; }
        .index-card.negative .index-change { color: #059669; }
        
        .index-chart-container { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--gray-200); width: 100%; height: 180px; }
        .index-mini-chart { width: 100%; height: 100%; }
        .indices-refresh { margin-top: 12px; width: 100%; padding: 8px; background: var(--gray-50); border: 1px solid var(--gray-200); border-radius: 8px; font-size: 0.75rem; color: var(--gray-600); cursor: pointer; transition: all 0.2s; font-weight: 600; }
        .indices-refresh:hover { background: var(--gray-100); border-color: var(--gray-300); }
        
        .add-fund-section { padding: 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .section-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.08em; }
        .input-row { display: grid; grid-template-columns: 1fr auto; gap: 10px; margin-bottom: 10px; }
        .input-field { width: 100%; padding: 12px 16px; border: 2px solid var(--gray-200); border-radius: 12px; font-size: 0.9375rem; font-family: 'JetBrains Mono', monospace; transition: all 0.25s; background: white; }
        .input-field:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12); transform: translateY(-1px); }
        .btn-add { padding: 12px 24px; border: none; border-radius: 12px; font-size: 0.9375rem; font-weight: 700; cursor: pointer; transition: all 0.25s; background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; white-space: nowrap; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); position: relative; overflow: hidden; }
        .btn-add:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); }
        .optional-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .input-small { padding: 10px 14px; font-size: 0.875rem; }
        .helper-text { font-size: 0.75rem; color: var(--gray-500); margin-top: 10px; display: flex; align-items: center; gap: 6px; background: var(--gray-50); padding: 8px 12px; border-radius: 8px; border-left: 3px solid var(--primary-light); }
        .fund-suggest { margin-top: 8px; border: 1.5px solid var(--gray-200); border-radius: 12px; background: white; overflow: hidden; box-shadow: 0 8px 20px rgba(0,0,0,0.06); max-height: 260px; overflow-y: auto; display: none; }
        .fund-suggest-item { padding: 10px 12px; cursor: pointer; transition: background 0.15s; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .fund-suggest-item:hover, .fund-suggest-item.active { background: var(--gray-50); }
        .fund-suggest-left { min-width: 0; }
        .fund-suggest-name { font-size: 0.875rem; font-weight: 700; color: var(--gray-800); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .fund-suggest-meta { font-size: 0.75rem; color: var(--gray-500); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .fund-suggest-code { font-family: 'JetBrains Mono', monospace; font-size: 0.8125rem; font-weight: 800; color: var(--gray-700); background: var(--gray-100); padding: 4px 8px; border-radius: 8px; flex-shrink: 0; }
        .fund-list { flex: 1; overflow-y: auto; padding: 16px; }
        .fund-list::-webkit-scrollbar { width: 6px; }
        .fund-list::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 10px; }
        .fund-item { background: white; border: 2px solid transparent; border-radius: 16px; padding: 18px; margin-bottom: 14px; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .fund-item:hover { border-color: var(--primary-light); transform: translateX(6px) translateY(-2px); box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15); }
        .fund-item.active { background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%); border-color: var(--primary); transform: translateX(8px); }
        .fund-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 14px; }
        .fund-info { flex: 1; }
        .fund-name { font-size: 0.9375rem; font-weight: 700; color: var(--gray-900); margin-bottom: 6px; }
        .fund-code { font-size: 0.75rem; color: var(--gray-500); font-family: 'JetBrains Mono', monospace; background: var(--gray-100); padding: 3px 8px; border-radius: 6px; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; }
        .fund-code-chg { font-family: 'Inter', sans-serif; font-weight: 700; font-size: 0.6875rem; padding: 1px 5px; border-radius: 4px; white-space: nowrap; }
        .fund-code-chg.positive { background: #fef2f2; color: #dc2626; }
        .fund-code-chg.negative { background: #ecfdf5; color: #059669; }
        .fund-code-chg.neutral { background: var(--gray-100); color: var(--gray-500); }
        .fund-item.card-expanded .fund-code-chg { display: none; }
        .fund-item.card-collapsed .fund-code-chg { display: inline-block; }
        .fund-actions { display: flex; gap: 6px; }
        .btn-icon { width: 32px; height: 32px; border: none; background: var(--gray-100); border-radius: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .btn-icon:hover { background: var(--gray-200); transform: scale(1.1); }
        .fund-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 12px; }
        .metric-card { background: linear-gradient(135deg, var(--gray-50) 0%, white 100%); padding: 12px; border-radius: 12px; border: 1px solid var(--gray-200); }
        .metric-label { font-size: 0.6875rem; color: var(--gray-600); margin-bottom: 4px; text-transform: uppercase; font-weight: 600; display: flex; justify-content: space-between; }
        .metric-value { font-size: 1.125rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; }
        .positive { color: var(--success); }
        .negative { color: var(--danger); }
        /* Âü∫ÈáëÂç°ÁâáÊäòÂè† */
        .fund-body { max-height: 200px; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1); }
        .fund-body.collapsed { max-height: 0; }
        .fund-header { cursor: pointer; user-select: none; }
        .fund-collapse-arrow { font-size: 0.7rem; color: var(--gray-400); transition: transform 0.3s; margin-left: 4px; display: inline-block; }
        .fund-collapse-arrow.collapsed { transform: rotate(-90deg); }
        
        /* ‰∏ªÈ°µÊ†áÈ¢òÊ†èÊäòÂè† */
        .header-collapse-btn { background: none; border: 1.5px solid var(--gray-200); border-radius: 8px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--gray-500); font-size: 0.875rem; transition: all 0.2s; }
        .header-collapse-btn:hover { border-color: var(--primary-light); color: var(--primary); background: var(--primary-ultra-light); }
        .stats-grid-wrapper { max-height: 520px; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1), margin 0.35s; padding: 6px 0; }
        .stats-grid-wrapper.collapsed { max-height: 0; margin-top: 0 !important; padding: 0; }
        .stats-grid-wrapper { margin-top: 16px; }
        
        /* Êó•Ê∂®Ë∑å‰º∞ÁÆóÊ†áËÆ∞ */
        .day-growth-source { display: inline-flex; align-items: center; font-size: 0.6875rem; font-weight: 600; padding: 2px 6px; border-radius: 4px; margin-left: 6px; line-height: 1; border: 1px solid transparent; user-select: none; }
        .day-growth-source.est { background: rgba(139,92,246,0.1); color: #7c3aed; border-color: rgba(139,92,246,0.22); }
        .day-growth-source.official { background: var(--gray-100); color: var(--gray-500); border-color: var(--gray-200); }
        
        /* Ê∑ªÂä†Âü∫ÈáëÂå∫ÂüüÊäòÂè† */
        .add-fund-toggle { width: 100%; padding: 14px 24px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border: none; border-bottom: 1px solid rgba(229,229,229,0.6); cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: background 0.2s; }
        .add-fund-toggle:hover { background: rgba(249,250,251,0.98); }
        .add-fund-toggle-left { display: flex; align-items: center; gap: 10px; }
        .add-fund-toggle-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); text-transform: uppercase; letter-spacing: 0.08em; }
        .add-fund-arrow { font-size: 0.75rem; color: var(--gray-500); transition: transform 0.3s; }
        .add-fund-arrow.open { transform: rotate(180deg); }
        .add-fund-body { max-height: 0; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1); background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229,229,229,0.6); }
        .add-fund-body.open { max-height: 300px; }
        .add-fund-inner { padding: 16px 24px 20px; }

        /* ÊåÅ‰ªìÁºñËæëÂØπËØùÊ°Ü */
        .pos-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); backdrop-filter: blur(4px); z-index: 20000; display: none; align-items: center; justify-content: center; }
        .pos-modal-overlay.active { display: flex; }
        .pos-modal { background: white; border-radius: 20px; width: 392px; max-width: 92vw; box-shadow: 0 24px 60px rgba(0,0,0,0.22); overflow: hidden; animation: posModalIn 0.22s cubic-bezier(.4,0,.2,1); }
        @keyframes posModalIn { from { transform: translateY(24px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .pos-modal-header { padding: 22px 24px 16px; display: flex; justify-content: space-between; align-items: center; }
        .pos-modal-title { font-size: 1.0625rem; font-weight: 800; color: var(--gray-900); }
        .pos-modal-close { width: 28px; height: 28px; border: none; background: var(--gray-100); border-radius: 8px; cursor: pointer; font-size: 1.125rem; color: var(--gray-500); display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
        .pos-modal-close:hover { background: var(--gray-200); color: var(--gray-700); }
        .pos-modal-body { padding: 0 24px 8px; }
        .pos-field { margin-bottom: 14px; }
        .pos-field label { display: block; font-size: 0.75rem; font-weight: 700; color: var(--gray-600); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.04em; }
        .pos-field input { width: 100%; padding: 10px 14px; border: 2px solid var(--gray-200); border-radius: 10px; font-size: 0.9375rem; font-family: 'JetBrains Mono', monospace; font-weight: 600; transition: border-color 0.2s; background: var(--gray-50); }
        .pos-field input:focus { outline: none; border-color: var(--primary); background: white; }
        .pos-field input:disabled { opacity: 0.45; cursor: not-allowed; }
        .pos-quick-label { font-size: 0.6875rem; font-weight: 700; color: var(--gray-500); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.04em; }
        .pos-quick-row { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 14px; }
        .pos-quick-btn { flex: 1; min-width: 0; padding: 7px 4px; border: 1.5px solid var(--gray-200); border-radius: 8px; background: white; font-size: 0.75rem; font-weight: 700; color: var(--gray-700); cursor: pointer; transition: all 0.15s; text-align: center; white-space: nowrap; }
        .pos-quick-btn:hover { border-color: var(--primary-light); color: var(--primary); background: var(--primary-ultra-light); }
        .pos-quick-btn.danger { border-color: #fca5a5; color: #dc2626; }
        .pos-quick-btn.danger:hover { background: #fef2f2; border-color: #ef4444; }
        .pos-quick-btn.success { border-color: #6ee7b7; color: #059669; }
        .pos-quick-btn.success:hover { background: #ecfdf5; border-color: #10b981; }
        .pos-buy-history { margin-top: 4px; padding-top: 12px; border-top: 1px dashed var(--gray-200); }
        .pos-buy-history-header { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
        .pos-buy-history-title { font-size: 0.6875rem; font-weight: 800; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.04em; }
        .pos-buy-history-actions { display: flex; gap: 8px; align-items: center; }
        .pos-buy-history-total { font-size: 0.75rem; font-weight: 800; color: var(--gray-800); font-family: 'JetBrains Mono', monospace; }
        .pos-buy-history-btn { border: 1.5px solid var(--gray-200); background: white; color: var(--gray-700); border-radius: 8px; padding: 6px 10px; font-size: 0.75rem; font-weight: 800; cursor: pointer; transition: all 0.15s; }
        .pos-buy-history-btn:hover { border-color: var(--gray-300); background: var(--gray-50); }
        .pos-buy-history-btn.danger { border-color: #fca5a5; color: #dc2626; }
        .pos-buy-history-btn.danger:hover { background: #fef2f2; border-color: #ef4444; }
        .pos-buy-history-list { display: flex; flex-direction: column; gap: 6px; max-height: 180px; overflow: auto; padding-right: 2px; }
        .pos-buy-history-list::-webkit-scrollbar { width: 4px; }
        .pos-buy-history-list::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 10px; }
        .pos-buy-item { display: flex; align-items: center; justify-content: space-between; gap: 10px; padding: 8px 10px; border: 1px solid var(--gray-200); border-radius: 12px; background: var(--gray-50); }
        .pos-buy-item-left { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
        .pos-buy-item-date { font-size: 0.8125rem; font-weight: 800; color: var(--gray-900); font-family: 'JetBrains Mono', monospace; }
        .pos-buy-item-sub { font-size: 0.75rem; color: var(--gray-500); font-weight: 700; }
        .pos-buy-item-right { display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
        .pos-buy-item-amt { font-size: 0.875rem; font-weight: 900; color: var(--gray-900); font-family: 'JetBrains Mono', monospace; }
        .pos-buy-item-del { width: 28px; height: 28px; border: none; background: white; border: 1px solid var(--gray-200); border-radius: 10px; cursor: pointer; color: var(--gray-500); font-size: 1rem; line-height: 1; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
        .pos-buy-item-del:hover { background: #fef2f2; border-color: #fecaca; color: #dc2626; }
        .pos-action-seg { display: flex; gap: 0; border: 2px solid var(--gray-200); border-radius: 12px; overflow: hidden; background: var(--gray-50); }
        .pos-action-btn { flex: 1; border: none; background: transparent; padding: 10px 10px; cursor: pointer; font-size: 0.875rem; font-weight: 900; color: var(--gray-700); transition: all 0.15s; }
        .pos-action-btn.active { background: white; color: var(--gray-900); box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
        .pos-action-btn.buy.active { border-right: 1px solid var(--gray-200); }
        .pos-action-btn.sell.active { border-left: 1px solid var(--gray-200); }
        .pos-action-btn:hover { background: rgba(255,255,255,0.9); }
        .pos-modal-footer { padding: 16px 24px 22px; display: flex; gap: 10px; justify-content: flex-end; }
        .pos-btn-cancel { padding: 9px 20px; border: 2px solid var(--gray-200); border-radius: 10px; background: white; font-size: 0.875rem; font-weight: 700; color: var(--gray-700); cursor: pointer; transition: all 0.15s; }
        .pos-btn-cancel:hover { border-color: var(--gray-300); background: var(--gray-50); }
        .pos-btn-save { padding: 9px 24px; border: none; border-radius: 10px; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; font-size: 0.875rem; font-weight: 700; cursor: pointer; transition: all 0.15s; box-shadow: 0 3px 10px rgba(59,130,246,0.3); }
        .pos-btn-save:hover { transform: translateY(-1px); box-shadow: 0 5px 16px rgba(59,130,246,0.4); }
        
        .fund-chart { height: 80px; background: var(--gray-50); border-radius: 10px; overflow: hidden; border: 1px solid var(--gray-200); }
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(255, 255, 255, 0.5); backdrop-filter: blur(10px); }
        .main-header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); padding: 24px 32px; }
        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .fund-title-main { font-size: 1.75rem; font-weight: 800; color: var(--gray-900); margin-bottom: 8px; }
        .fund-meta { display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
        .fund-code-large { font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; color: var(--gray-600); background: var(--gray-50); padding: 6px 14px; border-radius: 10px; font-weight: 600; border: 1px solid var(--gray-200); }
        .market-status { display: flex; align-items: center; gap: 8px; padding: 6px 14px; border-radius: 10px; font-size: 0.8125rem; font-weight: 600; }
        .market-status.open { background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; }
        .market-status.closed { background: var(--gray-50); color: var(--gray-700); border: 1px solid var(--gray-200); }
        .update-time { font-size: 0.8125rem; color: var(--gray-600); background: var(--gray-50); padding: 6px 14px; border-radius: 10px; border: 1px solid var(--gray-200); }
        .remind-chip { font-size: 0.8125rem; color: #b45309; background: rgba(245, 158, 11, 0.10); padding: 6px 12px; border-radius: 10px; border: 1px solid rgba(245, 158, 11, 0.22); cursor: pointer; user-select: none; font-weight: 700; display: inline-flex; align-items: center; gap: 6px; }
        .remind-chip.active { color: #047857; background: rgba(16, 185, 129, 0.10); border-color: rgba(16, 185, 129, 0.22); }
        .remind-chip.fired { color: var(--gray-700); background: var(--gray-50); border-color: var(--gray-200); }
        .remind-chip.alert { color: #b91c1c; background: #fef2f2; border-color: #fecaca; }
        .remind-chip.ring { animation: remindRing 0.8s ease-in-out infinite; transform-origin: 50% 0%; }
        @keyframes remindRing { 0% { transform: rotate(0deg); } 15% { transform: rotate(10deg); } 30% { transform: rotate(-10deg); } 45% { transform: rotate(8deg); } 60% { transform: rotate(-8deg); } 75% { transform: rotate(4deg); } 100% { transform: rotate(0deg); } }
        .remind-fired-hint { display: none; font-size: 0.75rem; color: var(--gray-700); background: white; border: 1px solid var(--gray-200); padding: 6px 10px; border-radius: 10px; cursor: pointer; user-select: none; max-width: 420px; }
        .remind-fired-hint.show { display: inline-flex; align-items: center; }
        .remind-fired-hint:hover { border-color: var(--gray-300); box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08); }
        .remind-fired-hint .rfh-viewport { height: 18px; overflow: hidden; display: block; }
        .remind-fired-hint .rfh-inner { display: block; will-change: transform; }
        .remind-fired-hint .rfh-item { height: 18px; line-height: 18px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
        .stat-card { background: white; padding: 20px; border-radius: 16px; border: 2px solid var(--gray-200); transition: all 0.3s; position: relative; overflow: hidden; }
        .stat-card:hover { border-color: var(--primary-light); transform: translateY(-4px); box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15); }
        .stat-label { font-size: 0.75rem; color: var(--gray-600); margin-bottom: 8px; text-transform: uppercase; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
        .stat-value { font-size: 1.875rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-bottom: 6px; }
        .stat-change { font-size: 0.875rem; font-weight: 600; display: flex; align-items: center; gap: 4px; }
        .chart-section { flex: 1; padding: 32px; overflow-y: auto; }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
        .chart-title { font-size: 1.25rem; font-weight: 800; color: var(--gray-900); }
        .time-tabs { display: flex; gap: 8px; background: white; padding: 6px; border-radius: 14px; border: 1px solid var(--gray-200); }
        .time-tab { padding: 8px 18px; border: none; background: transparent; border-radius: 10px; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.2s; color: var(--gray-600); }
        .time-tab.active { background: var(--primary); color: white; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
        .chart-row { display: flex; gap: 24px; height: 480px; margin-bottom: 24px; }
        .chart-main { flex: 2; min-width: 0; display: flex; flex-direction: column; }
        .chart-side { flex: 1; min-width: 340px; display: flex; flex-direction: column; }
        .chart-container { background: white; border-radius: 20px; padding: 24px; height: 100%; display: flex; flex-direction: column; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); margin-bottom: 0; }
        #klineChart { width: 100%; flex: 1; min-height: 0; }
        .side-card { background: white; border-radius: 20px; padding: 24px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); display: flex; flex-direction: column; height: 100%; min-height: 0; overflow: hidden; }
        .table-header { font-size: 1.125rem; font-weight: 800; color: var(--gray-900); margin-bottom: 16px; padding-bottom: 16px; border-bottom: 2px solid var(--gray-100); flex-shrink: 0; }
        .sector-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; flex-shrink: 0; }
        .sector-tag { display: inline-flex; align-items: center; padding: 4px 10px; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: var(--gray-50); border: 1px solid var(--gray-200); color: var(--gray-600); }
        .sector-tag.top10-weight { background: rgba(59, 130, 246, 0.08); border-color: rgba(59, 130, 246, 0.22); color: var(--primary-dark); }
        .sector-tag.positive { background: #fef2f2; border-color: #fee2e2; color: #dc2626; }
        .sector-tag.negative { background: #ecfdf5; border-color: #d1fae5; color: #059669; }

        .prebuy-tag { position: relative; display: inline-flex; align-items: center; padding: 2px 6px; margin-left: 6px; border-radius: 4px; font-size: 0.6875rem; font-weight: 600; line-height: 1; background: rgba(59, 130, 246, 0.10); border: 1px solid rgba(59, 130, 246, 0.22); color: var(--primary-dark); cursor: default; user-select: none; }
        .prebuy-tag::before,
        .prebuy-tag::after { opacity: 0; visibility: hidden; pointer-events: none; transform: translate(-50%, -6px); transition: opacity 0.16s ease, transform 0.16s ease, visibility 0.16s ease; }
        .prebuy-tag::after { content: attr(data-tooltip); position: absolute; left: 50%; bottom: calc(100% + 12px); width: max-content; max-width: min(360px, 70vw); white-space: normal; overflow-wrap: anywhere; word-break: break-word; padding: 10px 12px; border-radius: 12px; font-size: 0.8rem; font-weight: 600; line-height: 1.35; color: rgba(255,255,255,0.95); background: rgba(17,24,39,0.92); box-shadow: 0 12px 34px rgba(0,0,0,0.18); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 30; }
        .prebuy-tag::before { content: ''; position: absolute; left: 50%; bottom: calc(100% + 6px); width: 12px; height: 12px; background: rgba(17,24,39,0.92); transform: translate(-50%, -6px) rotate(45deg); border-radius: 3px; box-shadow: 0 8px 18px rgba(0,0,0,0.12); z-index: 29; }
        .prebuy-tag:hover::before,
        .prebuy-tag:hover::after,
        .prebuy-tag:focus-visible::before,
        .prebuy-tag:focus-visible::after { opacity: 1; visibility: visible; transform: translate(-50%, 0); }
        .side-scroll { flex: 1; overflow-y: auto; padding-right: 4px; }
        .side-scroll::-webkit-scrollbar { width: 4px; }
        .side-scroll::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 10px; }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        .side-scroll thead th { position: sticky; top: 0; background: white; z-index: 10; padding: 10px 8px; text-align: left; font-size: 0.75rem; font-weight: 700; color: var(--gray-500); border-bottom: 1px solid var(--gray-200); }
        .data-table-container thead th { padding: 10px 8px; text-align: left; font-size: 0.75rem; font-weight: 700; color: var(--gray-500); border-bottom: 1px solid var(--gray-200); }
        tbody td { padding: 10px 8px; border-bottom: 1px solid var(--gray-50); font-size: 0.875rem; color: var(--gray-800); }
        .side-scroll tbody tr { cursor: pointer; transition: background 0.15s; }
        .side-scroll tbody tr:hover { background: var(--gray-50); }
        .side-scroll tbody tr:hover td:first-child { color: var(--primary); text-decoration: underline; text-underline-offset: 3px; }
        .history-scroll { max-height: 360px; overflow-y: auto; }
        .data-table-container { background: white; border-radius: 20px; padding: 24px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); }
        .toast-container { position: fixed; top: 24px; right: 24px; display: flex; flex-direction: column; gap: 12px; z-index: 10000; pointer-events: none; }
        .toast { padding: 16px 24px; border-radius: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15); animation: slideIn 0.3s ease-out; background: white; border: 2px solid var(--gray-200); pointer-events: auto; }
        .toast.success { border-color: #10b981; background: #ecfdf5; }
        .toast.error { border-color: #ef4444; background: #fef2f2; }
        .toast .toast-row { display: flex; align-items: flex-start; gap: 12px; }
        .toast .toast-msg { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; line-height: 1.35; }
        .toast .toast-close { margin-left: auto; border: none; background: transparent; cursor: pointer; font-size: 1rem; line-height: 1; color: var(--gray-700); padding: 0 2px; }
        .toast .toast-close:hover { color: var(--gray-900); }
        @keyframes slideIn { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .empty-state { text-align: center; padding: 60px 32px; color: var(--gray-500); }
        .empty-icon { font-size: 4rem; margin-bottom: 16px; opacity: 0.5; }
        .empty-text { font-size: 1.125rem; font-weight: 600; color: var(--gray-700); margin-bottom: 8px; }
        .empty-subtext { font-size: 0.9375rem; }
        
        /* Êï∞ÊçÆÊ∫êÁä∂ÊÄÅÊåáÁ§∫Âô® */
        .source-indicator { position: fixed; bottom: 20px; left: 20px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 12px 16px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 1px solid var(--gray-200); font-size: 0.8125rem; z-index: 100; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: all 0.3s; }
        .source-indicator:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .source-indicator .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #10b981; animation: pulse 2s infinite; }
        .source-indicator .status-text { font-weight: 600; color: var(--gray-700); }
        .source-indicator .source-name { font-family: 'JetBrains Mono', monospace; color: var(--gray-500); font-size: 0.75rem; }
        
        /* Êï∞ÊçÆÊ∫êÁªüËÆ°ÂºπÁ™ó */
        .source-stats-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10001; display: none; align-items: center; justify-content: center; }
        .source-stats-modal.active { display: flex; }
        .source-stats-content { background: white; border-radius: 20px; padding: 32px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .source-stats-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 2px solid var(--gray-100); }
        .source-stats-title { font-size: 1.25rem; font-weight: 800; }
        .source-stats-close { width: 32px; height: 32px; border: none; background: var(--gray-100); border-radius: 8px; cursor: pointer; font-size: 1.25rem; }
        .source-stats-table { width: 100%; }
        .source-stats-table th { text-align: left; padding: 10px; background: var(--gray-50); font-size: 0.75rem; font-weight: 700; color: var(--gray-600); }
        .source-stats-table td { padding: 12px 10px; border-bottom: 1px solid var(--gray-100); font-size: 0.875rem; }
        .source-stats-table .success-rate { font-weight: 700; }
        .source-stats-table .success-rate.high { color: #10b981; }
        .source-stats-table .success-rate.medium { color: #f59e0b; }
        .source-stats-table .success-rate.low { color: #ef4444; }

        .swipe-hint { position: fixed; left: 12px; right: 12px; top: 50%; transform: translateY(-50%); display: none; align-items: center; justify-content: space-between; pointer-events: none; z-index: 2000; }
        .swipe-hint.show { display: flex; }
        .swipe-hint .arrow { width: 40px; height: 40px; border-radius: 999px; display: flex; align-items: center; justify-content: center; font-size: 26px; font-weight: 900; color: rgba(255,255,255,0.95); background: rgba(17,24,39,0.35); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); animation: swipeHintPulse 1.4s ease-in-out infinite; }
        .swipe-hint .text { flex: 1; text-align: center; margin: 0 10px; color: rgba(255,255,255,0.92); font-weight: 700; font-size: 0.95rem; text-shadow: 0 2px 10px rgba(0,0,0,0.35); }
        @keyframes swipeHintPulse { 0%,100% { transform: scale(1); opacity: 0.85; } 50% { transform: scale(1.08); opacity: 1; } }

        @media (hover: hover) and (pointer: fine) {
            .swipe-hint, .swipe-hint.show { display: none !important; }
        }
        
        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media (max-width: 1200px) { 
            .chart-row { height: auto; flex-direction: column; } 
            .chart-container { height: 400px; margin-bottom: 24px; } 
            .chart-side { min-width: 100%; }
            .side-card { height: 400px; } 
            .stats-grid { grid-template-columns: repeat(2, 1fr); } 
        }
        
        @media (max-width: 768px) { 
            .mobile-menu-btn { display: flex; }
            .sidebar { 
                width: 100%; 
                max-width: 380px;
                position: fixed; 
                z-index: 1000; 
                height: 100vh;
                transform: translateX(-100%); 
                transition: transform 0.3s; 
            }
            .sidebar.open { transform: translateX(0); }
            .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999; }
            .sidebar-overlay.active { display: block; }
            .main-content { margin-left: 0; touch-action: pan-y; }
            .main-header { padding: 80px 16px 16px; }
            .fund-title-main { font-size: 1.25rem; }
            .stats-grid { grid-template-columns: 1fr; gap: 12px; }
            .stat-card { padding: 16px; }
            .stat-value { font-size: 1.5rem; }
            .chart-section { padding: 16px; }
            .chart-container { padding: 16px; }
            .side-card { padding: 16px; }
            .fund-meta { gap: 8px; }
            .chart-header { flex-direction: column; align-items: flex-start; gap: 12px; }
            .time-tabs { width: 100%; justify-content: space-between; }
            .time-tab { padding: 8px 12px; font-size: 0.8125rem; }
            .input-row { grid-template-columns: 1fr; }
            .btn-add { width: 100%; }
            .source-indicator { display: none; } /* ÁßªÂä®Á´ØÈöêËóèÊï∞ÊçÆÊ∫êÊåáÁ§∫Âô® */
            .market-indices { padding: 0; }
            .indices-toggle { padding: 12px 16px; }
            .indices-inner { padding: 16px; }
            /* ÁßªÂä®Á´ØÊÅ¢Â§ç1Âàó */
            .indices-grid { grid-template-columns: 1fr; gap: 8px; }
            .index-card { padding: 10px 12px; min-height: auto; }
            .index-card.selected { grid-column: span 1; }
            .index-value { font-size: 1rem; }
        }
        
        @media (max-width: 480px) {
            .optional-inputs { grid-template-columns: 1fr; }
            .fund-code-large, .market-status, .update-time { font-size: 0.75rem; padding: 4px 10px; }
        }
    </style>
</head>
<body>
    <button class="mobile-menu-btn" id="mobileMenuBtn">
        <span></span>
        <span></span>
        <span></span>
    </button>
    
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="source-indicator" id="sourceIndicator">
        <div class="status-dot"></div>
        <div class="status-text">Êï∞ÊçÆÊ∫êËøêË°å‰∏≠</div>
        <div class="source-name" id="currentSourceName">fundgz_jsonp</div>
    </div>
    
    <div class="source-stats-modal" id="sourceStatsModal">
        <div class="source-stats-content">
            <div class="source-stats-header">
                <h3 class="source-stats-title">üìä Êï∞ÊçÆÊ∫êÁªüËÆ°</h3>
                <button class="source-stats-close" onclick="closeSourceStats()">√ó</button>
            </div>
            <table class="source-stats-table">
                <thead>
                    <tr>
                        <th>Êï∞ÊçÆÊ∫ê</th>
                        <th>ÊàêÂäü</th>
                        <th>Â§±Ë¥•</th>
                        <th>ÊàêÂäüÁéá</th>
                        <th>Âπ≥ÂùáËÄóÊó∂</th>
                    </tr>
                </thead>
                <tbody id="sourceStatsTableBody">
                    <tr><td colspan="5" style="text-align: center; padding: 20px; color: var(--gray-500);">ÊöÇÊó†Êï∞ÊçÆ</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- ÊåÅ‰ªìÁºñËæëÂØπËØùÊ°Ü -->
    <div class="pos-modal-overlay" id="posModalOverlay" onclick="posModalBgClick(event)">
        <div class="pos-modal">
            <div class="pos-modal-header">
                <div class="pos-modal-title" id="posModalTitle">ÁºñËæëÊåÅ‰ªì</div>
                <button class="pos-modal-close" onclick="closePosModal()">√ó</button>
            </div>
            <div class="pos-modal-body">
                <div class="pos-field">
                    <label>Âü∫Èáë‰ª£Á†Å</label>
                    <input type="text" id="posCode" disabled>
                </div>
                <div class="pos-field">
                    <label>Êìç‰ΩúÁ±ªÂûã</label>
                    <input type="hidden" id="posAction" value="buy">
                    <div class="pos-action-seg" role="tablist" aria-label="‰∫§ÊòìÁ±ªÂûã">
                        <button class="pos-action-btn buy active" id="posActionBuy" type="button" onclick="setPosAction('buy')">‰π∞ÂÖ• / Âä†‰ªì</button>
                        <button class="pos-action-btn sell" id="posActionSell" type="button" onclick="setPosAction('sell')">ÂçñÂá∫ / Âáè‰ªì</button>
                    </div>
                </div>
                <div class="pos-field">
                    <label id="posAmountLabel">‰π∞ÂÖ•ÈáëÈ¢ù</label>
                    <input type="number" id="posAmount" placeholder="Â¶Ç 10000" step="0.01">
                </div>
                <div class="pos-field">
                    <label id="posDateLabel">‰π∞ÂÖ•Êó∂Èó¥</label>
                    <input type="date" id="posBuyDate">
                </div>
                <div class="pos-quick-label">Âø´ÈÄüÊìç‰Ωú</div>
                <div class="pos-quick-row">
                    <button class="pos-quick-btn danger" onclick="posQuickAction('clear')">Ê∏Ö‰ªì</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('half')">1/2</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('third')">1/3</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('quarter')">1/4</button>
                    <button class="pos-quick-btn success" onclick="posQuickAction('double')">2√ó</button>
                </div>

                <div class="pos-buy-history" id="posBuyHistory">
                    <div class="pos-buy-history-header">
                        <div class="pos-buy-history-title">‰π∞ÂÖ•ÂéÜÂè≤</div>
                        <div class="pos-buy-history-actions">
                            <div class="pos-buy-history-total" id="posBuyHistoryTotal">--</div>
                            <button class="pos-buy-history-btn danger" onclick="clearPosBuys()">Ê∏ÖÁ©∫</button>
                        </div>
                    </div>
                    <div class="pos-buy-history-list" id="posBuyHistoryList"></div>
                </div>

                <div class="pos-buy-history" id="posSellHistory">
                    <div class="pos-buy-history-header">
                        <div class="pos-buy-history-title">ÂçñÂá∫ÂéÜÂè≤</div>
                        <div class="pos-buy-history-actions">
                            <div class="pos-buy-history-total" id="posSellHistoryTotal">--</div>
                            <button class="pos-buy-history-btn danger" onclick="clearPosSells()">Ê∏ÖÁ©∫</button>
                        </div>
                    </div>
                    <div class="pos-buy-history-list" id="posSellHistoryList"></div>
                </div>
            </div>
            <div class="pos-modal-footer">
                <button class="pos-btn-cancel" onclick="closePosModal()">ÂèñÊ∂à</button>
                <button class="pos-btn-save" onclick="savePosModal()">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>

    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="logo-card">
                    <div class="logo-content">
                        <div class="logo-icon">üìà</div>
                        <div class="logo">FundFlow</div>
                        <div class="logo-subtitle"><span class="status-indicator"></span><span>ÂÆûÊó∂ÁõëÊéßÁ≥ªÁªü</span></div>
                        <div class="logo-summary">
                            <div class="line"><span class="label">ÊåÅ‰ªìÈáëÈ¢ù</span><span id="allPositionAmount">--</span></div>
                            <div class="line"><span class="label">ÊåÅ‰ªìÊî∂Áõä</span><span id="allPositionProfit">--</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="market-indices">
                <button class="indices-toggle" onclick="toggleIndices()">
                    <div class="indices-toggle-left">
                        <div class="indices-title">
                            <span>üìä</span>
                            <span>Â∏ÇÂú∫ÊåáÊï∞</span>
                        </div>
                    </div>
                    <span class="indices-arrow" id="indicesArrow">‚ñº</span>
                </button>
                
                <div class="indices-content" id="indicesContent">
                    <div class="indices-inner">
                        <div class="indices-grid" id="indicesGrid">
                            </div>
                        <button class="indices-refresh" onclick="fetchMarketIndices()">üîÑ Âà∑Êñ∞ÊåáÊï∞</button>
                    </div>
                </div>
            </div>
            
            <div class="add-fund-section" style="padding:0; border-bottom:none;">
                <button class="add-fund-toggle" onclick="toggleAddFund()">
                    <div class="add-fund-toggle-left">
                        <span>Ôºã</span>
                        <span class="add-fund-toggle-title">Ê∑ªÂä†Âü∫Èáë</span>
                    </div>
                    <span class="add-fund-arrow" id="addFundArrow">‚ñº</span>
                </button>
                <div class="add-fund-body" id="addFundBody">
                    <div class="add-fund-inner">
                        <div class="input-row">
                            <input type="text" id="fundCode" class="input-field" placeholder="ËæìÂÖ•Âü∫Èáë‰ª£Á†Å">
                            <button onclick="addFund()" class="btn-add">Ê∑ªÂä†</button>
                        </div>
                        <div class="fund-suggest" id="fundSuggest"></div>
                        <div class="optional-inputs">
                            <input type="number" id="buyAmount" class="input-field input-small" placeholder="‰π∞ÂÖ•ÈáëÈ¢ù(ÂèØÈÄâ)">
                            <input type="date" id="buyDate" class="input-field input-small" placeholder="‰π∞ÂÖ•Êó∂Èó¥(ÂèØÈÄâ)">
                        </div>
                        <div class="helper-text"><span>üí°</span><span>ËæìÂÖ•ÊåÅ‰ªì‰ø°ÊÅØÂèØÊü•ÁúãÊî∂ÁõäËØ¶ÊÉÖ</span></div>
                    </div>
                </div>
            </div>
            <div class="fund-list" id="fundList"></div>
        </aside>

        <main class="main-content">
            <div class="swipe-hint" id="swipeHint" aria-hidden="true">
                <div class="arrow left">‚Äπ</div>
                <div class="text">Â∑¶Âè≥ÊªëÂä®ÂàáÊç¢Âü∫Èáë</div>
                <div class="arrow right">‚Ä∫</div>
            </div>
            <div class="main-header">
                <div class="header-top">
                    <div class="fund-title-section">
                        <h1 class="fund-title-main" id="selectedFundName">ÈÄâÊã©‰∏Ä‰∏™Âü∫ÈáëÂºÄÂßãÁõëÊéß</h1>
                        <div class="fund-meta">
                            <span class="fund-code-large" id="selectedFundCode">--</span>
                            <div class="market-status closed" id="marketStatus"><span>‚è∏</span><span id="marketStatusText">‰ºëÂ∏Ç‰∏≠</span></div>
                            <div class="update-time" id="updateTime">--</div>
                            <div class="remind-chip" id="remindChip" onclick="openReminderPrompt(event)">ÊèêÈÜí</div>
                            <div class="remind-fired-hint" id="remindFiredHint" onclick="jumpToLastFiredReminder(event)"></div>
                        </div>
                    </div>
                    <button class="header-collapse-btn" id="headerCollapseBtn" onclick="toggleHeaderStats()" title="ÊäòÂè†/Â±ïÂºÄ">‚ñº</button>
                </div>
                <div class="stats-grid-wrapper" id="statsGridWrapper">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">ÂΩìÂâçÂáÄÂÄº <span id="navDateLabel" style="background:var(--gray-100); padding:2px 6px; border-radius:4px; font-weight:500; font-size:0.65rem;">--</span></div>
                            <div class="stat-value" id="currentNav">--</div>
                            <div class="stat-change" id="navChange">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label"><span id="estLabel">‰º∞ÁÆóÂáÄÂÄº</span></div>
                            <div class="stat-value" id="estimatedNav">--</div>
                            <div class="stat-change" id="estimatedChange">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Êó•Ê∂®Ë∑åÂπÖ</div>
                            <div class="stat-value" id="dayGrowth">--</div>
                            <div class="stat-change" id="dayGrowthChange">--<span class="day-growth-source official" id="dayGrowthSource"></span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">ÊåÅ‰ªìÊî∂Áõä</div>
                            <div class="stat-value" id="totalProfit">--</div>
                            <div class="stat-change" id="profitPercent">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <div class="chart-header">
                    <h2 class="chart-title" id="chartTypeLabel">ÂáÄÂÄºËµ∞ÂäøÂõæ</h2>
                    <div class="time-tabs">
                        <button class="time-tab active" onclick="changeTimeRange('realtime')">ÂÆûÊó∂</button>
                        <button class="time-tab" onclick="changeTimeRange('5d')">1Âë®</button>
                        <button class="time-tab" onclick="changeTimeRange('1m')">1Êúà</button>
                        <button class="time-tab" onclick="changeTimeRange('3m')">3Êúà</button>
                        <button class="time-tab" onclick="changeTimeRange('1y')">1Âπ¥</button>
                        <button class="time-tab" onclick="changeTimeRange('all')">ÊàêÁ´ãÊù•</button>
                    </div>
                </div>
                <div class="chart-row">
                    <div class="chart-main">
                        <div class="chart-container"><div id="klineChart"></div></div>
                    </div>
                    <div class="chart-side">
                        <div class="side-card">
                            <div class="table-header">Âü∫ÈáëÊåÅ‰ªìÔºàTOP 10Ôºâ</div>
                            <div id="sectorTags" class="sector-tags"><span style="font-size: 0.8125rem; color: var(--gray-500);">ÊöÇÊó†Êï∞ÊçÆ</span></div>
                            <div class="side-scroll">
                                <table>
                                    <thead><tr><th>ËÇ°Á•®</th><th>‰ª£Á†Å</th><th>Âç†ÊØî</th><th>Ê∂®Ë∑åÂπÖ</th></tr></thead>
                                    <tbody id="holdingsTableBody"><tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">ËØ∑ÈÄâÊã©Âü∫Èáë</td></tr></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="data-table-container">
                    <div class="table-header">ÂéÜÂè≤ÂáÄÂÄºÊï∞ÊçÆ</div>
                    <div class="history-scroll" id="historyScroll">
                        <table>
                            <thead><tr><th>Êó•Êúü</th><th>Âçï‰ΩçÂáÄÂÄº</th><th>Êó•Â¢ûÈïøÁéá</th><th>Êó•ÂáÄÊî∂Áõä</th></tr></thead>
                            <tbody id="historyTableBody"><tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">ÊöÇÊó†Êï∞ÊçÆ</td></tr></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let funds = JSON.parse(localStorage.getItem('funds') || '[]');
        let selectedFund = null;
        let holdingsCache = {}; // { [fundCode]: { holdings: [{code, ratio, chg}], top10Weight, top10Contribution, estDayChg, timestamp } }
        let chart = null;
        let miniCharts = {};
        let updateInterval = null;
        let realtimeInterval = null;
        let currentTimeRange = 'realtime';
        let historyCache = {}; // { [fundCode]: [{x, y}, ...] } ÁºìÂ≠ò pingzhongdata ÂÖ®ÈÉ®ÂéÜÂè≤
        let historyTableState = { code: null, rendered: 0, pageSize: 10 };
        let fundgzQueue = Promise.resolve();
        let marketIndices = {};
        let selectedIndexKey = null;
        let indexCharts = {};
        let indexTrendCache = {}; // { [indexKey]: { times: [], prices: [], preClose: number, updatedAt: number } }
        let refreshInterval = null;
        let refreshLock = Promise.resolve();
        let lastFundRefreshAt = 0;
        let lastIndicesRefreshAt = 0;
        let lastHoldingsRefreshAt = 0;
        let refreshTick = 0;
        let fundRefreshCursor = 0;

        // Ê∑ªÂä†Âü∫ÈáëÂå∫ÂüüÊäòÂè†
        function toggleAddFund() {
            const body = document.getElementById('addFundBody');
            const arrow = document.getElementById('addFundArrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        // ============================================================
        // ÊåÅ‰ªìÁºñËæëÂØπËØùÊ°Ü
        // ============================================================
        let _posEditCode = null; // ÂΩìÂâçÊ≠£Âú®ÁºñËæëÁöÑÂü∫Èáë‰ª£Á†Å

        function openPosModal(code) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            _posEditCode = code;
            document.getElementById('posModalTitle').textContent = `ÁºñËæëÊåÅ‰ªì ‚Äî ${fund.name || code}`;
            document.getElementById('posCode').value = code;
            setPosAction('buy');
            document.getElementById('posAmount').value = '';
            document.getElementById('posBuyDate').value = '';
            renderPosBuyHistory(fund);
            renderPosSellHistory(fund);
            document.getElementById('posModalOverlay').classList.add('active');
            // Áü≠Âª∂ËøüÂêé focus ÈáëÈ¢ùËæìÂÖ•Ê°Ü
            setTimeout(() => document.getElementById('posAmount').focus(), 120);
        }

        function setPosAction(action) {
            const v = (action === 'sell') ? 'sell' : 'buy';
            const input = document.getElementById('posAction');
            if (input) input.value = v;
            const buyBtn = document.getElementById('posActionBuy');
            const sellBtn = document.getElementById('posActionSell');
            if (buyBtn) buyBtn.classList.toggle('active', v === 'buy');
            if (sellBtn) sellBtn.classList.toggle('active', v === 'sell');
            const amountLabel = document.getElementById('posAmountLabel');
            const dateLabel = document.getElementById('posDateLabel');
            if (amountLabel) amountLabel.textContent = (v === 'sell') ? 'ÂçñÂá∫ÈáëÈ¢ù' : '‰π∞ÂÖ•ÈáëÈ¢ù';
            if (dateLabel) dateLabel.textContent = (v === 'sell') ? 'ÂçñÂá∫Êó∂Èó¥' : '‰π∞ÂÖ•Êó∂Èó¥';

            const buyHist = document.getElementById('posBuyHistory');
            const sellHist = document.getElementById('posSellHistory');
            if (buyHist) buyHist.style.display = (v === 'buy') ? '' : 'none';
            if (sellHist) sellHist.style.display = (v === 'sell') ? '' : 'none';
        }

        function closePosModal() {
            document.getElementById('posModalOverlay').classList.remove('active');
            _posEditCode = null;
        }

        function posModalBgClick(e) {
            if (e.target === document.getElementById('posModalOverlay')) closePosModal();
        }

        function savePosModal() {
            if (!_posEditCode) return;
            const fund = funds.find(f => f.code === _posEditCode);
            if (!fund) return;
            const amountVal = document.getElementById('posAmount').value.trim();
            const buyDateVal = (document.getElementById('posBuyDate').value || '').trim();
            let amount = amountVal !== '' ? parseFloat(amountVal) : NaN;
            const date = buyDateVal !== '' ? buyDateVal : '';
            if (!Number.isFinite(amount)) amount = NaN;
            const action = (document.getElementById('posAction')?.value || 'buy');

            // Êú™ËæìÂÖ•Áõ¥Êé•‰øùÂ≠òÔºö‰∏çÂÅö‰ªª‰Ωï‰øÆÊîπ
            if (amountVal === '' && date === '') {
                closePosModal();
                return;
            }

            // ÈáëÈ¢ù>0‰ΩÜÊó•Êúü‰∏çÂêàÊ≥ïÔºö‰∏çÂÖÅËÆ∏‰øùÂ≠òÔºà‰π∞ÂÖ•/ÂçñÂá∫ÈÉΩ‰∏ÄÊ†∑Ôºâ
            if (Number.isFinite(amount) && amount > 0 && !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                showToast('ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑÊó•Êúü', 'error');
                return;
            }

            if (action === 'sell') {
                // Ê∏Ö‰ªìÔºöÈáëÈ¢ù <= 0 ÊàñÁ©∫ => ËÆ∞ÂΩï‚ÄúÂçñÂá∫ÂÖ®ÈÉ®‚Äù
                if (!Array.isArray(fund.sells)) fund.sells = [];
                if (!Number.isFinite(amount) || amount <= 0) {
                    const sh = getShanghaiTimeParts();
                    const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
                    if (!fund.sells.some(x => x && x.all === true && x.date === todayStr)) fund.sells.push({ date: todayStr, all: true });
                } else {
                    const idx = fund.sells.findIndex(x => x && x.date === date && x.all !== true);
                    if (idx >= 0) {
                        const prevAmt = Number(fund.sells[idx].amount);
                        fund.sells[idx].amount = (Number.isFinite(prevAmt) ? prevAmt : 0) + amount;
                    } else {
                        fund.sells.push({ amount, date, all: false });
                    }
                }
            } else {
                // ‰π∞ÂÖ•
                if (!Array.isArray(fund.buys)) fund.buys = [];
                if (!Number.isFinite(amount) || amount <= 0) {
                    showToast('ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑ‰π∞ÂÖ•ÈáëÈ¢ù', 'error');
                    return;
                }
                const idx = fund.buys.findIndex(x => x && x.date === date);
                if (idx >= 0) {
                    const prevAmt = Number(fund.buys[idx].amount);
                    fund.buys[idx].amount = (Number.isFinite(prevAmt) ? prevAmt : 0) + amount;
                } else {
                    fund.buys.push({ amount, date });
                }
                // ÊóßÂ≠óÊÆµ‰øùÁïô‰ΩÜ‰∏çÂÜçÁª¥Êä§
                fund.buyAmount = null;
                fund.buyDate = null;
            }
            saveFunds();
            closePosModal();
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === _posEditCode || selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('ÊåÅ‰ªì‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞');
        }

        function renderPosBuyHistory(fund) {
            const wrap = document.getElementById('posBuyHistory');
            const list = document.getElementById('posBuyHistoryList');
            const totalEl = document.getElementById('posBuyHistoryTotal');
            if (!wrap || !list || !totalEl) return;
            const buys = getFundBuys(fund);
            const total = buys.reduce((s, b) => s + (Number(b.amount) || 0), 0);
            totalEl.textContent = `ÂêàËÆ° ¬•${total.toFixed(2)}`;
            if (!buys.length) {
                list.innerHTML = `<div style="text-align:center;color:var(--gray-500);font-size:0.8125rem;padding:10px 0;font-weight:700;">ÊöÇÊó†‰π∞ÂÖ•ËÆ∞ÂΩï</div>`;
                return;
            }
            list.innerHTML = buys.map(b => {
                const eff = getFirstHistoryPointOnOrAfter(fund.code, b.date)?.date;
                const sub = eff ? `È¢ÑËÆ° ${eff} ÁîüÊïà` : 'ÂæÖÂáÄÂÄºÊä´Èú≤ÂêéÁîüÊïà';
                const key = `${b.date}|${Number(b.amount).toFixed(2)}`;
                return `
                    <div class="pos-buy-item">
                        <div class="pos-buy-item-left">
                            <div class="pos-buy-item-date">${b.date}</div>
                            <div class="pos-buy-item-sub">${sub}</div>
                        </div>
                        <div class="pos-buy-item-right">
                            <div class="pos-buy-item-amt">¬•${Number(b.amount).toFixed(2)}</div>
                            <button class="pos-buy-item-del" onclick="removePosBuyEntry('${fund.code}','${key}')" title="Âà†Èô§">√ó</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPosSellHistory(fund) {
            const wrap = document.getElementById('posSellHistory');
            const list = document.getElementById('posSellHistoryList');
            const totalEl = document.getElementById('posSellHistoryTotal');
            if (!wrap || !list || !totalEl) return;
            const sells = getFundSells(fund);
            const total = sells.reduce((s, x) => s + (x && !x.all ? (Number(x.amount) || 0) : 0), 0);
            totalEl.textContent = `ÂêàËÆ° ¬•${total.toFixed(2)}`;
            if (!sells.length) {
                list.innerHTML = `<div style="text-align:center;color:var(--gray-500);font-size:0.8125rem;padding:10px 0;font-weight:700;">ÊöÇÊó†ÂçñÂá∫ËÆ∞ÂΩï</div>`;
                return;
            }
            list.innerHTML = sells.map(s => {
                const eff = getFirstHistoryPointOnOrAfter(fund.code, s.date)?.date;
                const sub = eff ? `È¢ÑËÆ° ${eff} ÁîüÊïà` : 'ÂæÖÂáÄÂÄºÊä´Èú≤ÂêéÁîüÊïà';
                const key = s.all ? `${s.date}|ALL` : `${s.date}|${Number(s.amount).toFixed(2)}`;
                const amtText = s.all ? 'Ê∏Ö‰ªì' : `¬•${Number(s.amount).toFixed(2)}`;
                return `
                    <div class="pos-buy-item">
                        <div class="pos-buy-item-left">
                            <div class="pos-buy-item-date">${s.date}</div>
                            <div class="pos-buy-item-sub">${sub}</div>
                        </div>
                        <div class="pos-buy-item-right">
                            <div class="pos-buy-item-amt">${amtText}</div>
                            <button class="pos-buy-item-del" onclick="removePosSellEntry('${fund.code}','${key}')" title="Âà†Èô§">√ó</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function removePosBuyEntry(code, key) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            const [date, amtStr] = (key || '').split('|');
            const amt = Number(amtStr);
            let changed = false;
            if (Array.isArray(fund.buys)) {
                const before = fund.buys.length;
                fund.buys = fund.buys.filter(b => !(b && b.date === date && Number(Number(b.amount).toFixed(2)) === Number(amt.toFixed(2))));
                if (fund.buys.length !== before) changed = true;
            }
            const legacyAmt = Number(fund.buyAmount);
            const legacyDate = (fund.buyDate || '').toString();
            if (!changed && legacyDate === date && Number.isFinite(legacyAmt) && Number(legacyAmt.toFixed(2)) === Number(amt.toFixed(2))) {
                fund.buyAmount = null;
                fund.buyDate = null;
                changed = true;
            }
            if (!changed) return;
            saveFunds();
            renderPosBuyHistory(fund);
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('Â∑≤Âà†Èô§‰∏ÄÁ¨î‰π∞ÂÖ•ËÆ∞ÂΩï');
        }

        function removePosSellEntry(code, key) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            const [date, val] = (key || '').split('|');
            let changed = false;
            if (Array.isArray(fund.sells)) {
                const before = fund.sells.length;
                if (val === 'ALL') {
                    fund.sells = fund.sells.filter(s => !(s && s.date === date && s.all === true));
                } else {
                    const amt = Number(val);
                    fund.sells = fund.sells.filter(s => !(s && s.date === date && !s.all && Number(Number(s.amount).toFixed(2)) === Number(amt.toFixed(2))));
                }
                if (fund.sells.length !== before) changed = true;
            }
            if (!changed) return;
            saveFunds();
            renderPosSellHistory(fund);
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('Â∑≤Âà†Èô§‰∏ÄÁ¨îÂçñÂá∫ËÆ∞ÂΩï');
        }

        function clearPosBuys() {
            if (!_posEditCode) return;
            const fund = funds.find(f => f.code === _posEditCode);
            if (!fund) return;
            const buys = getFundBuys(fund);
            if (!buys.length) return;
            fund.buys = [];
            fund.buyAmount = null;
            fund.buyDate = null;
            saveFunds();
            renderPosBuyHistory(fund);
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('Â∑≤Ê∏ÖÁ©∫‰π∞ÂÖ•ÂéÜÂè≤');
        }

        function clearPosSells() {
            if (!_posEditCode) return;
            const fund = funds.find(f => f.code === _posEditCode);
            if (!fund) return;
            const sells = getFundSells(fund);
            if (!sells.length) return;
            fund.sells = [];
            // clears ‰ªÖ‰ΩúÂÖºÂÆπËØªÂèñÔºå‰∏çÊ∏ÖÁêÜ‰πü‰ºöÁªßÁª≠ÊòæÁ§∫ÔºõËøôÈáåÂêåÊ≠•Ê∏ÖÊéâÈÅøÂÖçÈáçÂ§çÂ±ïÁ§∫
            fund.clears = [];
            saveFunds();
            renderPosSellHistory(fund);
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('Â∑≤Ê∏ÖÁ©∫ÂçñÂá∫ÂéÜÂè≤');
        }

        function posQuickAction(action) {
            const amountInput = document.getElementById('posAmount');
            const current = parseFloat(amountInput.value) || 0;
            switch (action) {
                case 'clear':
                    // Ê∏Ö‰ªìÂ±û‰∫éÂçñÂá∫
                    setPosAction('sell');
                    amountInput.value = '0';
                    break;
                case 'half':
                    amountInput.value = (current / 2).toFixed(2);
                    break;
                case 'third':
                    amountInput.value = (current / 3).toFixed(2);
                    break;
                case 'quarter':
                    amountInput.value = (current / 4).toFixed(2);
                    break;
                case 'double':
                    amountInput.value = (current * 2).toFixed(2);
                    break;
            }
            amountInput.dispatchEvent(new Event('input'));
        }

        // ‰∏ªÈ°µÊ†áÈ¢òÊ†è stats ÊäòÂè†/Â±ïÂºÄ
        function toggleHeaderStats() {
            const wrapper = document.getElementById('statsGridWrapper');
            const btn = document.getElementById('headerCollapseBtn');
            if (!wrapper) return;
            wrapper.classList.toggle('collapsed');
            if (btn) btn.textContent = wrapper.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
        }

        // ÊäòÂè†/Â±ïÂºÄÂ∏ÇÂú∫ÊåáÊï∞
        function toggleIndices() {
            const content = document.getElementById('indicesContent');
            const arrow = document.getElementById('indicesArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
            if (content.classList.contains('open') && Object.keys(marketIndices).length === 0) {
                fetchMarketIndices();
            }
        }

        // Â∏ÇÂú∫ÊåáÊï∞ÈÖçÁΩÆ
        const MARKET_INDICES = {
            sh000001: { name: '‰∏äËØÅÊåáÊï∞', flag: 'üá®üá≥', secid: '1.000001', type: 'cn' },
            sz399001: { name: 'Ê∑±ËØÅÊàêÊåá', flag: 'üá®üá≥', secid: '0.399001', type: 'cn' },
            sz399006: { name: 'Âàõ‰∏öÊùøÊåá', flag: 'üá®üá≥', secid: '0.399006', type: 'cn' },
            us_dji: { name: 'ÈÅìÁêºÊñØ', flag: 'üá∫üá∏', secid: '100.DJIA', type: 'us' },
            us_ixic: { name: 'Á∫≥ÊñØËææÂÖã', flag: 'üá∫üá∏', secid: '100.NDX', type: 'us' },
            us_spx: { name: 'Ê†áÊôÆ500', flag: 'üá∫üá∏', secid: '100.SPX', type: 'us' }
        };

        async function fetchMarketIndices() {
            const grid = document.getElementById('indicesGrid');
            if (!grid) return;

            const nowTs = Date.now();
            const trendTasks = [];
            for (const [k, cfg] of Object.entries(MARKET_INDICES)) {
                if (cfg.type !== 'cn') continue;
                const cached = indexTrendCache[k];
                const fresh = cached && (nowTs - (cached.updatedAt || 0) < 20000);
                if (!fresh) trendTasks.push(fetchIndexTrendSnapshot(k, cfg));
            }
            if (trendTasks.length > 0) {
                await Promise.allSettled(trendTasks);
            }

            const indexSources = [
                {
                    name: 'eastmoney_api',
                    fetch: async (secid) => {
                        const url = `https://push2.eastmoney.com/api/qt/stock/get?secid=${secid}&fields=f43,f3,f169,f170,f60,f86&_=${Date.now()}`;
                        return await runWithSourceStat('index_stock_get_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                    }
                }
            ];

            const indexCards = [];
            
            for (const [key, config] of Object.entries(MARKET_INDICES)) {
                let data = null;
                
                for (const source of indexSources) {
                    try {
                        const result = await Promise.race([
                            source.fetch(config.secid),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 8000))
                        ]);
                        if (result?.data) { data = result.data; break; }
                    } catch (error) {
                        console.warn(`[ÊåáÊï∞-${config.name}-${source.name}] Â§±Ë¥•:`, error.message);
                        continue;
                    }
                }

                if (data) {
                    const price = (data.f43 !== undefined && data.f43 !== null && data.f43 !== '-') ? data.f43 : data.f60;
                    const priceNum = Number(price);
                    const isCn = config.type === 'cn';
                    let isClosed = false;
                    if (isCn) {
                        const s = getMarketStatus();
                        isClosed = !s.isOpen;
                    } else {
                        if (config.type === 'us') {
                            isClosed = !isUsMarketOpenNow();
                        } else {
                            const today = new Date();
                            const day = today.getDay();
                            if (day === 0 || day === 6) isClosed = true;
                        }
                    }

                    let changePct = 0;
                    const f3Num = (data.f3 !== undefined && data.f3 !== null && data.f3 !== '-') ? parseFloat(data.f3) : NaN;
                    const f170Num = (data.f170 !== undefined && data.f170 !== null && data.f170 !== '-') ? Number(data.f170) : NaN;
                    const closeRawNum = Number(data.f43);
                    const preCloseRawNum = Number(data.f60);
                    const closeForPctNum = Number.isFinite(closeRawNum) ? closeRawNum : priceNum;
                    // AËÇ°Âú®‰ºëÂ∏ÇÊó∂ÔºöÁî®ÊúÄËøëÊî∂ÁõòÂè£ÂæÑÔºàÊî∂Áõò‰ª∑ vs Êò®Êî∂Ôºâ
                    if (isCn && isClosed) {
                        if (Number.isFinite(closeForPctNum) && Number.isFinite(preCloseRawNum) && preCloseRawNum !== 0) {
                            changePct = (closeForPctNum - preCloseRawNum) / preCloseRawNum * 100;
                        } else if (Number.isFinite(f170Num) && Number.isFinite(priceNum)) {
                            const preClose = priceNum - f170Num;
                            if (preClose) changePct = (f170Num / preClose) * 100;
                        } else if (Number.isFinite(f3Num)) {
                            changePct = f3Num;
                        }
                    } else {
                        // ‰∫§Êòì‰∏≠ÔºàÊàñÈùûAËÇ°ÊåáÊï∞ÔºâÔºö‰ºòÂÖàÁî®Êé•Âè£ÂÆûÊó∂Ê∂®Ë∑åÂπÖ
                        if (Number.isFinite(f3Num)) {
                            changePct = f3Num;
                        } else if (Number.isFinite(f170Num) && Number.isFinite(priceNum)) {
                            const preClose = priceNum - f170Num;
                            if (preClose) changePct = (f170Num / preClose) * 100;
                        }
                    }

                    // ÂÖúÂ∫ïÔºöÈÉ®ÂàÜÊåáÊï∞Âú®‰∫§Êòì‰∏≠ f3/f170 ÂèØËÉΩÁº∫Â§±ÊàñËøîÂõû 0Ôºå‰ΩÜ f43/f60 ÊòØÂèØÈù†ÁöÑÔºàÁé∞‰ª∑/Êò®Êî∂Ôºâ
                    if ((!Number.isFinite(changePct) || Math.abs(changePct) < 1e-9) && Number.isFinite(closeForPctNum) && Number.isFinite(preCloseRawNum) && preCloseRawNum !== 0) {
                        changePct = (closeForPctNum - preCloseRawNum) / preCloseRawNum * 100;
                    }
                    const updateTime = data.f86 || '--';
                    const isPositive = changePct >= 0;
                    let finalPrice = price > 10000 && config.type === 'cn' ? (price/100).toFixed(2) : (price/100).toFixed(2);
                    let formattedChange = (changePct !== undefined) ? (isPositive ? '+' : '') + parseFloat(changePct).toFixed(2) + '%' : '--';
                    
                    let timeStr = '--';
                    if (updateTime && updateTime !== '--') {
                        const d = new Date(updateTime * 1000);
                        timeStr = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                    }

                    // Â¶ÇÊûúËØ•ÊåáÊï∞Â∑≤ÁªèÂ±ïÂºÄËøáÂπ∂ÊãâÂèñ‰∫Ü trends2/getÔºåÂàôÁî®Ëµ∞ÂäøÁºìÂ≠òË¶ÜÁõñÂç°Áâá‰ª∑Ê†º‰∏éÊ∂®Ë∑åÂπÖÔºåÁ°Æ‰øù‰∏éÂõæÂØπÈΩê
                    {
                        const cached = indexTrendCache[key];
                        const fresh = cached && (nowTs - (cached.updatedAt || 0) < 2 * 60 * 1000);
                        const lastPrice = fresh ? cached.prices?.[cached.prices.length - 1] : NaN;
                        const preClose = fresh ? cached.preClose : NaN;
                        const pct = (fresh && Number.isFinite(lastPrice) && Number.isFinite(preClose) && preClose !== 0) ? ((lastPrice - preClose) / preClose * 100) : NaN;
                        if (fresh && Number.isFinite(lastPrice)) {
                            finalPrice = lastPrice.toFixed(2);
                            if (Number.isFinite(pct)) {
                                changePct = pct;
                                formattedChange = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                            }
                            if (Array.isArray(cached.times) && cached.times.length > 0) timeStr = cached.times[cached.times.length - 1] || timeStr;
                        }
                    }
                    
                    marketIndices[key] = { price: finalPrice, change: changePct, changePct: formattedChange, time: timeStr, secid: config.secid, name: config.name };
                    
                    indexCards.push(`
                        <div class="index-card ${isPositive ? 'positive' : 'negative'} ${selectedIndexKey === key ? 'selected' : ''} ${isClosed ? 'closed' : ''}" 
                             onclick="selectIndex('${key}')" id="indexCard_${key}">
                            <div class="index-header">
                                <div class="index-name"><span class="index-flag">${config.flag}</span>${config.name}</div>
                                <span class="index-status-badge">${isClosed ? '‰ºëÂ∏Ç' : '‰∫§Êòì‰∏≠'}</span>
                            </div>
                            <div class="index-body">
                                <div class="index-value">${finalPrice}</div>
                                <div class="index-change">${formattedChange}</div>
                            </div>
                            <div class="index-chart-container" id="chartContainer_${key}" style="display: none;">
                                <div class="index-mini-chart" id="indexChart_${key}"></div>
                            </div>
                        </div>
                    `);
                } else {
                    indexCards.push(`
                        <div class="index-card">
                            <div class="index-header"><div class="index-name"><span class="index-flag">${config.flag}</span>${config.name}</div></div>
                            <div class="index-body"><div class="index-value">---</div><div class="index-change">Âä†ËΩΩÂ§±Ë¥•</div></div>
                        </div>
                    `);
                }
            }
            grid.innerHTML = indexCards.join('');

            // Ëã•ÂΩìÂâçÊúâÈÄâ‰∏≠ÁöÑÊåáÊï∞Âç°ÁâáÔºàÂ±ïÂºÄ‰∏≠ÔºâÔºåÂà∑Êñ∞ DOM ÂêéÈúÄË¶ÅÊÅ¢Â§çÂ±ïÂºÄÁä∂ÊÄÅÂπ∂ÈáçÁªòÂõæË°®
            if (selectedIndexKey) {
                const card = document.getElementById(`indexCard_${selectedIndexKey}`);
                const container = document.getElementById(`chartContainer_${selectedIndexKey}`);
                if (card) card.classList.add('selected');
                if (container) container.style.display = 'block';

                // DOM Ë¢´ÈáçÂª∫ÂêéÔºåÊóß echarts ÂÆû‰æãÂ∑≤ÁªëÂÆöÊóß DOMÔºåÈúÄË¶ÅÈáäÊîæÂπ∂Âú®Êñ∞ DOM ‰∏äÈáçÁªò
                if (indexCharts[selectedIndexKey]) {
                    try { indexCharts[selectedIndexKey].dispose(); } catch {}
                    delete indexCharts[selectedIndexKey];
                }

                const cached = indexTrendCache[selectedIndexKey];
                const fresh = cached && (Date.now() - (cached.updatedAt || 0) < 5 * 60 * 1000);
                if (fresh) {
                    drawIndexMiniChart(selectedIndexKey, cached);
                } else {
                    // ÁºìÂ≠ò‰∏çÂ≠òÂú®ÊàñËøáÊúüÔºöÈáçÊñ∞ÊãâÂèñ‰∏ÄÊ¨°ÔºàÂè™ÂØπÂΩìÂâçÂ±ïÂºÄÁöÑÊåáÊï∞ÊâßË°åÔºâ
                    fetchAndDrawIndexKline(selectedIndexKey);
                }
            }
        }
        
        async function selectIndex(key) {
            if (selectedIndexKey) {
                const prevCard = document.getElementById(`indexCard_${selectedIndexKey}`);
                const prevContainer = document.getElementById(`chartContainer_${selectedIndexKey}`);
                if (prevCard) prevCard.classList.remove('selected');
                if (prevContainer) prevContainer.style.display = 'none';
            }
            if (selectedIndexKey === key) { selectedIndexKey = null; return; }
            
            selectedIndexKey = key;
            const card = document.getElementById(`indexCard_${key}`);
            const container = document.getElementById(`chartContainer_${key}`);
            
            if (card) card.classList.add('selected');
            if (container) {
                container.style.display = 'block';
                if (indexCharts[key]) indexCharts[key].dispose();
                await fetchAndDrawIndexKline(key);
            }
        }
        
        function parseTrendTime(str) {
            if (!str) return '';
            let match = str.match(/(\d{2}):(\d{2})/);
            if (match) return `${match[1]}:${match[2]}`;
            if (str.length >= 12 && !isNaN(str)) return str.substring(8, 10) + ':' + str.substring(10, 12);
            return str;
        }

        function isAshareTradingTimeLabel(hhmm) {
            const m = (hhmm || '').match(/^(\d{2}):(\d{2})$/);
            if (!m) return true;
            const min = parseInt(m[1], 10) * 60 + parseInt(m[2], 10);
            return (min >= 570 && min <= 690) || (min >= 780 && min <= 900);
        }

        async function fetchIndexTrendSnapshot(key, config) {
            try {
                const url = `https://push2.eastmoney.com/api/qt/stock/trends2/get?secid=${config.secid}&fields1=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13&fields2=f51,f53&_=${Date.now()}`;
                const result = await runWithSourceStat('index_trends2_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                const d = result?.data;
                const trends = d?.trends;
                const preClose = Number(d?.preClose);
                if (!Array.isArray(trends) || trends.length === 0 || !Number.isFinite(preClose)) return;
                const times = [];
                const prices = [];
                for (const item of trends) {
                    const parts = String(item).split(',');
                    const t = parseTrendTime(parts[0]);
                    if (config.type === 'cn' && !isAshareTradingTimeLabel(t)) continue;
                    const p = parseFloat(parts[1]);
                    if (!Number.isFinite(p)) continue;
                    times.push(t);
                    prices.push(p);
                }
                if (times.length === 0 || prices.length === 0) return;
                indexTrendCache[key] = { times, prices, preClose, updatedAt: Date.now() };
            } catch {
            }
        }

        function drawIndexMiniChart(key, cached) {
            const chartDom = document.getElementById(`indexChart_${key}`);
            if (!chartDom) return;
            const times = cached?.times || [];
            const prices = cached?.prices || [];
            const preClose = cached?.preClose;
            if (!Array.isArray(times) || !Array.isArray(prices) || times.length === 0 || prices.length === 0 || !Number.isFinite(preClose)) {
                chartDom.innerHTML = '<div style="text-align:center;color:var(--gray-500);padding:60px 0;font-size:0.75rem;">ÊöÇÊó†Êï∞ÊçÆ</div>';
                return;
            }

            // Áî®Ëµ∞ÂäøÊï∞ÊçÆÂõûÂ°´Âç°ÁâáÊòæÁ§∫Ôºà‰ΩøÂç°ÁâáÊ∂®Ë∑åÂπÖ‰∏éÂõæ‰∏≠ÊúÄÊñ∞ÁÇπÂØπÈΩêÔºâ
            {
                const lastPrice = prices[prices.length - 1];
                const pct = (Number.isFinite(lastPrice) && Number.isFinite(preClose) && preClose !== 0) ? ((lastPrice - preClose) / preClose * 100) : NaN;
                const card = document.getElementById(`indexCard_${key}`);
                if (card && Number.isFinite(lastPrice)) {
                    const valueEl = card.querySelector('.index-value');
                    if (valueEl) valueEl.textContent = lastPrice.toFixed(2);
                    const changeEl = card.querySelector('.index-change');
                    if (changeEl && Number.isFinite(pct)) changeEl.textContent = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                }
                if (marketIndices[key]) {
                    if (Number.isFinite(lastPrice)) marketIndices[key].price = lastPrice.toFixed(2);
                    if (Number.isFinite(pct)) {
                        marketIndices[key].change = pct;
                        marketIndices[key].changePct = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                    }
                    if (times.length > 0) marketIndices[key].time = times[times.length - 1] || marketIndices[key].time;
                }
            }

            const indexChart = echarts.init(chartDom);
            indexCharts[key] = indexChart;
            indexChart.setOption({
                grid: { left: 30, right: 22, top: 10, bottom: 28, containLabel: true },
                xAxis: {
                    type: 'category', data: times, boundaryGap: true,
                    axisLabel: {
                        fontSize: 9,
                        color: '#999',
                        margin: 8,
                        interval: (index) => {
                            const total = times.length;
                            if (total <= 6) return true;
                            const step = Math.max(1, Math.floor(total / 4));
                            if (index === 0 || index === total - 1) return true;
                            return index % step === 0;
                        },
                        showMinLabel: true,
                        showMaxLabel: true
                    },
                    axisLine: { lineStyle: { color: '#e5e5e5' } }, axisTick: { show: false }
                },
                yAxis: { type: 'value', scale: true, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false }, axisTick: { show: false } },
                series: [{
                    type: 'line', data: prices, smooth: true, symbol: 'none',
                    lineStyle: { width: 1.5, color: prices[prices.length - 1] >= preClose ? '#dc2626' : '#059669' },
                    areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: prices[prices.length - 1] >= preClose ? 'rgba(220, 38, 38, 0.1)' : 'rgba(5, 150, 105, 0.1)' }, { offset: 1, color: 'rgba(255, 255, 255, 0)' }]) }
                }],
                tooltip: {
                    trigger: 'axis', confine: true,
                    backgroundColor: 'rgba(255, 255, 255, 0.95)', borderColor: '#e5e5e5', textStyle: { fontSize: 10 },
                    formatter: (params) => {
                        const param = params[0];
                        const change = ((param.data - preClose) / preClose * 100).toFixed(2);
                        return `${param.name}<br/>${param.data.toFixed(2)} (${change >= 0 ? '+' : ''}${change}%)`;
                    }
                }
            });

            // Êñ∞Âª∫Âêé‰∏ªÂä® resizeÔºåÈÅøÂÖçÂÆπÂô®ÂàöÊòæÁ§∫Âá∫Êù•Êó∂Â∞∫ÂØ∏‰∏∫ 0 ÂØºËá¥Á©∫ÁôΩ
            try { indexChart.resize(); } catch {}
        }

        async function fetchAndDrawIndexKline(key) {
            const config = MARKET_INDICES[key];
            if (!config) return;
            const chartDom = document.getElementById(`indexChart_${key}`);
            if (!chartDom) return;
            
            const klineSources = [
                {
                    name: 'eastmoney_trend',
                    fetch: async () => {
                        const url = `https://push2.eastmoney.com/api/qt/stock/trends2/get?secid=${config.secid}&fields1=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13&fields2=f51,f53&_=${Date.now()}`;
                        return await runWithSourceStat('index_trends2_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                    }
                }
            ];
            
            let trendData = null;
            for (const source of klineSources) {
                try {
                    const result = await source.fetch();
                    if (result?.data?.trends) { trendData = result.data; break; }
                } catch (error) {
                    console.warn(`[KÁ∫ø-${config.name}-${source.name}] Â§±Ë¥•:`, error.message);
                    continue;
                }
            }
            
            if (!trendData || !trendData.trends) {
                chartDom.innerHTML = '<div style="text-align:center;color:var(--gray-500);padding:60px 0;font-size:0.75rem;">ÊöÇÊó†Êï∞ÊçÆ</div>';
                return;
            }
            
            const times = [];
            const prices = [];
            const preClose = trendData.preClose;
            
            trendData.trends.forEach(item => {
                const parts = item.split(',');
                const t = parseTrendTime(parts[0]);
                if (config.type === 'cn' && !isAshareTradingTimeLabel(t)) return;
                const p = parseFloat(parts[1]);
                if (!Number.isFinite(p)) return;
                times.push(t);
                prices.push(p);
            });

            indexTrendCache[key] = { times, prices, preClose, updatedAt: Date.now() };
            drawIndexMiniChart(key, indexTrendCache[key]);
        }

        // ÁßªÂä®Á´ØËèúÂçïÊéßÂà∂
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        
        mobileMenuBtn?.addEventListener('click', () => { mobileMenuBtn.classList.toggle('active'); sidebar.classList.toggle('open'); sidebarOverlay.classList.toggle('active'); });
        sidebarOverlay?.addEventListener('click', () => { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); });

        // Â§öÊï∞ÊçÆÊ∫êÈÖçÁΩÆ
        function ensureSourceStat(name) {
            if (!name) return;
            if (!sourceStats[name]) sourceStats[name] = { success: 0, fail: 0, totalTime: 0 };
        }

        async function runWithSourceStat(name, fn) {
            ensureSourceStat(name);
            const startTime = Date.now();
            try {
                const data = await fn();
                const duration = Date.now() - startTime;
                sourceStats[name].success++;
                sourceStats[name].totalTime += duration;
                updateSourceIndicator(name);
                return data;
            } catch (error) {
                const duration = Date.now() - startTime;
                sourceStats[name].fail++;
                throw error;
            }
        }

        function fetchJsonp(url, callbackParam, timeoutMs = 10000) {
            return new Promise((resolve, reject) => {
                const cbName = `__ff_jsonp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                const script = document.createElement('script');
                const sep = url.includes('?') ? '&' : '?';
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error('timeout'));
                }, timeoutMs);
                const cleanup = () => {
                    clearTimeout(timer);
                    try { delete window[cbName]; } catch { window[cbName] = undefined; }
                    script.remove();
                };
                window[cbName] = (data) => {
                    cleanup();
                    resolve(data);
                };
                script.onerror = () => {
                    cleanup();
                    reject(new Error('script load failed'));
                };
                script.src = `${url}${sep}${callbackParam}=${cbName}`;
                document.head.appendChild(script);
            });
        }

        function loadScript(url, timeoutMs = 12000) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error('timeout'));
                }, timeoutMs);
                const cleanup = () => {
                    clearTimeout(timer);
                    script.remove();
                };
                script.onload = () => {
                    cleanup();
                    resolve();
                };
                script.onerror = () => {
                    cleanup();
                    reject(new Error('script load failed'));
                };
                script.src = url;
                document.head.appendChild(script);
            });
        }

        async function fetchApidataViaScript(url, sourceName) {
            return await runWithSourceStat(sourceName, async () => {
                try { delete window.apidata; } catch { window.apidata = undefined; }
                await loadScript(url, 12000);
                const d = window.apidata;
                if (!d) throw new Error('no apidata');
                try { delete window.apidata; } catch { window.apidata = undefined; }
                return d;
            });
        }

        const DATA_SOURCES = {
            fundgz_jsonp: {
                name: 'fundgz_jsonp', priority: 1,
                fetch: async (code) => {
                    return await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        const prev = window.jsonpgz;
                        const timeout = setTimeout(() => { window.jsonpgz = prev; script.remove(); reject(new Error('timeout')); }, 8000);
                        window.jsonpgz = (data) => { clearTimeout(timeout); window.jsonpgz = prev; script.remove(); resolve(data); };
                        script.onerror = () => { clearTimeout(timeout); window.jsonpgz = prev; script.remove(); reject(new Error('script load failed')); };
                        script.src = `https://fundgz.1234567.com.cn/js/${code}.js?rt=${Date.now()}`;
                        document.head.appendChild(script);
                    });
                }
            },
            ttjj_api_jsonp: {
                name: 'ttjj_api_jsonp', priority: 2,
                fetch: async (code) => {
                    const url = `https://api.fund.eastmoney.com/f10/lsjz?fundCode=${code}&pageIndex=1&pageSize=1&_=${Date.now()}`;
                    const json = await fetchJsonp(url, 'callback', 12000);
                    const latest = json?.Data?.LSJZList?.[0];
                    if (!latest) throw new Error('No data');
                    return { name: json.Data.SHORTNAME || code, dwjz: latest.DWJZ, jzrq: latest.FSRQ, gsz: latest.DWJZ, gszzl: latest.JZZZL || '0.00', gztime: latest.FSRQ + ' 15:00' };
                }
            },
            pingzhongdata_script: {
                name: 'pingzhongdata_script', priority: 3,
                fetch: async (code) => {
                    await loadScript(`https://fund.eastmoney.com/pingzhongdata/${code}.js?rt=${Date.now()}`, 12000);
                    const name = (window.fS_name || window.fSName || '').toString();
                    const navData = window.Data_netWorthTrend;
                    if (!name || !Array.isArray(navData) || navData.length === 0) throw new Error('Parse failed');
                    const latest = navData[navData.length - 1];
                    const prev = navData.length >= 2 ? navData[navData.length - 2] : null;
                    const dwjz = latest?.y;
                    const jzrq = new Date(latest?.x).toISOString().split('T')[0];
                    let gszzl = '0.00';
                    if (prev && prev.y) gszzl = (((latest.y - prev.y) / prev.y) * 100).toFixed(2);
                    return { name, dwjz: String(dwjz), jzrq, gsz: String(dwjz), gszzl, gztime: jzrq + ' 15:00' };
                }
            }
        };

        const sourceStats = {};
        Object.values(DATA_SOURCES).forEach(s => ensureSourceStat(s.name));

        async function fetchWithFallback(code) {
            const sources = Object.values(DATA_SOURCES).sort((a, b) => {
                ensureSourceStat(a.name);
                ensureSourceStat(b.name);
                const aSuccessRate = sourceStats[a.name].success / (sourceStats[a.name].success + sourceStats[a.name].fail || 1);
                const bSuccessRate = sourceStats[b.name].success / (sourceStats[b.name].success + sourceStats[b.name].fail || 1);
                if (Math.abs(aSuccessRate - bSuccessRate) > 0.1) return bSuccessRate - aSuccessRate;
                return a.priority - b.priority;
            });
            
            let lastError;
            for (const source of sources) {
                const startTime = Date.now();
                try {
                    console.log(`üîÑ [${source.name}] Â∞ùËØïËé∑ÂèñÊï∞ÊçÆ...`);
                    const data = await source.fetch(code);
                    const duration = Date.now() - startTime;
                    if (!data || !data.dwjz || !data.name) throw new Error('Êï∞ÊçÆ‰∏çÂÆåÊï¥');
                    ensureSourceStat(source.name);
                    sourceStats[source.name].success++;
                    sourceStats[source.name].totalTime += duration;
                    console.log(`‚úÖ [${source.name}] ÊàêÂäüÔºÅËÄóÊó∂: ${duration}ms`);
                    updateSourceIndicator(source.name);
                    return data;
                } catch (error) {
                    const duration = Date.now() - startTime;
                    ensureSourceStat(source.name);
                    sourceStats[source.name].fail++;
                    console.warn(`‚ùå [${source.name}] Â§±Ë¥•: ${error.message} (${duration}ms)`);
                    lastError = error;
                    if (source !== sources[sources.length - 1]) { await new Promise(resolve => setTimeout(resolve, 200)); continue; }
                }
            }
            throw lastError || new Error('ÊâÄÊúâÊï∞ÊçÆÊ∫êÂùáÂ§±Ë¥•');
        }

        function showSourceStats() { console.table(Object.entries(sourceStats).map(([name, stats]) => ({ Êï∞ÊçÆÊ∫ê: name, ÊàêÂäü: stats.success, Â§±Ë¥•: stats.fail, ÊàêÂäüÁéá: stats.success + stats.fail > 0 ? ((stats.success / (stats.success + stats.fail)) * 100).toFixed(1) + '%' : 'N/A', Âπ≥ÂùáËÄóÊó∂: stats.success > 0 ? (stats.totalTime / stats.success).toFixed(0) + 'ms' : 'N/A' }))); }
        window.showSourceStats = showSourceStats;
        
        let lastSuccessfulSource = 'fundgz_jsonp';
        document.getElementById('sourceIndicator')?.addEventListener('click', () => { openSourceStatsModal(); });
        
        function openSourceStatsModal() {
            const modal = document.getElementById('sourceStatsModal');
            const tbody = document.getElementById('sourceStatsTableBody');
            const statsData = Object.entries(sourceStats).map(([name, stats]) => ({ name, success: stats.success, fail: stats.fail, successRate: stats.success + stats.fail > 0 ? ((stats.success / (stats.success + stats.fail)) * 100).toFixed(1) : 'N/A', avgTime: stats.success > 0 ? (stats.totalTime / stats.success).toFixed(0) : 'N/A' })).sort((a, b) => (parseFloat(b.successRate) || 0) - (parseFloat(a.successRate) || 0));
            tbody.innerHTML = statsData.map(stat => { const rate = parseFloat(stat.successRate) || 0; const rateClass = rate >= 80 ? 'high' : rate >= 50 ? 'medium' : 'low'; return `<tr><td style="font-family: 'JetBrains Mono', monospace; font-size: 0.8125rem;">${stat.name}</td><td style="color: #10b981; font-weight: 600;">${stat.success}</td><td style="color: #ef4444; font-weight: 600;">${stat.fail}</td><td class="success-rate ${rateClass}">${stat.successRate}${stat.successRate !== 'N/A' ? '%' : ''}</td><td style="font-family: 'JetBrains Mono', monospace;">${stat.avgTime}${stat.avgTime !== 'N/A' ? 'ms' : ''}</td></tr>`; }).join('') || '<tr><td colspan="5" style="text-align: center; padding: 20px; color: var(--gray-500);">ÊöÇÊó†Êï∞ÊçÆ</td></tr>';
            modal.classList.add('active');
        }
        function closeSourceStats() { document.getElementById('sourceStatsModal').classList.remove('active'); }
        document.getElementById('sourceStatsModal')?.addEventListener('click', (e) => { if (e.target.id === 'sourceStatsModal') closeSourceStats(); });
        function updateSourceIndicator(sourceName) { lastSuccessfulSource = sourceName; const indicator = document.getElementById('currentSourceName'); if (indicator) indicator.textContent = sourceName; }

        window.addEventListener('DOMContentLoaded', () => { console.log('Higher | 9880699@gmail.com'); initChart(); renderFundList(); fetchMarketIndices(); initMobileSwipeNavigation(); initProfitToggle(); if (funds.length > 0) selectFund(funds[0]); startAutoUpdate(); });

        function renderFundList() {
            const listEl = document.getElementById('fundList');
            if (funds.length === 0) { listEl.innerHTML = `<div class="empty-state"><div class="empty-icon">üìä</div><div class="empty-text">ËøòÊ≤°ÊúâÊ∑ªÂä†Âü∫Èáë</div><div class="empty-subtext">ËæìÂÖ•Âü∫Èáë‰ª£Á†ÅÂºÄÂßãÁõëÊéß</div></div>`; return; }
            listEl.innerHTML = funds.map(fund => {
                const isCollapsed = fund._cardCollapsed !== false; // ÈªòËÆ§ÊäòÂè†
                const status = getMarketStatus();
                const isRealtime = (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç');
                const displayNav = getDisplayNav(fund);
                const badgeVal = getDisplayDayGrowth(fund);
                const badgeOk = Number.isFinite(badgeVal);
                return `
                <div class="fund-item ${selectedFund?.code === fund.code ? 'active' : ''} ${isCollapsed ? 'card-collapsed' : 'card-expanded'}" data-code="${fund.code}">
                    <div class="fund-header" onclick="toggleFundCard('${fund.code}', event)">
                        <div class="fund-info">
                            <div class="fund-name">${fund.name || 'Âä†ËΩΩ‰∏≠...'}<span class="fund-collapse-arrow ${isCollapsed ? 'collapsed' : ''}" id="arrow_${fund.code}">‚ñº</span></div>
                            <div class="fund-code">${fund.code}<span class="fund-code-chg ${badgeOk ? (badgeVal >= 0 ? 'positive' : 'negative') : 'neutral'}">${badgeOk ? (badgeVal >= 0 ? '+' : '') + badgeVal.toFixed(2) + '%' : '--'}</span></div>
                        </div>
                        <div class="fund-actions">
                            <button class="btn-icon btn-edit" onclick="event.stopPropagation(); openPosModal('${fund.code}')" title="ÁºñËæëÊåÅ‰ªì">‚úèÔ∏è</button>
                            <button class="btn-icon btn-refresh" onclick="event.stopPropagation(); refreshFundByCode('${fund.code}')">üîÑ</button>
                            <button class="btn-icon btn-delete" onclick="event.stopPropagation(); deleteFund('${fund.code}')">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="fund-body ${isCollapsed ? 'collapsed' : ''}" id="body_${fund.code}">
                        <div class="fund-metrics">
                            <div class="metric-card"><div class="metric-label">‰º∞ÁÆóÂáÄÂÄº</div><div class="metric-value">${displayNav}</div></div>
                            <div class="metric-card"><div class="metric-label">Êó•Ê∂®Ë∑å</div><div class="metric-value ${badgeOk && badgeVal >= 0 ? 'positive' : 'negative'}">${badgeOk ? (badgeVal >= 0 ? '+' : '') + badgeVal.toFixed(2) + '%' : '--'}</div></div>
                        </div>
                        <div class="fund-chart" id="miniChart_${fund.code}"></div>
                    </div>
                </div>`;
            }).join('');
            // ÁªëÂÆöÂç°Áâá‰∏ªÂå∫ÂüüÁÇπÂáª ‚Üí ÈÄâ‰∏≠Âü∫Èáë
            listEl.querySelectorAll('.fund-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.closest('.fund-actions') || e.target.closest('.fund-header')) return;
                    const fund = funds.find(f => f.code === item.dataset.code);
                    if (fund) selectFund(fund);
                });
            });
            funds.forEach(fund => setTimeout(() => initMiniChart(fund), 100));
            updateAllPositionSummary();
        }

        function refreshFundByCode(code) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            fetchFundData(fund);
        }

        function initMobileSwipeNavigation() {
            const container = document.querySelector('.main-content');
            if (!container) return;
            const hintEl = document.getElementById('swipeHint');
            const root = document;

            let startX = 0;
            let startY = 0;
            let moved = false;
            let tracking = false;
            let pointerId = null;
            let pointerCaptured = false;

            const minDx = 60;
            const maxDy = 45;
            const ratio = 1.2;

            function isMobile() {
                try {
                    if (window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches) return true;
                } catch (err) { /* ignore */ }
                return window.innerWidth <= 768;
            }

            function canHandle(e) {
                if (!isMobile()) return false;
                if (sidebar?.classList.contains('open') || sidebarOverlay?.classList.contains('active')) return false;
                const t = e?.target;
                if (t && (t.closest('input') || t.closest('textarea') || t.closest('select') || t.closest('button') || t.closest('a'))) return false;
                return true;
            }

            function showHintOnce() {
                if (!hintEl) return;
                if (!isMobile()) return;
                hintEl.classList.add('show');
                hintEl.style.display = 'flex';
                setTimeout(() => {
                    hintEl.classList.remove('show');
                    hintEl.style.display = 'none';
                }, 4200);
            }

            function dismissHint() {
                if (!hintEl) return;
                hintEl.classList.remove('show');
                hintEl.style.display = 'none';
            }

            function gotoDelta(delta) {
                if (!Array.isArray(funds) || funds.length <= 1) return;
                const idx = selectedFund ? funds.findIndex(f => f.code === selectedFund.code) : -1;
                const cur = idx >= 0 ? idx : 0;
                let next = cur + delta;
                if (next < 0) next = funds.length - 1;
                if (next >= funds.length) next = 0;
                const f2 = funds[next];
                if (f2) selectFund(f2);
            }

            function isInteractiveTarget(e) {
                const t = e?.target;
                if (!t) return false;
                return !!(t.closest('input') || t.closest('textarea') || t.closest('select') || t.closest('button') || t.closest('a'));
            }

            function handleSwipeEnd(dx, dy) {
                if (Math.abs(dx) >= minDx && Math.abs(dy) <= maxDy && Math.abs(dx) > Math.abs(dy) * ratio) {
                    dismissHint();
                    if (dx < 0) gotoDelta(+1);
                    else gotoDelta(-1);
                }
            }

            const hasPointer = typeof window !== 'undefined' && 'PointerEvent' in window;

            showHintOnce();

            if (hasPointer) {
                root.addEventListener('pointerdown', (e) => {
                    if (!canHandle(e)) return;
                    if (isInteractiveTarget(e)) return;
                    if (!container.contains(e.target)) return;
                    if (e.isPrimary === false) return;
                    if (e.pointerType === 'mouse' && e.button !== 0) return;
                    startX = e.clientX;
                    startY = e.clientY;
                    moved = false;
                    tracking = true;
                    pointerId = e.pointerId;
                    pointerCaptured = false;
                }, { capture: true });

                root.addEventListener('pointermove', (e) => {
                    if (!tracking) return;
                    if (pointerId !== null && e.pointerId !== pointerId) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    if (Math.abs(dx) > 8 || Math.abs(dy) > 8) moved = true;

                    if (!pointerCaptured && Math.abs(dx) > Math.abs(dy) * ratio && Math.abs(dx) > 10) {
                        try { container.setPointerCapture(e.pointerId); pointerCaptured = true; } catch (err) { /* ignore */ }
                    }

                    if (Math.abs(dy) > Math.abs(dx) * ratio) {
                        tracking = false;
                        pointerId = null;
                        if (pointerCaptured) {
                            try { container.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                            pointerCaptured = false;
                        }
                        return;
                    }

                    if (Math.abs(dx) > Math.abs(dy) * ratio) {
                        e.preventDefault();
                    }
                }, { capture: true });

                const pointerUpOrCancel = (e) => {
                    if (!tracking) return;
                    if (pointerId !== null && e.pointerId !== pointerId) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    const shouldHandle = tracking && moved && canHandle(e) && !isInteractiveTarget(e);

                    tracking = false;
                    pointerId = null;
                    if (pointerCaptured) {
                        try { container.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                        pointerCaptured = false;
                    }

                    if (shouldHandle) handleSwipeEnd(dx, dy);
                };

                root.addEventListener('pointerup', pointerUpOrCancel, { capture: true });
                root.addEventListener('pointercancel', pointerUpOrCancel, { capture: true });
                return;
            }

            root.addEventListener('touchstart', (e) => {
                if (!canHandle(e)) return;
                if (!container.contains(e.target)) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                startX = t.clientX;
                startY = t.clientY;
                moved = false;
                tracking = true;
            }, { passive: true, capture: true });

            root.addEventListener('touchmove', (e) => {
                if (!tracking) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                if (Math.abs(dx) > 8 || Math.abs(dy) > 8) moved = true;
                if (Math.abs(dy) > Math.abs(dx) * ratio) {
                    tracking = false;
                }
            }, { passive: true, capture: true });

            root.addEventListener('touchend', (e) => {
                if (!tracking || !moved) { tracking = false; return; }
                if (!canHandle(e)) { tracking = false; return; }
                const t = e.changedTouches && e.changedTouches[0];
                if (!t) { tracking = false; return; }
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                tracking = false;

                handleSwipeEnd(dx, dy);
            }, { passive: true, capture: true });
        }

        function toggleFundCard(code, event) {
            event.stopPropagation();
            if (event.target.closest('.fund-actions')) return;
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            const body = document.getElementById('body_' + code);
            const arrow = document.getElementById('arrow_' + code);
            if (!body) return;
            const wasCollapsed = body.classList.contains('collapsed');
            body.classList.toggle('collapsed');
            if (arrow) arrow.classList.toggle('collapsed');
            fund._cardCollapsed = !wasCollapsed;
            const root = event.currentTarget?.closest('.fund-item');
            if (root) {
                root.classList.toggle('card-collapsed', fund._cardCollapsed !== false);
                root.classList.toggle('card-expanded', fund._cardCollapsed === false);
            }
            // Â±ïÂºÄÊó∂ÈáçÊñ∞ÂàùÂßãÂåñËø∑‰Ω†Âõæ
            if (wasCollapsed) {
                setTimeout(() => {
                    if (miniCharts[code]) { miniCharts[code].dispose(); delete miniCharts[code]; }
                    initMiniChart(fund);
                }, 50);
            }
            // ÂêåÊó∂ÈÄâ‰∏≠ËØ•Âü∫Èáë
            selectFund(fund);
        }


        function initMiniChart(fund) {
            const chartDom = document.getElementById(`miniChart_${fund.code}`);
            if (!chartDom) return;
            // renderFundList ‰ºöÈáçÂª∫ DOMÔºöËã•ÁºìÂ≠òÂÆû‰æãÁªëÂÆöÁöÑÊòØÊóßËäÇÁÇπÔºå‰ºöÂØºËá¥‚ÄúÁÇπ‰∏Ä‰∏ãÂ∞±Ê∂àÂ§±/‰∏ç‰∏ÄËá¥‚Äù
            const cached = miniCharts[fund.code];
            if (cached) {
                const dom0 = (typeof cached.getDom === 'function') ? cached.getDom() : null;
                if (dom0 && dom0 !== chartDom) {
                    cached.dispose();
                    delete miniCharts[fund.code];
                } else {
                    return;
                }
            }
            const miniChart = echarts.init(chartDom);
            miniCharts[fund.code] = miniChart;
            const { xData, yData } = getRealtimeChartData(fund);
            const isUp = getDisplayDayGrowth(fund) >= 0;
            miniChart.setOption({
                grid: { left: 0, right: 0, top: 5, bottom: 5 },
                xAxis: { type: 'category', data: xData, show: false, boundaryGap: false },
                yAxis: { type: 'value', show: false, scale: true },
                series: [{ type: 'line', data: yData, smooth: true, symbol: 'none', connectNulls: true, lineStyle: { width: 2, color: isUp ? '#ef4444' : '#10b981' }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: isUp ? 'rgba(239, 68, 68, 0.3)' : 'rgba(16, 185, 129, 0.3)' }, { offset: 1, color: 'rgba(255,255,255,0)' }]) } }]
            });
            window.addEventListener('resize', () => miniChart.resize());
        }

        function updateMiniChart(fund) {
            const chartDom = document.getElementById(`miniChart_${fund.code}`);
            if (!chartDom) return;
            const status = getMarketStatus();
            if (!status.canRealtimeUpdate && status.reason !== 'ÂçàÈó¥‰ºëÂ∏Ç') {
                // ‰ºëÂ∏Ç/‰∏çÂºÄÁõòÔºö‰øùÊåÅÊúÄÂêé‰∏ÄÂ∏ßÔºåÈÅøÂÖçÂèçÂ§ç setOption ÂØºËá¥Èó™Ë∑≥
                return;
            }
            const c = miniCharts[fund.code];
            if (!c) { initMiniChart(fund); return; }
            const dom0 = (typeof c.getDom === 'function') ? c.getDom() : null;
            if (dom0 && dom0 !== chartDom) {
                c.dispose();
                delete miniCharts[fund.code];
                initMiniChart(fund);
                return;
            }
            const { xData, yData } = getRealtimeChartData(fund);
            const isUp = getDisplayDayGrowth(fund) >= 0;
            c.setOption({
                xAxis: { data: xData },
                series: [{
                    data: yData,
                    connectNulls: true,
                    lineStyle: { width: 2, color: isUp ? '#ef4444' : '#10b981' },
                    areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: isUp ? 'rgba(239, 68, 68, 0.3)' : 'rgba(16, 185, 129, 0.3)' }, { offset: 1, color: 'rgba(255,255,255,0)' }]) }
                }]
            }, { lazyUpdate: true });
        }

        function getMiniRealtimeSeries(fund) {
            const series = getRealtimeSeriesForChart(fund);
            let end = getEffectiveRealtimeEndIndex(series);
            if (end < 0) end = series.length - 1;
            return series.slice(0, end + 1);
        }

        function findLastFiniteIndex(arr) {
            if (!Array.isArray(arr)) return -1;
            for (let i = arr.length - 1; i >= 0; i--) {
                if (Number.isFinite(arr[i])) return i;
            }
            return -1;
        }

        function getEffectiveRealtimeEndIndex(series) {
            const timeEnd = getRealtimeEndIndex();
            const lastKnown = findLastFiniteIndex(series);
            if (timeEnd < 0) return lastKnown;
            if (lastKnown < 0) return timeEnd;
            return Math.min(timeEnd, lastKnown);
        }

        function getRealtimeSeriesForChart(fund) {
            const baseValue = parseFloat(fund.estimatedNav || fund.currentNav || 1.5);
            const stable = (Number.isFinite(baseValue) && baseValue > 0) ? baseValue : 1.5;
            const raw = Array.isArray(fund.realtimeHistory) ? fund.realtimeHistory : [];
            const out = new Array(242);
            // ‰∏çË¶ÅÊää‚ÄúÊú™Êù•Êó∂Èó¥ÊÆµ‚ÄùÁî® last ÂÄºÁ°¨Â°´Êª°ÔºåÂê¶ÂàôÂçà‰ºë/ÁõòÂâç‰ºöÁúãËµ∑Êù•ÂÉèÁîªÂà∞‰∫Ü 15:00„ÄÇ
            // Êú™Êù•ÈÉ®ÂàÜÁî® nullÔºåËÆ©ÊäòÁ∫øÂú®ÊúÄÂêé‰∏Ä‰∏™Â∑≤Áü•ÁÇπÂ§ÑËá™ÁÑ∂ÂÅúÊ≠¢„ÄÇ
            let firstKnown = -1;
            let lastKnown = -1;
            for (let i = 0; i < raw.length; i++) {
                if (Number.isFinite(raw[i])) { firstKnown = i; break; }
            }
            for (let i = raw.length - 1; i >= 0; i--) {
                if (Number.isFinite(raw[i])) { lastKnown = i; break; }
            }
            for (let i = 0; i < 242; i++) {
                const v = raw[i];
                // ÂÖ≥ÈîÆÔºöÈ¶ñ‰∏™Â∑≤Áü•ÁÇπ‰πãÂâç‰∏çË¶ÅÂõûÂ°´ÔºåÈÅøÂÖçÊää 10:30 ÁöÑÈ¶ñÊù°Êï∞ÊçÆÊò†Â∞ÑÊàê 09:30-10:30
                if (firstKnown >= 0 && i < firstKnown) {
                    out[i] = null;
                } else {
                    // È¶ñ‰∏™Â∑≤Áü•ÁÇπ‰πãÂêéÔºö‰ªÖÂú®Êé•Âè£ÂÆûÈôÖËøîÂõûËØ•ÂàÜÈíüÊó∂ÁªòÂà∂ÔºåÂê¶ÂàôÁî® null Êñ≠Á∫øÔºà‰∏çË¶ÅÁî®‰∏ä‰∏ÄÂàÜÈíüÂÄºË°•ÈΩêÔºâ
                    out[i] = (lastKnown >= 0 && i <= lastKnown && Number.isFinite(v)) ? v : null;
                }
            }
            return out;
        }

        function getOfficialDayGrowthFromHistory(fund) {
            const raw = historyCache[fund.code];
            if (!Array.isArray(raw) || raw.length < 2) return NaN;
            const a = raw[raw.length - 2]?.y;
            const b = raw[raw.length - 1]?.y;
            if (!Number.isFinite(a) || !Number.isFinite(b) || a === 0) return NaN;
            return ((b - a) / a) * 100;
        }

        function getDisplayDayGrowth(fund) {
            const status = getMarketStatus();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const est = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
            const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(est);

            // Â§úÈó¥ÂÆòÊñπÂáÄÂÄºÂ∑≤Êõ¥Êñ∞Ôºö‰ºòÂÖàÂÆòÊñπÂè£ÂæÑÔºàÈÅøÂÖçÁªßÁª≠ÊòæÁ§∫‚Äú‰ªäÊó•‰º∞ÁÆó‚ÄùÈÄ†ÊàêËØØËß£Ôºâ
            if (navDateStr === todayStr) {
                const off0 = getOfficialDayGrowthFromHistory(fund);
                if (Number.isFinite(off0)) return off0;
            }

            // ‰ªäÊó•ÂÆòÊñπÂáÄÂÄºÊú™Âá∫Ôºö‰ºòÂÖàÂ±ïÁ§∫‚Äú‰ªäÊó•‰º∞ÁÆóÊ∂®Ë∑åÂπÖ‚ÄùÔºàÁõòÂêéÁÇπÂáªÂç°Áâá‰πü‰∏çÂõûÈÄÄÂà∞Êò®Â§©Ôºâ
            if (navDateStr !== todayStr && hasTodayEst) {
                return est;
            }

            // ‰∫§Êòì‰∏≠/Âçà‰ºë/ÁõòÂêéË°•ÂÖ®ÔºöÂ±ïÁ§∫‰º∞ÁÆóÊó•Ê∂®Ë∑å
            if (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç' || status.reason === 'ÁõòÂêéË°•ÂÖ®') {
                const v = parseFloat(fund.dayGrowth);
                return Number.isFinite(v) ? v : 0;
            }
            // ÂÖ∂‰ªñÔºöÊòæÁ§∫ÂÆòÊñπÊó•Ê∂®Ë∑åÔºàÂéÜÂè≤ÂáÄÂÄºËÆ°ÁÆóÔºâ
            const off = getOfficialDayGrowthFromHistory(fund);
            if (Number.isFinite(off)) return off;
            const fallback = parseFloat(fund.dayGrowth);
            return Number.isFinite(fallback) ? fallback : 0;
        }

        function getDisplayNav(fund) {
            const status = getMarketStatus();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const estNavNum = parseFloat(fund.estimatedNav);
            const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(estNavNum) && estNavNum > 0;

            // ‰ªäÊó•ÂÆòÊñπÂáÄÂÄºÊú™Âá∫Ôºö‰ºòÂÖàÂ±ïÁ§∫‚Äú‰ªäÊó•ÊúÄÂêé‰∏ÄÊ¨°‰º∞ÁÆóÂÄº‚ÄùÔºàÁõòÂêé‰πüË¶Å‰øùÁïôÔºâ
            if (navDateStr !== todayStr && hasTodayEst) {
                return fund.estimatedNav;
            }

            // ‰∫§Êòì‰∏≠/Âçà‰ºë/ÁõòÂêéË°•ÂÖ®ÔºöÂ±ïÁ§∫‰º∞ÁÆóÂáÄÂÄºÔºàËã•ÊúâÔºâÔºåÂê¶ÂàôÂõûÈÄÄÂÆòÊñπÂáÄÂÄº
            if (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç' || status.reason === 'ÁõòÂêéË°•ÂÖ®') {
                return fund.estimatedNav || fund.currentNav || '--';
            }
            return fund.currentNav || '--';
        }

        function getShanghaiTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Asia/Shanghai', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), second: parseInt(map.second), dow };
        }

        function getNewYorkTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'America/New_York', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), second: parseInt(map.second), dow };
        }

        function isUsMarketOpenNow() {
            const ny = getNewYorkTimeParts();
            // Âë®‰∏Ä~Âë®‰∫î
            if (ny.dow === 0 || ny.dow === 6) return false;
            const min = ny.hour * 60 + ny.minute;
            // ÁæéËÇ°Â∏∏ËßÑ‰∫§ÊòìÊó∂ÊÆµÔºö09:30-16:00ÔºàÁ∫ΩÁ∫¶Êó∂Èó¥ÔºåËá™Âä®Â§ÑÁêÜÂ§è‰ª§Êó∂Ôºâ
            return min >= 9 * 60 + 30 && min <= 16 * 60;
        }

        function formatLastGzTimeForAshare(gztime) {
            if (!gztime || typeof gztime !== 'string') return gztime;
            let m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return gztime;
            const minutes = parseInt(m[4]) * 60 + parseInt(m[5]);
            const date = `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
            return minutes > 15 * 60 ? `${date} 15:00` : `${date} ${m[4].padStart(2,'0')}:${m[5].padStart(2,'0')}`;
        }

        function getDateStr(dateTimeStr) {
            if(!dateTimeStr) return '';
            const m = dateTimeStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
            if(!m) return '';
            return `${m[1]}-${m[2].padStart(2,'0')}-${m[3].padStart(2,'0')}`;
        }

        function getGzDelayMinutes(gztime) {
            if (!gztime || typeof gztime !== 'string') return null;
            const m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return null;
            const gzDate = `${m[1]}-${String(m[2]).padStart(2,'0')}-${String(m[3]).padStart(2,'0')}`;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (gzDate !== todayStr) return null;
            const gzMin = parseInt(m[4]) * 60 + parseInt(m[5]);
            const nowMinRaw = sh.hour * 60 + sh.minute;

            // Âª∂ËøüÊòæÁ§∫Âè£ÂæÑÔºö‰ºëÂ∏ÇÊó∂‰∏çÂ∫îÊää‚ÄúÈùû‰∫§ÊòìÊó∂Èó¥‚ÄùÁÆóËøõÂª∂Ëøü
            // - ÁõòÂâçÔºöÊåâ 09:30 Â∞ÅÈ°∂
            // - ÂçàÈó¥‰ºëÂ∏ÇÔºöÊåâ 11:30 Â∞ÅÈ°∂
            // - ÁõòÂêéÔºöÊåâ 15:00 Â∞ÅÈ°∂ÔºàÁõòÂêéË°•ÂÖ®ÊúüÈô§Â§ñÔºâ
            const status = getMarketStatus();
            let capMin = 900;
            if (status.reason === 'ÁõòÂâç') capMin = 570;
            else if (status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç') capMin = 690;
            else if (status.reason === 'ÁõòÂêé') capMin = 900;
            else if (status.reason === 'ÁõòÂêéË°•ÂÖ®') capMin = nowMinRaw;
            const nowMin = Math.min(nowMinRaw, capMin);
            const gzMinCapped = Math.min(gzMin, 900);

            // ËßÑÂàôÔºöÂè™Ë¶ÅÂ∑≤ÁªèÊãøÂà∞Êî∂Áõò(15:00)Êï∞ÊçÆÔºåÂ∞±‰∏çÂÜçÂ±ïÁ§∫‚ÄúÂª∂ËøüxxÂàÜÈíü‚Äù
            if (gzMinCapped >= 900) return 0;
            const d = nowMin - gzMinCapped;
            if (!Number.isFinite(d) || d < 0) return null;
            return d;
        }

        async function fetchFundData(fund, options = {}) {
            try {
                const data = await (fundgzQueue = fundgzQueue.then(() => fetchWithFallback(fund.code)));
                fund.name = data.name;
                fund.currentNav = data.dwjz;
                // Áªü‰∏ÄÂè£ÂæÑÔºöfund.dayGrowth ‰ª£Ë°®‚Äú‰º∞ÁÆóÊó•Ê∂®Ë∑åÂπÖ‚ÄùÔºà‰∫§Êòì‰∏≠ÔºâÔºåÊù•Ê∫êÂèØËÉΩÊòØ fundgz ÊàñÊåÅ‰ªì‰º∞ÁÆó
                // Èò≤ÂõûÈÄÄÔºöÂ¶ÇÊûúÊé•Âè£ËøîÂõû‰∫ÜÊõ¥Êó©ÁöÑ gztimeÔºàÊóßÊï∞ÊçÆÔºâÔºå‰∏çË¶ÅË¶ÜÁõñÊúÄÊñ∞ÊòæÁ§∫‰∏éÊõ≤Á∫ø
                const sh0 = getShanghaiTimeParts();
                const todayStr0 = `${sh0.year}-${String(sh0.month).padStart(2,'0')}-${String(sh0.day).padStart(2,'0')}`;
                const gzDateStr = getDateStr(data.gztime);
                // Êñ∞‰∫§ÊòìÊó•/Ë∑®Â§©ÔºöÈáçÁΩÆ last idxÔºåÈÅøÂÖçÊò®Â§©ÁöÑ idx=241 ÂØºËá¥‰ªäÂ§©Êó©Áõò acceptGz Ê∞∏Ëøú‰∏∫ false
                if (gzDateStr && gzDateStr !== (fund._lastGzDate || '')) {
                    fund._lastGzDate = gzDateStr;
                    if (gzDateStr === todayStr0) {
                        fund._lastGzIdx = -1;
                    }
                }
                const gzIdx = getRealtimeMinuteIndexFromGzTime(data.gztime);
                const lastIdx = Number.isFinite(fund._lastGzIdx) ? fund._lastGzIdx : -1;
                const acceptGz = (gzIdx < 0) ? true : (gzIdx >= lastIdx);
                if (acceptGz && gzIdx >= 0) fund._lastGzIdx = gzIdx;

                if (acceptGz) {
                    fund._fundgzDayGrowth = data.gszzl;
                    // ÈªòËÆ§ÂÖàÁî® fundgzÔºõËã•ÂêéÁª≠ÊúâÊåÅ‰ªì‰º∞ÁÆóÔºå‰ºöÂú® updateDayGrowthDisplay ‰∏≠Ë¶ÜÁõñ
                    fund.dayGrowth = data.gszzl;
                    fund.estimatedNav = data.gsz;
                    fund.estimatedTime = data.gztime;
                }
                fund.navDate = data.jzrq;
                const status = getMarketStatus();
                const gszNum0 = parseFloat(data.gsz);
                const dwjzNum0 = parseFloat(data.dwjz);
                const seed = status.canRealtimeUpdate
                    ? ((Number.isFinite(gszNum0) && gszNum0 > 0) ? gszNum0 : dwjzNum0)
                    : dwjzNum0;
                if (!Array.isArray(fund.realtimeHistory)) fund.realtimeHistory = [];
                const allowRealtimeWrite = (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç' || status.reason === 'ÁõòÂêéË°•ÂÖ®');
                if (allowRealtimeWrite && acceptGz) {
                    const v0 = parseFloat(data.gsz);
                    const v = (Number.isFinite(v0) && v0 > 0) ? v0 : seed;
                    if (Number.isFinite(v) && v > 0) {
                        // ÂØπÈΩêÂà∞‚ÄúÂàÜÈíüÊßΩ‰Ωç‚ÄùÔºåÈÅøÂÖç push ÂØºËá¥Êó∂Èó¥ËΩ¥ÊºÇÁßªÂà∞ 14:53 ‰πãÁ±ª
                        // ‰ΩøÁî® gztime ËÆ°ÁÆóÊßΩ‰ΩçÔºåÈÅøÂÖç‚ÄúÊõ¥Êñ∞‰∫é13:51‰ΩÜÂõæÁîªÂà∞13:55‚ÄùËøôÁßçË∂ÖÂâç
                        const idx = gzIdx >= 0 ? gzIdx : getRealtimeMinuteIndex();
                        if (idx >= 0) {
                            if (fund.realtimeHistory.length < 242) fund.realtimeHistory.length = 242;
                            fund.realtimeHistory[idx] = v;
                        }
                    }
                }
                if (acceptGz) {
                    fund.lastUpdateTime = formatLastGzTimeForAshare(data.gztime) || '';
                }
                saveFunds();
                if (!options.suppressRender) renderFundList();
                // ÂêåÊ≠•Ëø∑‰Ω†Âõæ‰∏é‰∏ªÂõæÔºàÂêå‰∏Ä‰ªΩ realtimeHistoryÔºâ
                // ‰ºëÂ∏Ç/‰∏çÂºÄÁõòÊó∂‰∏çÂà∑Êñ∞Ëø∑‰Ω†ÂõæÔºåÈÅøÂÖçÈó™Ë∑≥Ôºõ‰ΩÜÂÖÅËÆ∏È¶ñÊ¨°ÂàùÂßãÂåñ
                if (allowRealtimeWrite && acceptGz) {
                    updateMiniChart(fund);
                } else {
                    if (!miniCharts[fund.code]) initMiniChart(fund);
                }
                if (selectedFund?.code === fund.code) { updateMainDisplay(fund); if (currentTimeRange === 'realtime') updateRealtimeChart(); }
            } catch (e) { console.error('Ëé∑ÂèñÂü∫ÈáëÊï∞ÊçÆÂ§±Ë¥•:', e); showToast('Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï', 'error'); }
        }

        function getShanghaiTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Asia/Shanghai', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), dow };
        }

        function formatLastGzTimeForAshare(gztime) {
            if (!gztime || typeof gztime !== 'string') return gztime;
            let m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return gztime;
            const minutes = parseInt(m[4]) * 60 + parseInt(m[5]);
            const date = `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
            return minutes > 15 * 60 ? `${date} 15:00` : `${date} ${m[4].padStart(2,'0')}:${m[5].padStart(2,'0')}`;
        }

        function getDateStr(dateTimeStr) {
            if(!dateTimeStr) return '';
            const m = dateTimeStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
            if(!m) return '';
            return `${m[1]}-${m[2].padStart(2,'0')}-${m[3].padStart(2,'0')}`;
        }

        // ÊåÅ‰ªìÊî∂ÁõäÊòæÁ§∫Ê®°ÂºèÔºöfalse=ÊÄªÊî∂ÁõäÔºåtrue=ÂΩìÊó•Áõà‰∫è
        let showDailyProfit = false;

        // Ê∑ªÂä†ÊåÅ‰ªìÊî∂ÁõäÁÇπÂáªÂàáÊç¢‰∫ã‰ª∂
        function initProfitToggle() {
            const profitCard = document.querySelector('.stat-card:nth-child(4)');
            if (profitCard) {
                profitCard.addEventListener('click', function() {
                    showDailyProfit = !showDailyProfit;
                    if (selectedFund) {
                        updateMainDisplay(selectedFund);
                    }
                });
                // Ê∑ªÂä†ÁÇπÂáªÊèêÁ§∫Ê†∑Âºè
                profitCard.style.cursor = 'pointer';
                profitCard.title = 'ÁÇπÂáªÂàáÊç¢ÊÄªÊî∂Áõä/ÂΩìÊó•Áõà‰∫è';
            }
        }

        function updateMainDisplay(fund) {
            document.getElementById('selectedFundName').textContent = fund.name || 'Êú™Áü•Âü∫Èáë';
            document.getElementById('selectedFundCode').textContent = fund.code;
            document.getElementById('currentNav').textContent = fund.currentNav || '--';
            document.getElementById('navDateLabel').textContent = fund.navDate ? fund.navDate.substring(5) : '--';

            const sh0 = getShanghaiTimeParts();
            const todayStr0 = `${sh0.year}-${String(sh0.month).padStart(2,'0')}-${String(sh0.day).padStart(2,'0')}`;
            const navDateStr0 = getDateStr(fund.navDate);
            const navChangeEl = document.getElementById('navChange');
            if (navChangeEl) {
                if (navDateStr0 === todayStr0) {
                    const raw = historyCache[fund.code];
                    const prev = Array.isArray(raw) && raw.length >= 2 ? raw[raw.length - 2] : null;
                    const prevNav = prev ? Number(prev.y) : NaN;
                    const prevDate = prev ? tsToDateStr(prev.x) : '';
                    if (Number.isFinite(prevNav)) {
                        navChangeEl.textContent = `ÂâçÊó•ÂáÄÂÄº ${prevNav.toFixed(4)}${prevDate ? `Ôºà${prevDate.slice(5)}Ôºâ` : ''}`;
                        navChangeEl.className = 'stat-change';
                    } else {
                        navChangeEl.textContent = 'ÂâçÊó•ÂáÄÂÄº --';
                        navChangeEl.className = 'stat-change';
                    }
                } else if (navDateStr0) {
                    navChangeEl.textContent = `Êä´Èú≤Êó∂Èó¥ ${navDateStr0.slice(5)} 15:00`;
                    navChangeEl.className = 'stat-change';
                } else {
                    navChangeEl.textContent = 'Á≠âÂæÖÂáÄÂÄºÊõ¥Êñ∞';
                    navChangeEl.className = 'stat-change';
                }
            }

            // Êó•Ê∂®Ë∑åÂπÖ ‚Äî Áî± updateDayGrowthDisplay Ë¥üË¥£Ê∏≤Êüì
            updateDayGrowthDisplay(fund);
            
            const status = getMarketStatus();
            const shProfit = getShanghaiTimeParts();
            const todayProfitStr = `${shProfit.year}-${String(shProfit.month).padStart(2,'0')}-${String(shProfit.day).padStart(2,'0')}`;
            const navDateProfitStr = getDateStr(fund.navDate);
            const officialNav0 = parseFloat(fund.currentNav);
            const profitNav0 = parseFloat(getDisplayNav(fund));
            const profitNav = (navDateProfitStr === todayProfitStr && Number.isFinite(officialNav0))
                ? officialNav0
                : (Number.isFinite(profitNav0)
                    ? profitNav0
                    : ((status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç' || status.reason === 'ÁõòÂêéË°•ÂÖ®')
                        ? parseFloat(fund.estimatedNav || fund.currentNav)
                        : parseFloat(fund.currentNav)));
            const pos = getPosition(fund);
            if (pos.has && Number.isFinite(profitNav)) {
                const m = calcPositionMetrics(pos, profitNav);
                if (m.ok) {
                    // ËÆ°ÁÆóÂΩìÊó•Áõà‰∫è
                    const dayGrowth = parseFloat(fund.dayGrowth);
                    const todayValue = Number(m.value) || 0;
                    // Âè£ÂæÑÁªü‰∏ÄÔºöÁî®‚Äú‰ªäÊó•ÊåÅ‰ªìÈáëÈ¢ù - Êò®Êó•ÊåÅ‰ªìÈáëÈ¢ù‚Äù‰Ωú‰∏∫ÂΩìÊó•Áõà‰∫èÔºåÈÅøÂÖçÊ∂®Ë∑åÂπÖÁ≤æÂ∫¶/ÂõõËàç‰∫îÂÖ•ÂØºËá¥ÁöÑÂá†ÂàÜÈí±ËØØÂ∑Æ
                    let prevValue = todayValue;
                    let dailyProfit = 0;
                    const src0 = (fund && fund._dayGrowthSource) ? String(fund._dayGrowthSource) : '';
                    if (src0 === 'est') {
                        // ÂΩì‰ΩøÁî®‰º∞ÁÆóÊ∂®Ë∑åÂπÖÊó∂ÔºåÂü∫Êï∞Êåâ‚ÄúÊåÅ‰ªìÊî∂Áõä‚ÄùÂè£ÂæÑÂ±ïÁ§∫Ôºà‰ºòÂÖàÂÆòÊñπ/T+2ÔºâÔºåÈÅøÂÖçÂèçÊé®Âá∫Êù•ÁöÑ 3999.91 ÈÄ†ÊàêËØØËß£
                        const mBase = calcPositionMetricsOfficialT2FromBuys(fund);
                        const baseValue = (mBase && mBase.ok) ? Number(mBase.value) : todayValue;
                        prevValue = Number.isFinite(baseValue) ? baseValue : todayValue;
                        dailyProfit = (Number.isFinite(dayGrowth) && Number.isFinite(prevValue)) ? (prevValue * dayGrowth / 100) : 0;
                    } else {
                        if (Number.isFinite(dayGrowth) && Number.isFinite(todayValue) && Math.abs(dayGrowth) < 50) {
                            const k = 1 + dayGrowth / 100;
                            if (k !== 0) prevValue = todayValue / k;
                        }
                        dailyProfit = todayValue - prevValue;
                    }
                    
                    if (showDailyProfit) {
                        // ÊòæÁ§∫ÂΩìÊó•Áõà‰∫è
                        document.getElementById('totalProfit').textContent = '¬•' + dailyProfit.toFixed(2);
                        document.getElementById('totalProfit').className = `stat-value ${dailyProfit>=0?'positive':'negative'}`;
                        const ppEl = document.getElementById('profitPercent');
                        const src = src0;
                        const srcTag = (src === 'est')
                            ? ' <span class="day-growth-source est">‰º∞ÁÆó</span>'
                            : (src === 'official')
                                ? ' <span class="day-growth-source official">ÂÆòÊñπ</span>'
                                : '';
                        ppEl.innerHTML = 'ÊåÅ‰ªìÈáëÈ¢ù ¬•' + prevValue.toFixed(2) + srcTag;
                        ppEl.className = 'stat-change';
                        ppEl.style.color = '';
                        // ‰øÆÊîπÊ†áÈ¢ò‰∏∫ÂΩìÊó•Áõà‰∫è
                        const profitCard = document.querySelector('.stat-card:nth-child(4) .stat-label');
                        if (profitCard) {
                            profitCard.textContent = 'ÂΩìÊó•Áõà‰∫è';
                        }
                    } else {
                        // ÊòæÁ§∫ÊÄªÊî∂Áõä
                        const m2 = calcPositionMetricsOfficialT2FromBuys(fund);
                        const mShow = (m2 && m2.ok) ? m2 : m;
                        document.getElementById('totalProfit').textContent = '¬•' + mShow.profit.toFixed(2);
                        document.getElementById('totalProfit').className = `stat-value ${mShow.profit>=0?'positive':'negative'}`;
                        const ppEl = document.getElementById('profitPercent');
                        ppEl.textContent = 'ÊåÅ‰ªìÈáëÈ¢ù ¬•' + mShow.value.toFixed(2);
                        ppEl.className = 'stat-change';
                        ppEl.style.color = '';
                        // ‰øÆÊîπÊ†áÈ¢ò‰∏∫ÊåÅ‰ªìÊî∂Áõä
                        const profitCard = document.querySelector('.stat-card:nth-child(4) .stat-label');
                        if (profitCard) {
                            profitCard.textContent = 'ÊåÅ‰ªìÊî∂Áõä';
                        }
                    }
                } else {
                    document.getElementById('totalProfit').textContent = '--';
                    document.getElementById('totalProfit').className = 'stat-value';
                    const ppEl = document.getElementById('profitPercent');
                    ppEl.textContent = 'ÊåÅ‰ªìÈáëÈ¢ù --';
                    ppEl.className = 'stat-change';
                    ppEl.style.color = '#000';
                }
            } else {
                document.getElementById('totalProfit').textContent = '--';
                document.getElementById('totalProfit').className = 'stat-value';
                const ppEl = document.getElementById('profitPercent');
                const buys = getFundBuys(fund);
                if (buys.length > 0) {
                    ppEl.textContent = 'Á≠âÂæÖÂáÄÂÄºÊõ¥Êñ∞';
                } else {
                    ppEl.textContent = 'Êú™ËÆæÁΩÆÊåÅ‰ªì';
                }
                ppEl.className = 'stat-change';
                ppEl.style.color = '#000';
            }

            // Áî®‰∏äÊµ∑Êó∂Âå∫Âà§Êñ≠Âë®Êú´
            const sh = getShanghaiTimeParts();
            const isWeekend = (sh.dow === 0 || sh.dow === 6);
            if (isWeekend) {
                document.getElementById('estimatedNav').textContent = '--';
                document.getElementById('estimatedChange').textContent = 'Âë®Êú´‰ºëÂ∏Ç';
                document.getElementById('estimatedChange').className = 'stat-change';
                document.getElementById('estLabel').textContent = '‰º∞ÁÆóÂáÄÂÄº';
            } else {
                const navDateStr = getDateStr(fund.navDate);
                // ‰ªäÊó•Êó•ÊúüÔºà‰∏äÊµ∑Ôºâ
                const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;

                // ‰ªäÊó•Â∑≤Âá∫ÂÆòÊñπÂáÄÂÄºÔºö‰∏çÂÜçÂ±ïÁ§∫‰º∞ÁÆóÔºàÈÅøÂÖçËØØËß£ÔºâÔºå‰ΩÜ‰øùÁïô‚Äú‰º∞ÁÆóÂáÄÂÄº‚ÄùÊ†áÁ≠æ
                if (navDateStr === todayStr) {
                    document.getElementById('estimatedNav').textContent = fund.currentNav || '--';
                    document.getElementById('estimatedChange').textContent = 'Â∑≤Êõ¥Êñ∞‰ªäÊó•ÂáÄÂÄº';
                    document.getElementById('estimatedChange').className = 'stat-change';
                    document.getElementById('estLabel').textContent = '‰º∞ÁÆóÂáÄÂÄº';
                } else {
                    // ‰ªäÊó•Â∞öÊú™Âá∫ÂÆòÊñπÂáÄÂÄºÔºöÁõòÂêé‰πüÂ±ïÁ§∫‚Äú‰ªäÊó•ÊúÄÂêé‰∏ÄÊ¨°‰º∞ÁÆóÂÄº‚Äù
                    const estDateStr = getDateStr(fund.estimatedTime);
                    const estNavNum = parseFloat(fund.estimatedNav);
                    const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(estNavNum) && estNavNum > 0;

                    if (hasTodayEst) {
                        const estChgNum = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
                        document.getElementById('estimatedNav').textContent = estNavNum.toFixed(4);
                        document.getElementById('estimatedChange').textContent = Number.isFinite(estChgNum)
                            ? ((estChgNum >= 0 ? '+' : '') + estChgNum.toFixed(2) + '%')
                            : '--';
                        document.getElementById('estimatedChange').className = `stat-change ${Number.isFinite(estChgNum) && estChgNum >= 0 ? 'positive' : 'negative'}`;
                        document.getElementById('estLabel').textContent = '‰º∞ÁÆóÂáÄÂÄº';
                    } else {
                        document.getElementById('estimatedNav').textContent = '--';
                        document.getElementById('estimatedChange').textContent = 'Á≠âÂæÖ‰ªäÊó•‰º∞ÂÄºÊõ¥Êñ∞';
                        document.getElementById('estimatedChange').className = 'stat-change';
                        document.getElementById('estLabel').textContent = '‰º∞ÁÆóÂáÄÂÄº';
                    }
                }
            }
            const sh2 = getShanghaiTimeParts();
            const todayStr2 = `${sh2.year}-${String(sh2.month).padStart(2,'0')}-${String(sh2.day).padStart(2,'0')}`;
            const navDateStr2 = getDateStr(fund.navDate);
            let showUpdateTime = fund.lastUpdateTime || '--';
            let useDelay = true;
            // Êî∂ÁõòÊï∞ÊçÆÂ∑≤Âà∞ÔºöÂè™Ë¶ÅÂ±ïÁ§∫‰∏∫ 15:00ÔºåÂ∞±‰∏çÂÜçÊòæÁ§∫‚ÄúÂª∂ËøüxxÂàÜÈíü‚ÄùÔºàÈÅøÂÖçÁõòÂêéË°•ÂÖ®/Âè£ÂæÑÂ∑ÆÂºÇÈÄ†ÊàêËØØÂØºÔºâ
            if (/\b15:00$/.test(showUpdateTime)) {
                useDelay = false;
            }
            // Ëã•‰ªäÊó•ÂÆòÊñπÂáÄÂÄºÂ∑≤Âá∫Ôºå‰ΩÜ‰º∞ÂÄºÊ∫ê(gztime)ÊªûÂêéÂà∞ÊóßÊó•ÊúüÔºåÈÅøÂÖç‚ÄúÊõ¥Êñ∞‰∫é 01-30‚ÄùËøôÁßçËØØÂØº
            if (navDateStr2 === todayStr2) {
                const lastDateStr = getDateStr(showUpdateTime);
                if (lastDateStr && lastDateStr !== todayStr2) {
                    showUpdateTime = `${todayStr2} 15:00`;
                    useDelay = false;
                }
            }
            const delayMin = useDelay ? getGzDelayMinutes(showUpdateTime) : null;
            const delayText = (useDelay && Number.isFinite(delayMin) && delayMin >= 2) ? `ÔºàÂª∂Ëøü${delayMin}ÂàÜÈíüÔºâ` : '';
            document.getElementById('updateTime').textContent = 'Êõ¥Êñ∞‰∫é ' + showUpdateTime + delayText;
            updateReminderBadge();
            updateLastFiredReminderHint();
            rescheduleReminder();
            updateMarketStatusUI();
            updateAllPositionSummary();
        }

        const REMINDER_STORAGE_KEY = 'fund_reminders_v1';
        const LAST_FIRED_REMINDER_KEY = 'fund_reminders_last_fired_v1';
        let reminderTimer = null;
        let reminderScheduleKey = null;
        let reminderNextAtMs = null;
        let lastFiredHintTimer = null;
        let lastFiredHintIndex = 0;

        function loadReminders() {
            try {
                const raw = localStorage.getItem(REMINDER_STORAGE_KEY);
                const obj = raw ? JSON.parse(raw) : null;
                return (obj && typeof obj === 'object') ? obj : {};
            } catch { return {}; }
        }

        function saveReminders(map) {
            try { localStorage.setItem(REMINDER_STORAGE_KEY, JSON.stringify(map || {})); } catch {}
        }

        function getSelectedReminder() {
            if (!selectedFund?.code) return null;
            const all = loadReminders();
            const r = all[selectedFund.code];
            if (!r || !r.time || typeof r.time !== 'string') return null;
            if (!/^\d{2}:\d{2}$/.test(r.time)) return null;
            return r;
        }

        function loadLastFiredReminder() {
            try {
                const raw = localStorage.getItem(LAST_FIRED_REMINDER_KEY);
                const obj = raw ? JSON.parse(raw) : null;
                return (obj && typeof obj === 'object') ? obj : null;
            } catch {
                return null;
            }
        }

        function saveLastFiredReminder(data) {
            try { localStorage.setItem(LAST_FIRED_REMINDER_KEY, JSON.stringify(data || null)); } catch {}
        }

        function updateLastFiredReminderHint() {
            const el = document.getElementById('remindFiredHint');
            if (!el) return;
            const last = loadLastFiredReminder();
            if (lastFiredHintTimer) { clearInterval(lastFiredHintTimer); lastFiredHintTimer = null; }
            lastFiredHintIndex = 0;
            if (!last || !last.date || (!Array.isArray(last.items) && (!last.code || !last.time))) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (last.date !== todayStr) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const items0 = Array.isArray(last.items) ? last.items : [{ code: last.code, name: last.name, time: last.time }];
            const items = items0
                .filter(x => x && x.code && x.time)
                .map(x => ({ code: x.code, name: x.name || x.code, time: x.time }));
            const visibleItems = selectedFund?.code ? items.filter(x => x.code !== selectedFund.code) : items;
            if (visibleItems.length === 0) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const listHtml = visibleItems
                .concat(visibleItems.length > 1 ? [visibleItems[0]] : [])
                .map(x => `<div class="rfh-item" data-code="${x.code}">ÊúÄËøëÊèêÈÜíÔºö${x.name}Ôºà${x.code}Ôºâ${x.time}</div>`)
                .join('');
            el.innerHTML = `<span class="rfh-viewport"><span class="rfh-inner">${listHtml}</span></span>`;
            el.classList.add('show');

            if (visibleItems.length > 1) {
                const inner = el.querySelector('.rfh-inner');
                const itemH = 18;
                const count = visibleItems.length;
                lastFiredHintTimer = setInterval(() => {
                    lastFiredHintIndex++;
                    if (!inner) return;
                    inner.style.transition = 'transform 0.35s ease';
                    inner.style.transform = `translateY(${-lastFiredHintIndex * itemH}px)`;
                    if (lastFiredHintIndex === count) {
                        setTimeout(() => {
                            if (!inner) return;
                            inner.style.transition = 'none';
                            inner.style.transform = 'translateY(0px)';
                            lastFiredHintIndex = 0;
                        }, 380);
                    }
                }, 2200);
            }
        }

        function jumpToLastFiredReminder(e) {
            e?.stopPropagation?.();
            const code = e?.target?.closest?.('[data-code]')?.getAttribute?.('data-code');
            const targetCode = code || loadLastFiredReminder()?.code;
            if (!targetCode) return;
            const target = funds.find(f => f.code === targetCode);
            if (target) selectFund(target);
        }

        function updateReminderBadge() {
            const el = document.getElementById('remindChip');
            if (!el) return;
            // Ëß¶ÂèëÊèêÈÜíÂêéÁöÑ 1 ÂàÜÈíüÊä•Ë≠¶ÊÄÅÁî± fireReminder ÊéßÂà∂ÔºåÈÅøÂÖçË¢´Âà∑Êñ∞ÈÄªËæëË¶ÜÁõñ
            if (el.classList.contains('alert')) return;
            const r = getSelectedReminder();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (r) {
                el.classList.remove('alert');
                if (hasFiredTodayForThisTime(r, todayStr)) {
                    el.classList.remove('active');
                    el.classList.add('fired');
                    el.textContent = `‚è∞ Â∑≤ÊèêÈÜí ${r.time}`;
                } else {
                    el.classList.remove('fired');
                    el.classList.add('active');
                    el.textContent = `‚è∞ ${r.time}`;
                }
            } else {
                el.classList.remove('active');
                el.classList.remove('fired');
                el.classList.remove('alert');
                el.classList.remove('ring');
                el.textContent = 'ÊèêÈÜí';
            }
        }

        function hasFiredTodayForThisTime(r, todayStr) {
            if (!r) return false;
            if (r.lastFiredDate !== todayStr) return false;
            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºöËã•Ê≤°Êúâ lastFiredTimeÔºåÂàôËßÜ‰∏∫ÂΩìÊó•Â∑≤ÊèêÈÜíÔºà‰ΩÜ‰øÆÊîπÊó∂Èó¥Êó∂‰ºöÊ∏ÖÁ©∫ lastFiredDateÔºâ
            if (!r.lastFiredTime) return true;
            return r.lastFiredTime === r.time;
        }

        function getReminderTargetMin(r) {
            if (!r?.time || typeof r.time !== 'string') return null;
            const m = r.time.match(/^(\d{2}):(\d{2})$/);
            if (!m) return null;
            const hh = parseInt(m[1], 10);
            const mm = parseInt(m[2], 10);
            if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
            return hh * 60 + mm;
        }

        function getShanghaiDateStrOffset(days) {
            const sh = getShanghaiTimeParts();
            const d = new Date(Date.UTC(sh.year, sh.month - 1, sh.day + (days || 0)));
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth() + 1).padStart(2, '0');
            const dd = String(d.getUTCDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        function checkReminderDue() {
            const r = getSelectedReminder();
            if (!r || !selectedFund?.code) return false;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (hasFiredTodayForThisTime(r, todayStr)) return false;
            const targetMin = getReminderTargetMin(r);
            if (!Number.isFinite(targetMin)) return false;
            const nowMin = sh.hour * 60 + sh.minute;
            // Âè™Âú®Âà∞ÁÇπËøô‰∏ÄÂàÜÈíüËß¶ÂèëÔºõËã•ËÆæÁΩÆÊó∂Èó¥Êó©‰∫éÂΩìÂâçÊó∂Èó¥ÔºåÂàôËßÜ‰∏∫‰∏ã‰∏ÄÂ§©Ôºà‰∏çÁ´ãÂàªË°•Ëß¶ÂèëÔºâ
            if (nowMin === targetMin) return true;
            return false;
        }

        function openReminderPrompt(e) {
            e?.stopPropagation?.();
            if (!selectedFund?.code) return;
            const r = getSelectedReminder();
            const current = r?.time || '';
            const input = prompt('ËÆæÁΩÆÊèêÈÜíÊó∂Èó¥(HH:MM)ÔºåÁïôÁ©∫ÂèñÊ∂à', current || '14:55');
            if (input === null) return;
            const all = loadReminders();
            const v = (input || '').trim();
            if (!v) {
                delete all[selectedFund.code];
                saveReminders(all);
                updateReminderBadge();
                rescheduleReminder();
                showToast(`${selectedFund.name || selectedFund.code} Â∑≤ÂèñÊ∂àÊèêÈÜí`);
                return;
            }
            if (!/^\d{1,2}:\d{2}$/.test(v)) {
                alert('Ê†ºÂºè‰∏çÊ≠£Á°ÆÔºåËØ∑ËæìÂÖ• HH:MMÔºå‰æãÂ¶Ç 14:55');
                return;
            }
            const [hhRaw, mmRaw] = v.split(':');
            const hh = String(Math.min(23, Math.max(0, parseInt(hhRaw, 10)))).padStart(2,'0');
            const mm = String(Math.min(59, Math.max(0, parseInt(mmRaw, 10)))).padStart(2,'0');
            const nextTime = `${hh}:${mm}`;
            const prev = all[selectedFund.code];
            const prevTime = prev?.time || null;
            const keepFired = prevTime && prevTime === nextTime;
            all[selectedFund.code] = {
                time: nextTime,
                lastFiredDate: keepFired ? (prev?.lastFiredDate || null) : null,
                lastFiredTime: keepFired ? (prev?.lastFiredTime || prevTime || null) : null
            };
            saveReminders(all);
            updateReminderBadge();
            rescheduleReminder();
            showToast(`${selectedFund.name || selectedFund.code} Â∑≤ËÆæÁΩÆÊèêÈÜí ${hh}:${mm}`);
        }

        function rescheduleReminder() {
            // ËØ¥ÊòéÔºöËØ•ÂáΩÊï∞‰ºöÂú®Âà∑Êñ∞Âæ™ÁéØ‰∏≠Ë¢´È¢ëÁπÅË∞ÉÁî®„ÄÇ
            // Ëã•ÊØèÊ¨°ÈÉΩ clearTimeout + ÈáçËÆæÔºå‰ºöÂú®‰∏¥Áïå 1 ÂàÜÈíüÂÜÖ‰∏çÊñ≠ÊîπÂÜôÂÆöÊó∂Âô®ÔºåÊûÅÁ´ØÊÉÖÂÜµ‰∏ã‰ºöÈîôËøáËß¶Âèë„ÄÇ
            const r = getSelectedReminder();
            if (!r) return;

            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (hasFiredTodayForThisTime(r, todayStr)) return;

            // Ëã•Â∑≤Âà∞ÁÇπ/ËøáÁÇπÔºåÁ´ãÂàªË°•Ëß¶Âèë‰∏ÄÊ¨°Ôºà‰øÆÂ§ç‚ÄúËÆæÁΩÆ‰∫Ü‰ΩÜÊ≤°ÊèêÈÜí/Â∑≤ËøáÁÇπ‰ªçÊòæÁ§∫Â∑≤ËÆæÁΩÆ‚ÄùÔºâ
            if (checkReminderDue()) {
                // Ê≥®ÊÑèÔºöÈ°µÈù¢ÂèØËÉΩÂú®ËΩÆËØ¢Âà∑Êñ∞Êó∂È¢ëÁπÅË∞ÉÁî® rescheduleReminderÔºåËã•‰ΩøÁî®Áü≠ setTimeout ‰ºöË¢´‰∏çÊñ≠ clearTimeout ÂØºËá¥Ê∞∏‰∏çËß¶Âèë
                // ËøôÈáåÁõ¥Êé•Ëß¶ÂèëÔºåÁî± lastFiredDate/lastFiredTime Ë¥üË¥£Èò≤Èáç
                fireReminder();
                return;
            }

            const [hh, mm] = r.time.split(':').map(x => parseInt(x, 10));
            const sh2 = getShanghaiTimeParts();
            const nowMin = sh2.hour * 60 + sh2.minute;
            const targetMin = hh * 60 + mm;
            let minutesLeft = targetMin - nowMin;
            const targetOffsetDays = minutesLeft < 0 ? 1 : 0;
            if (minutesLeft < 0) minutesLeft += 1440;
            const targetDateStr = getShanghaiDateStrOffset(targetOffsetDays);
            const scheduleKey = `${selectedFund.code}|${r.time}|${targetDateStr}`;

            // Â¶ÇÊûúÂΩìÂâçÂ∑≤ÊúâÂêå‰∏Ä‰∏™ scheduleKey ÁöÑËÆ°Êó∂Âô®ÔºåÂ∞±‰∏çË¶ÅÈáçÂ§ç clear/re-schedule
            if (reminderTimer && reminderScheduleKey === scheduleKey && Number.isFinite(reminderNextAtMs)) {
                return;
            }
            if (reminderTimer) { clearTimeout(reminderTimer); reminderTimer = null; }

            // Ëã•Â∑≤ÁªèËøõÂÖ•ÁõÆÊ†áÂàÜÈíüÔºàÂèØËÉΩ seconds ‰∏çÂêåÔºâÔºåÁõ¥Êé•Ëß¶Âèë
            if (minutesLeft === 0) {
                reminderScheduleKey = scheduleKey;
                reminderNextAtMs = Date.now();
                fireReminder();
                return;
            }

            const delay = Math.max(200, minutesLeft * 60000 - ((sh2.second || 0) * 1000));
            reminderScheduleKey = scheduleKey;
            reminderNextAtMs = Date.now() + delay;
            reminderTimer = setTimeout(() => fireReminder(), delay);
        }

        async function fireReminder() {
            const r = getSelectedReminder();
            if (!r || !selectedFund?.code) return;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            // Èò≤ÊäñÔºöÊú™Âà∞ÁõÆÊ†áÊó∂Èó¥‰∏çËß¶ÂèëÔºà‰øÆÂ§ç 15:39 ËÆæÁΩÆ 15:40 Âç¥ÊèêÂâçËß¶ÂèëÔºâ
            const targetMin = getReminderTargetMin(r);
            const nowMin = sh.hour * 60 + sh.minute;
            if (Number.isFinite(targetMin) && nowMin < targetMin) {
                rescheduleReminder();
                return;
            }
            const all = loadReminders();
            const curr = all[selectedFund.code];
            if (curr) {
                curr.lastFiredDate = todayStr;
                curr.lastFiredTime = r.time;
                all[selectedFund.code] = curr;
                saveReminders(all);
            }

            const prevLast = loadLastFiredReminder();
            const prevItems0 = (prevLast && Array.isArray(prevLast.items))
                ? prevLast.items
                : (prevLast && prevLast.code && prevLast.time ? [{ code: prevLast.code, name: prevLast.name, time: prevLast.time }] : []);
            const sameBucket = prevLast && prevLast.date === todayStr && prevLast.time === r.time;
            const nextItems = (sameBucket ? prevItems0.slice() : []);
            const idx = nextItems.findIndex(x => x && x.code === selectedFund.code);
            const nextItem = { code: selectedFund.code, name: selectedFund.name || selectedFund.code, time: r.time };
            if (idx >= 0) nextItems[idx] = nextItem; else nextItems.push(nextItem);
            saveLastFiredReminder({ date: todayStr, time: r.time, items: nextItems });
            updateLastFiredReminderHint();

            const title = 'FundFlow ÊèêÈÜí';
            const body = `${selectedFund.name || selectedFund.code}Ôºà${r.time}ÔºâËØ∑ÂÖ≥Ê≥®Áõò‰∏≠ÂèòÂåñ`;
            try {
                if ('Notification' in window) {
                    if (Notification.permission === 'granted') {
                        new Notification(title, { body });
                    } else if (Notification.permission !== 'denied') {
                        const p = await Notification.requestPermission();
                        if (p === 'granted') new Notification(title, { body });
                    } else {
                        // denied: do nothing
                    }
                }
            } catch {
                // ignore
            }
            const chip = document.getElementById('remindChip');
            if (chip) {
                chip.classList.add('alert');
                chip.classList.add('ring');
                chip.classList.remove('active');
                chip.classList.remove('fired');
                chip.textContent = `‚è∞ ${r.time}`;
                setTimeout(() => {
                    chip.classList.remove('alert');
                    chip.classList.remove('ring');
                    updateReminderBadge();
                }, 60000);
            }
            showToast(body, 'error', 60000, true);
            // Êä•Ë≠¶ÊÄÅ‰∏ã‰∏çÊõ¥Êñ∞ badgeÔºåÈÅøÂÖçÁ´ãÂàªÂèòÊàê‚ÄúÂ∑≤ÊèêÈÜí‚ÄùËÄåÁúã‰∏çÂà∞Á∫¢Ëâ≤ÊèêÁ§∫
            rescheduleReminder();
        }

        // ============================================================
        // Êó•Ê∂®Ë∑åÂπÖÊ∏≤Êüì ‚Äî ÂºÄÁõò‰∏≠Áî®ÊåÅ‰ªìÂä†ÊùÉ‰º∞ÁÆóÔºåÊú™ÂºÄÁõòÁî®ÂÆòÊñπÊï∞ÊçÆ
        // ============================================================
        function updateDayGrowthDisplay(fund) {
            const el = document.getElementById('dayGrowth');
            const chgEl = document.getElementById('dayGrowthChange');
            const status = getMarketStatus();
            const cache = holdingsCache[fund.code];

            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const fundgzEst = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
            const hasFundgzToday = (estDateStr === todayStr) && Number.isFinite(fundgzEst);

            // Â§úÈó¥ÂÆòÊñπÂáÄÂÄºÂ∑≤Êõ¥Êñ∞ÔºöÂº∫Âà∂Â±ïÁ§∫ÂÆòÊñπÂè£ÂæÑÔºàÂπ∂Ê†áÊ≥®Êó•ÊúüÊó∂Èó¥Ôºâ
            if (navDateStr === todayStr) {
                const off = getOfficialDayGrowthFromHistory(fund);
                if (Number.isFinite(off)) {
                    if (Number.isFinite(off)) fund.dayGrowth = off;
                    fund._dayGrowthSource = 'official';
                    el.innerHTML = (off >= 0 ? '+' : '') + off.toFixed(2) + '%';
                    el.className = `stat-value ${off >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        const offDate = navDateStr ? navDateStr.slice(5) : '';
                        chgEl.innerHTML = `ÂΩìÊó•Ê∂®ÂπÖ${offDate ? ' ' + offDate + ' 15:00' : ''} <span class="day-growth-source official">ÂÆòÊñπ</span>`;
                    }
                    return;
                }
            }

            // ‰ΩøÁî®‰º∞ÁÆóÊù°‰ª∂:
            //   Â∏ÇÂú∫Ê≠£Âú®‰∫§Êòì Êàñ ÂçàÈó¥‰ºëÂ∏ÇÔºà‰∏äÂçàÂ∑≤ÊúâÊï∞ÊçÆÔºâ
            //   ‰∏î holdingsCache ‰∏≠ÊúâÊñ∞È≤úÊï∞ÊçÆÔºà< 5ÂàÜÈíüÔºâ
            const cacheAge = cache ? (Date.now() - cache.timestamp) : Infinity;
            const useHoldingsEstimation = (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç') 
                                          && cache 
                                          && cacheAge < 300000;
            const useEstimation = useHoldingsEstimation || (navDateStr !== todayStr && hasFundgzToday);

            if (useEstimation) {
                if (useHoldingsEstimation) {
                    const est = cache.estDayChg;
                    if (Number.isFinite(est)) fund.dayGrowth = est;
                    fund._dayGrowthSource = 'est';
                    el.innerHTML = (est >= 0 ? '+' : '') + est.toFixed(2) + '%';
                    el.className = `stat-value ${est >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        chgEl.innerHTML = `TOP10ÊùÉÈáç ${cache.top10Weight.toFixed(2)}% <span class="day-growth-source est">‰º∞ÁÆó</span>`;
                    }
                } else {
                    const est = fundgzEst;
                    if (Number.isFinite(est)) fund.dayGrowth = est;
                    fund._dayGrowthSource = 'est';
                    el.innerHTML = (est >= 0 ? '+' : '') + est.toFixed(2) + '%';
                    el.className = `stat-value ${est >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        const t = (fund.estimatedTime && typeof fund.estimatedTime === 'string') ? (fund.estimatedTime.match(/\b\d{1,2}:\d{2}\b/)?.[0] || '') : '';
                        chgEl.innerHTML = `‰ªäÊó•‰º∞ÁÆó${t ? ' ' + t : ''} <span class="day-growth-source est">‰º∞ÁÆó</span>`;
                    }
                }
            } else {
                // ‚îÄ‚îÄ Êú™ÂºÄÁõò / ÁºìÂ≠òËøáÊúü: ÊòæÁ§∫ÂÆòÊñπÊó•Ê∂®Ë∑åÔºàÂéÜÂè≤ÂáÄÂÄºÂè£ÂæÑÔºâ ‚îÄ‚îÄ
                const dg = getDisplayDayGrowth(fund);
                // Èùû‰∫§ÊòìÊó∂‰πü‰øùÊåÅ dayGrowth ‰∏éÂ±ïÁ§∫‰∏ÄËá¥ÔºàÈÅøÂÖçÂ∑¶‰æß/Âè≥‰æß‰∏çÂêåÊ≠•Ôºâ
                if (Number.isFinite(dg)) fund.dayGrowth = dg;
                fund._dayGrowthSource = Number.isFinite(dg) ? 'official' : '';
                el.innerHTML = !isNaN(dg) ? (dg >= 0 ? '+' : '') + dg.toFixed(2) + '%' : '--';
                el.className = `stat-value ${!isNaN(dg) && dg >= 0 ? 'positive' : 'negative'}`;
                if (chgEl) {
                    const offDate = navDateStr ? navDateStr.slice(5) : '';
                    chgEl.innerHTML = !isNaN(dg)
                        ? `ÂΩìÊó•Ê∂®ÂπÖ${offDate ? ' ' + offDate + ' 15:00' : ''} <span class="day-growth-source official">ÂÆòÊñπ</span>`
                        : '--';
                }
            }
        }

        function getRealtimeMinuteIndex() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (min < 570) return -1;
            if (min <= 690) return min - 570;
            if (min < 780) return -1;
            if (min <= 900) return 121 + (min - 780);
            return -1;
        }

        function getRealtimeMinuteIndexFromGzTime(gztime) {
            if (!gztime || typeof gztime !== 'string') return -1;
            const m = gztime.match(/\b(\d{1,2}):(\d{2})\b/);
            if (!m) return -1;
            const hour = parseInt(m[1]);
            const minute = parseInt(m[2]);
            if (!Number.isFinite(hour) || !Number.isFinite(minute)) return -1;
            const min = hour * 60 + minute;
            if (min < 570) return -1;
            if (min <= 690) return min - 570;
            if (min < 780) return -1;
            if (min <= 900) return 121 + (min - 780);
            return -1;
        }

        function getRealtimeEndIndex() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (t.dow === 0 || t.dow === 6) return -1;
            // ÁõòÂâç
            if (min < 570) return -1;
            // ‰∏äÂçà 09:30 - 11:30
            if (min <= 690) return min - 570;
            // Âçà‰ºëÔºöÂõ∫ÂÆöÂà∞ 11:30
            if (min < 780) return 120;
            // ‰∏ãÂçà 13:00 - 15:00
            if (min <= 900) return 121 + (min - 780);
            // ÁõòÂêéÔºöÂõ∫ÂÆöÂà∞ 15:00
            return 241;
        }

        function updateMarketStatusUI() {
            const s = getMarketStatus();
            const el = document.getElementById('marketStatus');
            el.className = `market-status ${s.isOpen?'open':'closed'}`;
            const displayReason = (s.reason === 'ÁõòÂêéË°•ÂÖ®') ? 'ÁõòÂêé' : s.reason;
            el.innerHTML = `<span>${s.isOpen?'‚ñ∂':'‚è∏'}</span><span>${s.isOpen?'‰∫§Êòì‰∏≠':displayReason}</span>`;
        }

        function getMarketStatus() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (t.dow === 0 || t.dow === 6) return { isOpen: false, reason: 'Âë®Êú´‰ºëÂ∏Ç', canRealtimeUpdate: false };
            if ((min >= 570 && min < 690) || (min >= 780 && min < 900)) return { isOpen: true, reason: '‰∫§Êòì‰∏≠', canRealtimeUpdate: true };
            // ÁõòÂêéË°•ÂÖ®ÊúüÔºö15:00 ÂêéÊï∞ÊçÆÊ∫êÂèØËÉΩ‰ªçÂú®Ë°•ÊúÄÂêéÂá†ÂàÜÈíüÔºà‰æãÂ¶Ç 14:55 ÊâçÂà∞ÔºâÔºåÂÖÅËÆ∏Áü≠Êó∂Èó¥ÁªßÁª≠ÊãâÂèñ‰º∞ÂÄº
            if (min >= 900 && min < 915) return { isOpen: false, reason: 'ÁõòÂêéË°•ÂÖ®', canRealtimeUpdate: true };
            return { isOpen: false, reason: min < 570 ? 'ÁõòÂâç' : (min >= 900 ? 'ÁõòÂêé' : 'ÂçàÈó¥‰ºëÂ∏Ç'), canRealtimeUpdate: false };
        }

        function saveFunds() { localStorage.setItem('funds', JSON.stringify(funds)); }

        function getFundBuys(fund) {
            const out = [];
            if (Array.isArray(fund?.buys)) {
                for (const b of fund.buys) {
                    const amount = Number(b?.amount);
                    const date = (b?.date || '').toString();
                    if (Number.isFinite(amount) && amount > 0 && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
                        out.push({ amount, date });
                    }
                }
            }
            // ÂÖºÂÆπÊóßÁªìÊûÑ
            const legacyAmt = Number(fund?.buyAmount);
            const legacyDate = (fund?.buyDate || '').toString();
            if (Number.isFinite(legacyAmt) && legacyAmt > 0 && /^\d{4}-\d{2}-\d{2}$/.test(legacyDate)) {
                out.push({ amount: legacyAmt, date: legacyDate });
            }
            out.sort((a, b) => (a.date < b.date ? -1 : (a.date > b.date ? 1 : 0)));
            return out;
        }

        function getFundSells(fund) {
            const out = [];
            if (Array.isArray(fund?.sells)) {
                for (const s of fund.sells) {
                    const date = (s?.date || '').toString();
                    const all = !!s?.all;
                    const amount = Number(s?.amount);
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) continue;
                    if (all) {
                        out.push({ date, all: true, amount: null });
                    } else if (Number.isFinite(amount) && amount > 0) {
                        out.push({ date, all: false, amount });
                    }
                }
            }
            // ÂÖºÂÆπÊóß clearsÔºàËøÅÁßª‰∏∫ sells allÔºâ
            if (Array.isArray(fund?.clears)) {
                for (const c of fund.clears) {
                    const date = (c?.date || '').toString();
                    if (/^\d{4}-\d{2}-\d{2}$/.test(date)) out.push({ date, all: true, amount: null });
                }
            }
            out.sort((a, b) => (a.date < b.date ? -1 : (a.date > b.date ? 1 : 0)));
            return out;
        }

        function getFundBuyInfo(fund) {
            const buys = getFundBuys(fund);
            if (!buys.length) return { amount: null, date: null };
            return { amount: buys[0].amount, date: buys[0].date };
        }

        function getFirstHistoryPointOnOrAfter(code, dateStr) {
            const all = historyCache[code];
            if (!Array.isArray(all) || all.length === 0 || !dateStr) return null;
            for (let i = 0; i < all.length; i++) {
                const d = tsToDateStr(all[i].x);
                if (d >= dateStr) return { i, x: all[i].x, y: Number(all[i].y), date: d };
            }
            return null;
        }

        function getHistoryPointByDate(code, dateStr) {
            const all = historyCache[code];
            if (!Array.isArray(all) || all.length === 0 || !dateStr) return null;
            for (let i = all.length - 1; i >= 0; i--) {
                const d = tsToDateStr(all[i].x);
                if (d === dateStr) return { i, x: all[i].x, y: Number(all[i].y), date: d };
                if (d < dateStr) break;
            }
            return null;
        }

        function getPrevHistoryPoint(code, dateStr) {
            const p = getHistoryPointByDate(code, dateStr);
            if (!p) return null;
            const all = historyCache[code];
            const i = p.i - 1;
            if (!Array.isArray(all) || i < 0) return null;
            return { i, x: all[i].x, y: Number(all[i].y), date: tsToDateStr(all[i].x) };
        }

        function getLatestOfficialHistoryPoint(code) {
            const all = historyCache[code];
            if (!Array.isArray(all) || all.length === 0) return null;
            const last = all[all.length - 1];
            const y = Number(last?.y);
            const x = last?.x;
            const date = tsToDateStr(x);
            if (!Number.isFinite(y) || y <= 0) return null;
            return { i: all.length - 1, x, y, date };
        }

        function calcPositionMetricsOfficialT2FromBuys(fund) {
            if (!fund || !fund.code) return { ok: false };
            const buys = getFundBuys(fund);
            const sells = getFundSells(fund);
            // ÊúâÂçñÂá∫Êó∂ÔºåÊöÇÊó∂ÂõûÈÄÄÂà∞ÂéüÁÆóÊ≥ïÔºåÈÅøÂÖçÂè£ÂæÑ/Ââ©‰Ωô‰ªΩÈ¢ùËøΩË∏™Âá∫Èîô
            if (Array.isArray(sells) && sells.length > 0) return { ok: false };
            if (!Array.isArray(buys) || buys.length === 0) return { ok: false };

            const latest = getLatestOfficialHistoryPoint(fund.code);
            if (!latest) return { ok: false };

            let invested = 0;
            let value = 0;
            const pending = [];

            for (const b of buys) {
                const amount = Number(b?.amount);
                const dateStr = (b?.date || '').toString();
                if (!Number.isFinite(amount) || amount <= 0 || !/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) continue;

                const bp = getFirstHistoryPointOnOrAfter(fund.code, dateStr);
                if (!bp || !bp.date || !Number.isFinite(bp.y) || bp.y <= 0) {
                    pending.push({ amount, date: dateStr, effectiveDate: bp?.date || null });
                    continue;
                }

                invested += amount;
                const buyIdx = Number(bp.i);
                // ËßÑÂàôÔºö‰π∞ÂÖ•ÂêéÁöÑ‰∏ã‰∏Ä‰∫§ÊòìÊó•ÂºÄÂßãÊåâÂÆòÊñπÂáÄÂÄºÂèçÊò†Êî∂ÁõäÔºàT+1Ôºâ„ÄÇ
                // Ëã•ÊúÄÊñ∞Êä´Èú≤Êó• <= ‰π∞ÂÖ•ÁîüÊïàÊó•ÔºåÂàôËßÜ‰∏∫Â∞öÊú™ÂºÄÂßãËÆ°Êî∂ÁõäÔºå‰ª∑ÂÄºÊåâÊú¨ÈáëËÆ°„ÄÇ
                if (Number.isFinite(buyIdx) && latest.i <= buyIdx) {
                    value += amount;
                    continue;
                }

                const shares = amount / Number(bp.y);
                if (!Number.isFinite(shares) || shares <= 0) {
                    value += amount;
                    continue;
                }
                value += shares * latest.y;
            }

            if (!Number.isFinite(invested) || invested <= 0) return { ok: false, pendingBuys: pending };
            const profit = value - invested;
            const profitPct = invested ? (profit / invested * 100) : NaN;
            return { ok: true, invested, value, profit, profitPct, pendingBuys: pending, nav: latest.y, navDate: latest.date };
        }

        function getPositionFromBuy(fund) {
            const buys = getFundBuys(fund);
            const sells = getFundSells(fund);
            if (!buys.length && !sells.length) return { has: false };

            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;

            let invested = 0;
            let shares = 0;
            const pending = [];

            const txs = [];
            for (const b of buys) {
                const bp = getFirstHistoryPointOnOrAfter(fund.code, b.date);
                if (!bp || !bp.date) { pending.push({ amount: b.amount, date: b.date, effectiveDate: null }); continue; }
                if (bp.date > todayStr) { pending.push({ amount: b.amount, date: b.date, effectiveDate: bp.date }); continue; }
                const nav0 = Number(bp.y);
                if (!Number.isFinite(nav0) || nav0 <= 0) { pending.push({ amount: b.amount, date: b.date, effectiveDate: bp.date }); continue; }
                txs.push({ type: 'buy', effDate: bp.date, amount: b.amount, nav: nav0, inputDate: b.date });
            }
            for (const s of sells) {
                const bp = getFirstHistoryPointOnOrAfter(fund.code, s.date);
                if (!bp || !bp.date) continue;
                if (bp.date > todayStr) continue;
                const nav0 = Number(bp.y);
                if (!Number.isFinite(nav0) || nav0 <= 0) continue;
                txs.push({ type: 'sell', effDate: bp.date, amount: s.amount, all: !!s.all, nav: nav0, inputDate: s.date });
            }
            txs.sort((a, b) => (a.effDate < b.effDate ? -1 : (a.effDate > b.effDate ? 1 : (a.type === b.type ? 0 : (a.type === 'buy' ? -1 : 1)))));

            for (const tx of txs) {
                if (tx.type === 'buy') {
                    const sh0 = tx.amount / tx.nav;
                    if (!Number.isFinite(sh0) || sh0 <= 0) continue;
                    shares += sh0;
                    invested += tx.amount;
                } else {
                    if (shares <= 0) continue;
                    const avgCost = invested > 0 ? (invested / shares) : 0;
                    let sellShares = 0;
                    if (tx.all) sellShares = shares;
                    else sellShares = tx.amount / tx.nav;
                    if (!Number.isFinite(sellShares) || sellShares <= 0) continue;
                    sellShares = Math.min(sellShares, shares);
                    shares -= sellShares;
                    invested -= avgCost * sellShares;
                    if (shares <= 0.00000001) { shares = 0; invested = 0; }
                    if (invested < 0) invested = 0;
                }
            }

            if (shares <= 0 || invested <= 0) return { has: false, pendingBuys: pending };
            return { has: true, invested, shares, pendingBuys: pending };
        }

        function getPositionFromLegacy(fund) {
            const cost = Number(fund?.holdingCost);
            const shares = Number(fund?.holdingShares);
            if (!Number.isFinite(cost) || cost <= 0 || !Number.isFinite(shares) || shares <= 0) return { has: false };
            const amount = cost * shares;
            return { has: true, invested: amount, shares };
        }

        function getPosition(fund) {
            const p = getPositionFromBuy(fund);
            if (p.has) return p;
            return getPositionFromLegacy(fund);
        }

        function calcPositionMetrics(pos, nav) {
            if (!pos || !pos.has || !Number.isFinite(nav) || nav <= 0) return { ok: false };
            const invested = Number(pos.invested);
            const shares = Number(pos.shares);
            if (!Number.isFinite(invested) || invested <= 0 || !Number.isFinite(shares) || shares <= 0) return { ok: false };

            const value = shares * nav;
            const profit = value - invested;
            const profitPct = invested ? (profit / invested * 100) : NaN;
            return { ok: true, invested, value, profit, profitPct };
        }

        function updateAllPositionSummary() {
            const amountEl = document.getElementById('allPositionAmount');
            const profitEl = document.getElementById('allPositionProfit');
            if (!amountEl || !profitEl) return;

            amountEl.className = '';
            profitEl.className = '';
            amountEl.style.color = 'rgba(255,255,255,0.95)';
            profitEl.style.color = 'rgba(255,255,255,0.95)';

            let totalValue = 0;
            let totalProfit = 0;
            let hasAny = false;

            for (const f of funds) {
                const pos = getPosition(f);
                if (!pos.has) continue;
                hasAny = true;
                const m2 = calcPositionMetricsOfficialT2FromBuys(f);
                if (m2 && m2.ok) {
                    totalValue += m2.value;
                    totalProfit += m2.profit;
                    continue;
                }
                // ÂõûÈÄÄÔºöËã•Êó†Ê≥ïÁî®ÂÆòÊñπÂéÜÂè≤ÂáÄÂÄºÂè£ÂæÑÔºàÁº∫ÂéÜÂè≤/ÊúâÂçñÂá∫Á≠âÔºâÔºåÁî®ÂéüÂè£ÂæÑ
                const shProfit = getShanghaiTimeParts();
                const todayProfitStr = `${shProfit.year}-${String(shProfit.month).padStart(2,'0')}-${String(shProfit.day).padStart(2,'0')}`;
                const navDateProfitStr = getDateStr(f.navDate);
                const officialNav0 = parseFloat(f.currentNav);
                const dispNav0 = parseFloat(getDisplayNav(f));
                const nav = (navDateProfitStr === todayProfitStr && Number.isFinite(officialNav0)) ? officialNav0 : dispNav0;
                if (!Number.isFinite(nav)) continue;
                const m = calcPositionMetrics(pos, nav);
                if (!m.ok) continue;
                totalValue += m.value;
                totalProfit += m.profit;
            }

            if (!hasAny) {
                amountEl.textContent = '--';
                profitEl.textContent = '--';
                return;
            }

            amountEl.textContent = '¬•' + totalValue.toFixed(2);
            profitEl.textContent = '¬•' + totalProfit.toFixed(2);
        }
        
        async function addFund() {
            const code = document.getElementById('fundCode').value.trim();
            if (!/^\d{6}$/.test(code)) return showToast('ËØ∑ËæìÂÖ•6‰ΩçÊï∞Â≠óÂü∫Èáë‰ª£Á†Å', 'error');
            if (funds.some(f => f.code === code)) return showToast('ËØ•Âü∫ÈáëÂ∑≤Â≠òÂú®', 'error');
            const buyAmount = parseFloat(document.getElementById('buyAmount').value);
            const buyDate = (document.getElementById('buyDate').value || '').trim();
            const hasBuy = Number.isFinite(buyAmount) && buyAmount > 0 && /^\d{4}-\d{2}-\d{2}$/.test(buyDate);
            const fund = { code, buys: hasBuy ? [{ amount: buyAmount, date: buyDate }] : [], buyAmount: null, buyDate: null, name: 'Âä†ËΩΩ‰∏≠...', currentNav: '--', dayGrowth: '--' };
            funds.push(fund); saveFunds(); renderFundList();
            document.getElementById('fundCode').value = ''; document.getElementById('buyAmount').value = ''; document.getElementById('buyDate').value = '';
            await fetchFundData(fund); showToast('Ê∑ªÂä†ÊàêÂäü');
            if (window.innerWidth <= 768) { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); }
        }
        
        function deleteFund(code) {
            if (!confirm('Á°ÆËÆ§Âà†Èô§ËØ•Âü∫ÈáëÔºü')) return;
            funds = funds.filter(f => f.code !== code); saveFunds();
            if (miniCharts[code]) { miniCharts[code].dispose(); delete miniCharts[code]; }
            if (selectedFund?.code === code) selectedFund = funds[0] || null;
            renderFundList(); if(selectedFund) selectFund(selectedFund);
        }

        function selectFund(fund) {
            selectedFund = fund; renderFundList(); updateMainDisplay(fund); loadHoldingsAndSectors(fund);
            fetchHistoryData(fund.code, currentTimeRange !== 'realtime');
            if (currentTimeRange === 'realtime') { updateRealtimeChart(); startRealtimeUpdate(); }
            if (window.innerWidth <= 768) { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); }
        }

        function getSecId(code) {
            if (!code) return "";
            // ËøáÊª§ÊéâÂèØËÉΩÂ≠òÂú®ÁöÑÂ≠óÊØçÂâçÁºÄÔºàÂ¶Ç sh601228 ÊèêÂèñ‰∏∫ 601228Ôºâ
            let pureCode = String(code).match(/\d{6}/);
            if (pureCode) {
                return pureCode[0];
            }
            return String(code).trim().substring(0, 6);
        }

        function getEastmoneySecId(code) {
            const c = getSecId(code);
            if (!/^\d{6}$/.test(c)) return c;
            // ‰∏ä‰∫§ÊâÄ: 6xxxxx / Ê∑±‰∫§ÊâÄ&Âåó‰∫§ÊâÄÁ≠â: 0xxxxx/3xxxxx/8xxxxx...
            return (c.startsWith('6') ? `1.${c}` : `0.${c}`);
        }

        function openStockDetail(code) {
            if (!code) return;
            const stockCode = getSecId(code);
            if (!/^\d{6}$/.test(stockCode)) {
                console.warn("ËÇ°Á•®‰ª£Á†ÅÊ†ºÂºèÈùûÊ≥ï:", stockCode);
                return;
            }
            // ÊûÑÂª∫ÁôæÂ∫¶Â∞èÁ®ãÂ∫èÈìæÊé•
            const url = `https://pqa9p2.smartapps.baidu.com/pages/quote/quote?code=${stockCode}`;
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        function normalizeStockChg(chg, status) {
            const v = (typeof chg === 'number') ? chg : Number(chg);
            if (!Number.isFinite(v)) return 0;
            // ÁõòÂâç/Âë®Êú´ÔºöÊ∂®Ë∑åÂπÖÊ≤°ÊúâÊÑè‰πâ
            // ÁõòÂêéÔºö‰ªçÂ∫îÂ±ïÁ§∫Êî∂ÁõòÊ∂®Ë∑åÂπÖÔºàÊé•Âè£ËøîÂõûÁöÑÊòØÂΩìÊó•Êî∂ÁõòÂè£ÂæÑÔºâÔºå‰∏çË¶ÅÂΩíÈõ∂
            if (status && status.canRealtimeUpdate === false) {
                const reason = status.reason;
                if (reason === 'ÁõòÂâç' || reason === 'Âë®Êú´‰ºëÂ∏Ç') return 0;
            }
            // Èò≤Âæ°Ôºö‰∏úË¥¢ÈÉ®ÂàÜÂú∫ÊôØ‰ºöËøîÂõû -100 ‰Ωú‰∏∫Áº∫Â§±ÂÄº
            if (Math.abs(v) >= 99.99) return 0;
            return v;
        }

        // ============================================================
        // ÊåÅ‰ªìÂä†ËΩΩ - Âê´ gushitong.baidu.com Êñ∞Êï∞ÊçÆÊ∫êÔºà‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºâ
        // ============================================================
        async function loadHoldingsAndSectors(fund, options = {}) {
            const tbody = document.getElementById('holdingsTableBody');
            const tags = document.getElementById('sectorTags');
            const status0 = getMarketStatus();

            // updateOnly: Âè™Êõ¥Êñ∞Ê∂®Ë∑åÂπÖÔºå‰∏çË¶ÅÈáçÁªò DOMÔºàÈÅøÂÖçÈó™Ë∑≥Ôºâ
            if (options.updateOnly) {
                await updateHoldingsChgOnly(fund);
                return;
            }

            // silent: Â∑≤ÁªèÊúâÂÜÖÂÆπÊó∂‰∏çË¶ÅÂÜô‚ÄúÂä†ËΩΩ‰∏≠...‚ÄùË¶ÜÁõñÈÄ†ÊàêÈó™Ë∑≥
            if (!options.silent) {
                if (tbody) tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">Âä†ËΩΩ‰∏≠...</td></tr>`;
                if (tags) tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">Âä†ËΩΩ‰∏≠...</span>`;
            }

            // --- Êï∞ÊçÆÊ∫ê1 (‰ºòÂÖà): gushitong.baidu.com ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            // ËøîÂõûÁöÑJSONÁªìÊûÑ:
            //   Result[0].DisplayData.resultData.tplData.result.content.tabs[0 (ÊåÅ‰ªìtab)]
            //     .content.heavyStock.body[]  ‚Üí TOP 10 ÊåÅ‰ªìËÇ°Á•®
            //     .content.industryPositon.list[] ‚Üí Ë°å‰∏öÊùøÂùóÂç†ÊØî
            const baiduTargetUrl = `https://gushitong.baidu.com/opendata?resource_id=5803&query=${fund.code}&new_need_di=1&source=qieman`;
            const baiduProxyOff = (localStorage.getItem('BAIDU_PROXY_OFF') || '') === '1';
            const baiduCorsProxy = ((localStorage.getItem('BAIDU_CORS_PROXY') || '').trim() || 'https://api.allorigins.win/get?url=');
            const baiduAllowDirect = (localStorage.getItem('BAIDU_DIRECT') || '') === '1';

            async function fetchBaiduViaProxy(targetUrl, proxyPrefix) {
                const proxyUrl = `${proxyPrefix}${encodeURIComponent(targetUrl)}`;
                const res = await fetch(proxyUrl, { signal: AbortSignal.timeout(12000) });
                if (!res.ok) throw new Error(`proxy http ${res.status}`);
                let payload;
                try {
                    payload = await res.json();
                } catch {
                    const text = await res.text();
                    payload = JSON.parse(text);
                }
                const raw = payload && typeof payload === 'object' && typeof payload.contents === 'string'
                    ? payload.contents
                    : payload;
                if (typeof raw === 'string') return JSON.parse(raw);
                return raw;
            }

            const baiduSources = [];
            // Áõ¥ËøûÊñπÊ°àÔºöËã•ÁôæÂ∫¶Êé•Âè£ÊîØÊåÅ JSONPÔºàcb/callbackÔºâÔºåÂèØÁªïËøá CORS ‰∏îÊõ¥Âø´
            // Ê≥®ÊÑèÔºöÂ¶ÇÊûúÊé•Âè£‰∏çÊîØÊåÅ JSONPÔºåËøôÈáå‰ºöÂæàÂø´Ë∂ÖÊó∂Âπ∂Ëá™Âä®ÂõûÈÄÄÂà∞‰ª£ÁêÜ/‰∏úË¥¢Â§áÁî®Ê∫ê
            baiduSources.push({
                name: 'gushitong_jsonp',
                fetch: async () => {
                    try {
                        return await fetchJsonp(baiduTargetUrl, 'cb', 2500);
                    } catch {
                        return await fetchJsonp(baiduTargetUrl, 'callback', 2500);
                    }
                }
            });
            if (!baiduProxyOff && baiduCorsProxy) {
                baiduSources.push({
                    name: 'gushitong_proxy',
                    fetch: async () => await fetchBaiduViaProxy(baiduTargetUrl, baiduCorsProxy)
                });
            }
            if (baiduAllowDirect) {
                baiduSources.push({
                    name: 'gushitong_direct',
                    fetch: async () => {
                        const res = await fetch(baiduTargetUrl, { signal: AbortSignal.timeout(10000) });
                        return await res.json();
                    }
                });
            }

            let baiduData = null; // Ëß£ÊûêÂêéÁöÑÁªìÊûÑÂåñÊï∞ÊçÆ: { holdings: [...], sectors: [...] }

            for (const source of baiduSources) {
                try {
                    console.log(`üîÑ [ÊåÅ‰ªì-${source.name}] Â∞ùËØïËé∑Âèñ...`);
                    const json = await runWithSourceStat(`holdings_${source.name}`, async () => await source.fetch());

                    // Ê∑±Â±ÇËß£ÊûêË∑ØÂæÑ
                    const result = json?.Result?.[0];
                    const tplData = result?.DisplayData?.resultData?.tplData?.result;
                    const tabs = tplData?.content?.tabs;

                    // tabs[0] ÊòØ "ÊåÅ‰ªì" tab (type: "position")
                    const positionTab = tabs?.find(t => t.type === 'position') || tabs?.[0];
                    const posContent = positionTab?.content;

                    // heavyStock.body ‚Üí TOP 10 ËÇ°Á•®
                    const heavyStockBody = posContent?.heavyStock?.body;
                    // industryPositon.list ‚Üí Ë°å‰∏öÊùøÂùó
                    const industryList = posContent?.industryPositon?.list;
                    // heavyStock Êõ¥Êñ∞Êó•Êúü
                    const holdingDate = posContent?.heavyStock?.titleHeader?.[1] || '';

                    if (!heavyStockBody || heavyStockBody.length === 0) {
                        throw new Error('heavyStock.body ‰∏∫Á©∫');
                    }

                    // Êò†Â∞ÑÊåÅ‰ªìÊï∞ÊçÆ
                    const holdings = heavyStockBody.map(item => ({
                        name: item.name,                          // ËÇ°Á•®ÂêçÁß∞
                        code: item.code,                          // ËÇ°Á•®‰ª£Á†Å
                        ratio: parseFloat(item.positionProportion?.replace('%', '')) || 0  // Âç†ÂáÄÂÄºÊØî‰æã
                    }));

                    // Êò†Â∞ÑË°å‰∏öÊùøÂùóÊï∞ÊçÆ
                    const sectors = (industryList || []).map(item => ({
                        name: item.text,                          // Ë°å‰∏öÂêçÁß∞
                        weight: parseFloat(item.value?.replace('%', '')) || 0  // Âç†ÊØî
                    }));

                    baiduData = { holdings, sectors, holdingDate };
                    console.log(`‚úÖ [ÊåÅ‰ªì-${source.name}] ÊàêÂäü! ÊåÅ‰ªì${holdings.length}Êù°, ÊùøÂùó${sectors.length}Êù°, Êó•Êúü: ${holdingDate}`);
                    break;

                } catch (error) {
                    console.warn(`‚ùå [ÊåÅ‰ªì-${source.name}] Â§±Ë¥•:`, error.message);
                    continue;
                }
            }

            // --- Êï∞ÊçÆÊ∫ê2 (Â§áÁî®): eastmoney HTML Áà¨Âèñ ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            if (!baiduData) {
                console.log('‚ö†Ô∏è BaiduÊï∞ÊçÆÊ∫êÂÖ®ÈÉ®Â§±Ë¥•ÔºåÂ∞ùËØïeastmoneyÂ§áÁî®Ê∫ê...');
                try {
                    const url = `https://fundf10.eastmoney.com/FundArchivesDatas.aspx?type=jjcc&topline=10&code=${fund.code}&year=&month=&rt=${Date.now()}`;
                    const apidata = await fetchApidataViaScript(url, 'holdings_eastmoney_apidata');
                    const html = (apidata?.content || '').toString().replace(/\\r\\n/g, '').replace(/\\n/g, '').replace(/\\t/g, '').replace(/\\\//g, '/').replace(/\\\"/g, '"');
                    const doc = new DOMParser().parseFromString(html, 'text/html');
                    const tables = Array.from(doc.querySelectorAll('table'));
                    const table = tables.find(t => {
                        const thText = (t.querySelector('thead')?.textContent || t.textContent || '').replace(/\s+/g, '');
                        return thText.includes('ËÇ°Á•®‰ª£Á†Å') && thText.includes('ËÇ°Á•®ÂêçÁß∞') && thText.includes('Âç†ÂáÄÂÄº');
                    }) || tables[0];

                    let holdings = [];
                    if (table) {
                        const ths = Array.from(table.querySelectorAll('thead th'));
                        const norm = (s) => (s || '').replace(/\s+/g, '').replace(/\u00a0/g, '');
                        const idxCode = ths.findIndex(th => norm(th.textContent).includes('ËÇ°Á•®‰ª£Á†Å'));
                        const idxName = ths.findIndex(th => norm(th.textContent).includes('ËÇ°Á•®ÂêçÁß∞'));
                        const idxRatio = ths.findIndex(th => {
                            const t = norm(th.textContent);
                            return t.includes('Âç†ÂáÄÂÄº') || t.includes('Âç†ÂáÄÂÄºÊØî‰æã');
                        });

                        const rows = Array.from(table.querySelectorAll('tbody tr'));
                        holdings = rows.map(tr => {
                            const tds = Array.from(tr.querySelectorAll('td'));
                            if (tds.length === 0) return null;
                            const code = (tds[idxCode]?.textContent || '').trim();
                            const name = (tds[idxName]?.textContent || '').trim();
                            const ratioText = (tds[idxRatio]?.textContent || '').trim();
                            let ratio = 0;
                            const m = ratioText.match(/(\d+(\.\d+)?)/);
                            if (m) ratio = parseFloat(m[1]);
                            return { code, name, ratio };
                        }).filter(x => x && x.code && x.name).slice(0, 10);
                    }

                    if (holdings.length > 0) {
                        baiduData = { holdings, sectors: [], holdingDate: '' };
                        console.log(`‚úÖ eastmoneyÂ§áÁî®Ê∫êËß£Êûê‰∫Ü ${holdings.length} Êù°ÊåÅ‰ªì`);
                    }
                } catch (e) {
                    console.error('Ëß£ÊûêeastmoneyÊåÅ‰ªìÂ§±Ë¥•:', e);
                }
            }

            // --- Êó†Êï∞ÊçÆÈÄÄÂá∫ ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            if (!baiduData || baiduData.holdings.length === 0) {
                console.error('üí• ÊâÄÊúâÊåÅ‰ªìÊï∞ÊçÆÊ∫êÂùáÂ§±Ë¥•ÊàñÊó†Êï∞ÊçÆ');
                tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500);">Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï</td></tr>`;
                tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">Âä†ËΩΩÂ§±Ë¥•</span>`;
                return;
            }

            // --- Ê∏≤ÊüìÊùøÂùóÊ†áÁ≠æÔºàË°å‰∏öÂç†ÊØîÔºâ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            // Â¶ÇÊûúÊúâBaiduË°å‰∏öÊï∞ÊçÆÁõ¥Êé•Áî®ÔºõÂê¶ÂàôÂêéÈù¢‰ªéeastmoneyËÇ°Á•®Ë°åÊÉÖÈáåÂΩíÂπ∂
            let sectorSource = 'baidu'; // Ê†áËÆ∞Êï∞ÊçÆÊù•Ê∫ê
            if (baiduData.sectors.length > 0) {
                tags.innerHTML = baiduData.sectors.slice(0, 6).map(s =>
                    `<span class="sector-tag">${s.name} ${s.weight.toFixed(1)}%</span>`
                ).join('');
            } else {
                sectorSource = 'eastmoney'; // ÂêéÁª≠‰ªéË°åÊÉÖÂΩíÂπ∂
                tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">ÊùøÂùóÊï∞ÊçÆÂä†ËΩΩ‰∏≠...</span>`;
            }

            // --- Ëé∑ÂèñËÇ°Á•®ÂÆûÊó∂Ë°åÊÉÖÔºàÊ∂®Ë∑åÂπÖÔºâ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            const quoteSources = [
                (secid) => `https://push2.eastmoney.com/api/qt/stock/get?secid=${secid}&fields=f2,f3,f4,f43,f60,f100&ut=fa5fd1943c7b386f172d6893dbfba10b&_=${Date.now()}`
            ];

            console.log('üìà ÂºÄÂßãËé∑ÂèñËÇ°Á•®Ë°åÊÉÖ...');
            const quotes = await Promise.all(baiduData.holdings.map(async h => {
                const secid = getEastmoneySecId(h.code);
                for (const getUrl of quoteSources) {
                    try {
                        let qjson;
                        try {
                            qjson = await runWithSourceStat('quote_stock_get_jsonp', async () => await fetchJsonp(getUrl(secid), 'cb', 8000));
                        } catch {
                            qjson = await runWithSourceStat('quote_stock_get_jsonp_callback', async () => await fetchJsonp(getUrl(secid), 'callback', 8000));
                        }
                        if (qjson?.data) {
                            const d = qjson.data;
                            const last = Number(d.f43 ?? d.f2);
                            const prevClose = Number(d.f60);
                            const chgRaw = d.f3;
                            let chg = (typeof chgRaw === 'number') ? chgRaw : Number(chgRaw);
                            if (!Number.isFinite(chg)) {
                                if (Number.isFinite(last) && Number.isFinite(prevClose) && prevClose !== 0) {
                                    chg = ((last - prevClose) / prevClose) * 100;
                                } else {
                                    chg = 0;
                                }
                            }
                            chg = normalizeStockChg(chg, status0);
                            return { ...h, chg, price: Number.isFinite(last) ? last : 0, industry: d.f100 || 'ÂÖ∂‰ªñ' };
                        }
                    } catch (err) { continue; }
                }
                return { ...h, chg: 0, price: 0, industry: 'ÂÖ∂‰ªñ' };
            }));

            // Áªü‰∏ÄÂèòÈáèÔºöTOP10 ÊùÉÈáç/ÂâçÂçÅÊåÅ‰ªìÂç†ÊØîÂêàËÆ°Áî®Âêå‰∏Ä‰∏™ top10WeightÔºåÈÅøÂÖç‰∏§Â§ÑÂêÑÁÆóÂêÑÁöÑÂØºËá¥Èîô‰π±
            const top10Weight = quotes.reduce((sum, h) => sum + (parseFloat(h.ratio) || 0), 0);
            const top10WeightTag = `<span class="sector-tag top10-weight">ÂâçÂçÅÊåÅ‰ªìÂç†ÊØîÂêàËÆ°Ôºö${top10Weight.toFixed(2)}%ÔºàËÇ°Á•®ÊåÅ‰ªìÔºâ</span>`;
            if (tags) {
                tags.innerHTML = top10WeightTag + tags.innerHTML;
            }

            // --- Ê∏≤ÊüìÊåÅ‰ªìË°®Ê†º ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            let holdingDateLabel = '';
            if (baiduData.holdingDate) {
                holdingDateLabel = ` <span style="font-size:0.7rem;color:var(--gray-500);font-weight:500;">(${baiduData.holdingDate})</span>`;
            }
            document.querySelector('.table-header').innerHTML = `Âü∫ÈáëÊåÅ‰ªìÔºàTOP 10Ôºâ${holdingDateLabel}`;

            // ÁºìÂ≠òÂΩìÂâç TOP10 ÂàóË°®ÔºåÂêéÁª≠ updateHoldingsChgOnly Âè™Êõ¥Êñ∞Ê∂®Ë∑åÂπÖ
            fund._topHoldings = quotes.map(h => ({ code: h.code, name: h.name, ratio: h.ratio || 0 }));

            tbody.innerHTML = quotes.map(h => `
                <tr data-code="${h.code}" onclick="openStockDetail('${h.code}')">
                    <td>${h.name}</td>
                    <td style="font-family:'JetBrains Mono',monospace;font-size:0.8125rem;">${h.code}</td>
                    <td><strong>${h.ratio ? h.ratio.toFixed(2) + '%' : '--'}</strong></td>
                    <td class="holding-chg ${h.chg >= 0 ? 'positive' : 'negative'}"><strong>${(h.chg > 0 ? '+' : '') + h.chg.toFixed(2) + '%'}</strong></td>
                </tr>
            `).join('');

            // --- Â¶ÇÊûúÊùøÂùóÊï∞ÊçÆÊù•Ëá™eastmoneyÔºå‰ªéË°åÊÉÖÈáåÂΩíÂπ∂Ë°å‰∏ö‰ø°ÊÅØ ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            if (sectorSource === 'eastmoney') {
                const sectors = {};
                quotes.forEach(h => {
                    const ind = h.industry || 'ÂÖ∂‰ªñ';
                    if (!sectors[ind]) sectors[ind] = { name: ind, weight: 0, chg: [] };
                    sectors[ind].weight += (h.ratio || 0);
                    if (h.chg !== undefined) sectors[ind].chg.push(h.chg);
                });
                const sortedSectors = Object.values(sectors).map(s => ({ ...s, avgChg: s.chg.length > 0 ? s.chg.reduce((a, b) => a + b, 0) / s.chg.length : 0 })).sort((a, b) => b.weight - a.weight).slice(0, 6);
                const filteredSectors = sortedSectors.filter(s => s.name !== 'ÂÖ∂‰ªñ');
                const sectorHtml = filteredSectors.map(s =>
                    `<span class="sector-tag ${s.avgChg >= 0 ? 'positive' : 'negative'}">${s.name} ${s.weight.toFixed(1)}% ${s.avgChg !== 0 ? '(' + (s.avgChg >= 0 ? '+' : '') + s.avgChg.toFixed(2) + '%)' : ''}</span>`
                ).join('');
                tags.innerHTML = top10WeightTag + (sectorHtml || '');
            }

            // --- ËÆ°ÁÆóÊó•Ê∂®Ë∑åÂπÖ‰º∞ÁÆóÔºàÊ†∏ÂøÉÁÆóÊ≥ïÔºâ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
            // ÂÖ¨Âºè: estimatedDayChg = Œ£(w_i √ó chg_i) + (1 - W_top) √ó residual_rate
            //   w_i         = Á¨¨i‰∏™ËÇ°Á•®Âç†ÂáÄÂÄºÊØî‰æã (%)ÔºåÂ¶Ç 9.32 Ë°®Á§∫ 9.32%
            //   chg_i       = Á¨¨i‰∏™ËÇ°Á•®‰ªäÊó•ÂÆûÊó∂Ê∂®Ë∑åÂπÖ (%)
            //   W_top       = TOP10 ÊÄªÊùÉÈáç‰πãÂíå (%)ÔºåÂ¶Ç 62.86
            //   residual_rate = Ââ©‰Ωô‰ªì‰ΩçÁöÑ‰º∞ÁÆóÊ∂®Ë∑åÁéá
            //                   ÂΩì fundgz gszzl ÂèØÁî®Êó∂ÂèçÊé®: residual = (gszzl - top10_contribution) / (100 - W_top)
            //                   ÂΩì gszzl ‰∏çÂèØÁî®ÊàñÂâ©‰ΩôÊùÉÈáç‰∏∫0Êó∂: residual = top10 Âä†ÊùÉÂπ≥ÂùáÊ∂®Ë∑åÁéá
            // Ê≥®ÊÑè: w_i ÊòØÁôæÂàÜÊØîÂÄº (Â¶Ç9.32)ÔºåÊâÄ‰ª• Œ£(w_i √ó chg_i) ÁöÑÂçï‰ΩçÊòØ %√ó%ÔºåÈúÄË¶Å /100 ÂΩí‰∏ÄÂåñ
            {
                const status = getMarketStatus();
                if (status.canRealtimeUpdate || status.reason === 'ÂçàÈó¥‰ºëÂ∏Ç') {
                    // ËÆ°ÁÆó TOP10 Âä†ÊùÉË¥°ÁåÆ
                    let top10Contribution = 0; // TOP10 ÂØπÊ∂®Ë∑åÁöÑË¥°ÁåÆ (%)
                    quotes.forEach(h => {
                        const w = h.ratio || 0;   // Âç†ÂáÄÂÄºÊØî‰æã (%)
                        const c = h.chg || 0;     // ‰ªäÊó•Ê∂®Ë∑åÂπÖ (%)
                        top10Contribution += (w / 100) * c; // w/100 ÊääÁôæÂàÜÊØîËΩ¨‰∏∫ÊØî‰æãÔºå‰πò‰ª•chg(%)ÂæóÂà∞Ë¥°ÁåÆ(%)
                    });

                    let residualWeight = 100 - top10Weight; // Ââ©‰Ωô‰ªì‰ΩçÊùÉÈáç (%)
                    let residualRate = 0;                    // Ââ©‰Ωô‰ªì‰Ωç‰º∞ÁÆóÊ∂®Ë∑åÁéá (%)

                    const fundgzGszzl = parseFloat(fund._fundgzDayGrowth); // fundgz Êèê‰æõÁöÑÊï¥‰Ωì‰º∞ÁÆóÊ∂®Ë∑åÂπÖ (%)
                    if (!isNaN(fundgzGszzl) && residualWeight > 0.01) {
                        // Áî® fundgz ‰º∞ÁÆóÂèçÊé®Ââ©‰Ωô‰ªì‰ΩçÊ∂®Ë∑åÁéá
                        // gszzl ‚âà top10_contribution + (residualWeight/100) √ó residualRate
                        // ‚üπ residualRate = (gszzl - top10_contribution) / (residualWeight/100)
                        residualRate = (fundgzGszzl - top10Contribution) / (residualWeight / 100);
                        // ÂÆâÂÖ®ÈôêÂà∂ÔºöÂâ©‰Ωô‰º∞ÁÆó‰∏çËÉΩË∂ÖËøá TOP10 ÂùáÂÄºÁöÑ 3ÂÄçÔºåÈò≤Ê≠¢ÂºÇÂ∏∏ÂÄº
                        const top10AvgRate = top10Weight > 0 ? top10Contribution / (top10Weight / 100) : 0;
                        if (Math.abs(residualRate) > Math.abs(top10AvgRate) * 3 + 5) {
                            residualRate = top10AvgRate; // ÂõûÈÄÄÂà∞TOP10ÂùáÂÄº
                        }
                    } else if (top10Weight > 0) {
                        // gszzl ‰∏çÂèØÁî®Êó∂ÔºåÁî® TOP10 Âä†ÊùÉÂùáÂÄºËøë‰ººÂâ©‰ΩôÈÉ®ÂàÜ
                        residualRate = top10Contribution / (top10Weight / 100);
                    }

                    // ÊúÄÁªà‰º∞ÁÆóÊ∂®Ë∑åÂπÖÔºö‰ºòÂÖà‰ΩøÁî® fundgz ÁöÑÊï¥‰Ωì‰º∞ÁÆóÔºàÂ∏ÇÂú∫ÈÄöÁî®Âè£ÂæÑÔºâÔºåÈÅøÂÖçÂõ†ÈôêÂπÖ/ËØØÂ∑ÆÂØºËá¥Êï¥‰ΩìË∑ëÂÅè
                    const fallbackEst = top10Contribution + (residualWeight / 100) * residualRate;
                    const estDayChg = (!isNaN(fundgzGszzl)) ? fundgzGszzl : fallbackEst;

                    // Â≠òÂÖ•ÁºìÂ≠ò‰æõ updateMainDisplay ‰ΩøÁî®
                    holdingsCache[fund.code] = {
                        top10Weight: top10Weight,
                        top10Contribution: top10Contribution,
                        residualWeight: residualWeight,
                        residualRate: residualRate,
                        estDayChg: estDayChg,
                        timestamp: Date.now()
                    };
                }
            }
        }

        async function updateHoldingsChgOnly(fund) {
            const tbody = document.getElementById('holdingsTableBody');
            if (!tbody) return;
            const list = Array.isArray(fund?._topHoldings) ? fund._topHoldings : [];
            if (list.length === 0) return;

            const status0 = getMarketStatus();

            // ÊâπÈáèË°åÊÉÖÔºö‰∏ÄÊ¨°ËØ∑Ê±ÇÊãøÂà∞ TOP10 ÂÖ®ÈÉ®ËÇ°Á•®Ê∂®Ë∑åÂπÖÔºåÈÅøÂÖç 1 ÁßíÂÜÖÂ§öÊ¨°ËØ∑Ê±Ç
            const secids = list.map(h => getEastmoneySecId(h.code)).filter(Boolean).join(',');
            if (!secids) return;
            const url = `https://push2.eastmoney.com/api/qt/ulist.np/get?fltt=2&invt=2&secids=${secids}&fields=f12,f3&ut=fa5fd1943c7b386f172d6893dbfba10b&_=${Date.now()}`;

            let qjson;
            try {
                qjson = await runWithSourceStat('quote_ulist_np_get_jsonp', async () => await fetchJsonp(url, 'cb', 8000));
            } catch {
                qjson = await runWithSourceStat('quote_ulist_np_get_jsonp_callback', async () => await fetchJsonp(url, 'callback', 8000));
            }

            const diff = qjson?.data?.diff;
            const chgMap = {};
            if (Array.isArray(diff)) {
                diff.forEach(item => {
                    const code = (item?.f12 || '').toString();
                    const chg = Number(item?.f3);
                    if (code && Number.isFinite(chg)) chgMap[code] = chg;
                });
            }

            const quotes = list.map(h => ({
                code: h.code,
                chg: normalizeStockChg(Number.isFinite(chgMap[h.code]) ? chgMap[h.code] : 0, status0)
            }));

            quotes.forEach(q => {
                const tr = tbody.querySelector(`tr[data-code="${q.code}"]`);
                if (!tr) return;
                const td = tr.querySelector('td.holding-chg');
                if (!td) return;
                td.className = `holding-chg ${q.chg >= 0 ? 'positive' : 'negative'}`;
                td.innerHTML = `<strong>${(q.chg > 0 ? '+' : '') + q.chg.toFixed(2) + '%'}</strong>`;
            });

            // ÂêåÊ≠•Êõ¥Êñ∞‚ÄúÊó•Ê∂®Ë∑åÂπÖ‚ÄùÁöÑ‰º∞ÁÆóÁºìÂ≠òÔºàËÆ©ÊåÅ‰ªìÂÆûÊó∂Ê∂®Ë∑å‰∏éÊó•Ê∂®Ë∑åÂπÖËÅîÂä®Ôºâ

            const top10Weight = list.reduce((sum, h) => sum + (parseFloat(h.ratio) || 0), 0);
            let top10Contribution = 0;
            list.forEach(h => {
                const w = parseFloat(h.ratio) || 0;
                const c = normalizeStockChg(Number.isFinite(chgMap[h.code]) ? chgMap[h.code] : 0, status0);
                top10Contribution += (w / 100) * c;
            });

            const residualWeight = 100 - top10Weight;
            let residualRate = 0;
            const fundgzGszzl = parseFloat(fund._fundgzDayGrowth);
            if (!isNaN(fundgzGszzl) && residualWeight > 0.01) {
                residualRate = (fundgzGszzl - top10Contribution) / (residualWeight / 100);
                const top10AvgRate = top10Weight > 0 ? top10Contribution / (top10Weight / 100) : 0;
                if (Math.abs(residualRate) > Math.abs(top10AvgRate) * 3 + 5) {
                    residualRate = top10AvgRate;
                }
            } else if (top10Weight > 0) {
                residualRate = top10Contribution / (top10Weight / 100);
            }

            const fallbackEst = top10Contribution + (residualWeight / 100) * residualRate;
            const estDayChg = (!isNaN(fundgzGszzl)) ? fundgzGszzl : fallbackEst;

            holdingsCache[fund.code] = {
                top10Weight,
                top10Contribution,
                residualWeight,
                residualRate,
                estDayChg,
                timestamp: Date.now()
            };
            if (Number.isFinite(estDayChg)) fund.dayGrowth = estDayChg;
        }

        function initChart() {
            const dom = document.getElementById('klineChart');
            chart = echarts.init(dom);
            chart.setOption({
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: 'rgba(255,255,255,0.95)', padding: 12 },
                grid: { left: '3%', right: '4%', bottom: '20', top: '20', containLabel: true },
                xAxis: { type: 'category', boundaryGap: false, axisLine: { lineStyle: { color: '#e5e5e5' } }, axisLabel: { color: '#737373' } },
                yAxis: { type: 'value', scale: true, splitLine: { lineStyle: { color: '#f5f5f5' } }, axisLabel: { color: '#737373' } },
                series: [{ name: 'ÂáÄÂÄº', type: 'line', smooth: true, symbol: 'none', connectNulls: true, lineStyle: { width: 3, color: '#3b82f6' }, areaStyle: { color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(59,130,246,0.3)'},{offset:1,color:'rgba(59,130,246,0.05)'}]) }, emphasis: { focus: 'series' } }]
            });
            initTurningPointMagnet();
            window.addEventListener('resize', () => chart.resize());
        }

        let _turningPointIdxs = [];
        let _turningPointLabels = [];
        let _magnetLock = false;

        function setTurningPointMagnetData(labels, values, maxPoints, extraIdxs) {
            const idxs = pickTurningPoints(values, maxPoints);
            const merged = [];
            if (Array.isArray(idxs)) merged.push(...idxs);
            if (Array.isArray(extraIdxs)) merged.push(...extraIdxs);
            const uniq = Array.from(new Set(merged.filter(v => Number.isFinite(v) && v >= 0)));
            _turningPointIdxs = uniq.sort((a, b) => a - b);
            _turningPointLabels = Array.isArray(labels) ? labels : [];
        }

        function findNearestIdx(sortedIdxs, target) {
            if (!Array.isArray(sortedIdxs) || sortedIdxs.length === 0) return -1;
            let lo = 0;
            let hi = sortedIdxs.length - 1;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const v = sortedIdxs[mid];
                if (v === target) return v;
                if (v < target) lo = mid + 1;
                else hi = mid - 1;
            }
            const candA = hi >= 0 ? sortedIdxs[hi] : null;
            const candB = lo < sortedIdxs.length ? sortedIdxs[lo] : null;
            if (candA === null) return candB ?? -1;
            if (candB === null) return candA ?? -1;
            return (Math.abs(candA - target) <= Math.abs(candB - target)) ? candA : candB;
        }

        function axisValueToIndex(val) {
            if (typeof val === 'number' && Number.isFinite(val)) return val;
            if (!val) return -1;
            const s = String(val);
            const idx = _turningPointLabels.indexOf(s);
            return idx >= 0 ? idx : -1;
        }

        function initTurningPointMagnet() {
            if (!chart) return;
            chart.off('updateAxisPointer');
            chart.on('updateAxisPointer', (e) => {
                if (_magnetLock) return;
                const info = e?.axesInfo?.[0];
                if (!info) return;
                const curIdx = axisValueToIndex(info.value);
                if (curIdx < 0) return;
                const nearest = findNearestIdx(_turningPointIdxs, curIdx);
                if (nearest < 0) return;

                const threshold = 1; // Èôç‰ΩéÁ£ÅÂê∏ÂäõÂ∫¶ÔºåÈÅøÂÖçÂΩ±ÂìçËá™Áî±ÁßªÂä®
                if (Math.abs(nearest - curIdx) <= threshold && nearest !== curIdx) {
                    _magnetLock = true;
                    try {
                        chart.dispatchAction({ type: 'showTip', seriesIndex: 0, dataIndex: nearest });
                    } finally {
                        setTimeout(() => { _magnetLock = false; }, 0);
                    }
                }
            });
        }

        function pickTurningPoints(values, maxPoints = 12) {
            if (!Array.isArray(values) || values.length < 3) return [];
            const pts = [];
            let lastFinite = -1;
            for (let i = 0; i < values.length; i++) {
                if (Number.isFinite(values[i])) { lastFinite = i; break; }
            }
            if (lastFinite < 0) return [];
            let prev = values[lastFinite];
            let prevDiff = 0;
            for (let i = lastFinite + 1; i < values.length; i++) {
                const v = values[i];
                if (!Number.isFinite(v)) continue;
                const diff = v - prev;
                if (prevDiff !== 0 && diff !== 0 && (prevDiff > 0) !== (diff > 0)) {
                    // ËΩ¨ÊäòÁÇπÂá∫Áé∞Âú® prev ÂØπÂ∫îÁöÑÁ¥¢ÂºïÈôÑËøë
                    pts.push({ idx: i - 1, score: Math.abs(prevDiff) + Math.abs(diff) });
                }
                if (diff !== 0) prevDiff = diff;
                prev = v;
            }
            if (pts.length <= maxPoints) return pts.map(p => p.idx);
            pts.sort((a, b) => b.score - a.score);
            const top = pts.slice(0, maxPoints).map(p => p.idx).sort((a, b) => a - b);
            return top;
        }

        function changeTimeRange(range) {
            currentTimeRange = range;
            document.querySelectorAll('.time-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            if (range === 'realtime') {
                updateRealtimeChart();
                startRealtimeUpdate();
                if (selectedFund) fetchHistoryData(selectedFund.code, false);
            }
            else {
                stopRealtimeUpdate();
                if (!selectedFund) return;
                if (historyCache[selectedFund.code]) { renderHistoryChart(selectedFund.code); }
                else { fetchHistoryData(selectedFund.code, true); }
            }
        }

        function getRealtimeChartData(fund) {
            const labels = [];
            for (let m=570; m<=690; m++) labels.push(`${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`);
            for (let m=780; m<=900; m++) labels.push(`${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`);
            const history = getRealtimeSeriesForChart(fund);
            let end = getEffectiveRealtimeEndIndex(history);
            if (end < 0) end = history.length - 1;
            const xData = labels.slice(0, end + 1);
            const yData = history.slice(0, end + 1);
            return { labels, history, end, xData, yData };
        }

        function updateRealtimeChart() {
            if (!selectedFund) return;
            document.getElementById('chartTypeLabel').innerHTML = `ÂÆûÊó∂‰º∞ÂÄºËµ∞Âäø`;
            const { xData, yData } = getRealtimeChartData(selectedFund);

            setTurningPointMagnetData(xData, yData, 16);

            const baseNav = parseFloat(selectedFund.currentNav);
            chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: (params) => {
                        const pNav = params?.[0];
                        const t = pNav?.axisValueLabel || '';
                        const rawNav = pNav?.data;
                        const nav = (rawNav === null || rawNav === undefined) ? NaN : Number(rawNav);
                        const navText = Number.isFinite(nav) ? nav.toFixed(4) : '--';

                        let pct = NaN;
                        if (Number.isFinite(baseNav) && baseNav > 0 && Number.isFinite(nav)) {
                            pct = ((nav - baseNav) / baseNav) * 100;
                        }
                        const pctText = Number.isFinite(pct) ? ((pct >= 0 ? '+' : '') + pct.toFixed(2) + '%') : '--';
                        const pctColor = Number.isFinite(pct) ? (pct >= 0 ? '#ef4444' : '#10b981') : '#737373';
                        return `${t}<br/>ÂáÄÂÄºÔºö${navText}<br/>Ê∂®Ë∑åÂπÖÔºö<span style="color:${pctColor};font-weight:700;">${pctText}</span>`;
                    }
                },
                xAxis: {
                    data: xData,
                    axisTick: { show: false },
                    minorTick: { show: false },
                    axisLabel: {
                        color: '#737373',
                        interval: 0,
                        formatter: (value) => {
                            if (value === '09:30') return '09:30';
                            if (value === '11:30') return '11:30/13:00';
                            if (value === '15:00') return '15:00';
                            return '';
                        }
                    }
                },
                series: [{ name: 'ÂáÄÂÄº', data: yData }]
            });
        }

        // Ê†πÊçÆÊó∂Èó¥ËåÉÂõ¥ËÆ°ÁÆóÊà™Êñ≠Êó∂Èó¥Êà≥ÔºàÊØ´ÁßíÔºâ
        function getCutoffTimestamp(range) {
            const t = getShanghaiTimeParts();
            const today = new Date(Date.UTC(t.year, t.month - 1, t.day)); // ‰∏äÊµ∑"‰ªäÂ§©"00:00 UTC
            let cutoff;
            switch (range) {
                case '5d':  cutoff = new Date(today); cutoff.setUTCDate(cutoff.getUTCDate() - 7); break;
                case '1m':  cutoff = new Date(today); cutoff.setUTCMonth(cutoff.getUTCMonth() - 1); break;
                case '3m':  cutoff = new Date(today); cutoff.setUTCMonth(cutoff.getUTCMonth() - 3); break;
                case '1y':  cutoff = new Date(today); cutoff.setUTCFullYear(cutoff.getUTCFullYear() - 1); break;
                case 'all': return 0; // ÊàêÁ´ãÊù•‰∏çÊà™Êñ≠
                default:    cutoff = new Date(today); cutoff.setUTCDate(cutoff.getUTCDate() - 7); break;
            }
            return cutoff.getTime();
        }

        // Â∞ÜÊó∂Èó¥Êà≥ËΩ¨‰∏∫ YYYY-MM-DDÔºà‰∏äÊµ∑Êó∂Âå∫ +8Ôºâ
        function tsToDateStr(ts) {
            const d = new Date(ts + 8 * 3600000); // Âä†8Â∞èÊó∂ÂêéÊåâUTCËØª
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth() + 1).padStart(2, '0');
            const dd = String(d.getUTCDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        function getBuyMarkersForHistoryChart(fund, labels, values) {
            const out = { data: [], byDate: {}, idxs: [] };
            if (!fund || !Array.isArray(labels) || !Array.isArray(values) || labels.length !== values.length) return out;
            const buys = getFundBuys(fund);
            if (!buys.length) return out;

            for (const b of buys) {
                const bp = getFirstHistoryPointOnOrAfter(fund.code, b.date);
                const effDate = bp?.date;
                if (!effDate) continue;
                const idx = labels.indexOf(effDate);
                if (idx < 0) continue;
                const nav = Number(values[idx]);
                if (!Number.isFinite(nav)) continue;
                if (!out.byDate[effDate]) out.byDate[effDate] = [];
                out.byDate[effDate].push({ buyDate: b.date, amount: Number(b.amount), effDate, nav });
                out.idxs.push(idx);
            }

            for (const [d, items] of Object.entries(out.byDate)) {
                // ‰∏Ä‰∏™ÁîüÊïàÊó•Âè™Áîª‰∏Ä‰∏™ÁÇπÔºå‰ΩÜ tooltip ÈáåÂàóÂá∫Â§öÁ¨î
                const nav = items?.[0]?.nav;
                if (!Number.isFinite(nav)) continue;
                out.data.push({ value: [d, nav], _buyItems: items });
            }

            out.data.sort((a, b) => (String(a.value?.[0]) < String(b.value?.[0]) ? -1 : 1));
            out.idxs = Array.from(new Set(out.idxs.filter(v => Number.isFinite(v) && v >= 0))).sort((a, b) => a - b);
            return out;
        }

        function getSellMarkersForHistoryChart(fund, labels, values) {
            const out = { data: [], byDate: {}, idxs: [] };
            if (!fund || !Array.isArray(labels) || !Array.isArray(values) || labels.length !== values.length) return out;
            const sells = getFundSells(fund);
            if (!sells.length) return out;
            for (const s of sells) {
                const bp = getFirstHistoryPointOnOrAfter(fund.code, s.date);
                const effDate = bp?.date;
                if (!effDate) continue;
                const idx = labels.indexOf(effDate);
                if (idx < 0) continue;
                const nav = Number(values[idx]);
                if (!Number.isFinite(nav)) continue;
                if (!out.byDate[effDate]) out.byDate[effDate] = [];
                out.byDate[effDate].push({ sellDate: s.date, effDate, nav, all: !!s.all, amount: s.amount });
                out.idxs.push(idx);
            }
            for (const [d, items] of Object.entries(out.byDate)) {
                const nav = items?.[0]?.nav;
                if (!Number.isFinite(nav)) continue;
                out.data.push({ value: [d, nav], _sellItems: items });
            }
            out.data.sort((a, b) => (String(a.value?.[0]) < String(b.value?.[0]) ? -1 : 1));
            out.idxs = Array.from(new Set(out.idxs.filter(v => Number.isFinite(v) && v >= 0))).sort((a, b) => a - b);
            return out;
        }

        // ‰ªéÁºìÂ≠òÊï∞ÊçÆÊ∏≤ÊüìÂõæË°® + ÂéÜÂè≤Ë°®Ê†ºÔºà‰∏çÂèëÁΩëÁªúËØ∑Ê±ÇÔºâ
        function renderHistoryChart(code) {
            const all = historyCache[code];
            if (!all || all.length === 0) return;

            const cutoff = getCutoffTimestamp(currentTimeRange);
            const data = all.filter(p => p.x >= cutoff); // ÊåâÊó∂Èó¥Êà≥Êà™Êñ≠

            const labels = data.map(p => tsToDateStr(p.x));
            const values = data.map(p => p.y);

            const fund = funds.find(f => f.code === code);
            const buyMarkers = getBuyMarkersForHistoryChart(fund, labels, values);
            const sellMarkers = getSellMarkersForHistoryChart(fund, labels, values);

            setTurningPointMagnetData(labels, values, 18, [...(buyMarkers.idxs || []), ...(sellMarkers.idxs || [])]);

            const rangeLabel = { '5d':'1Âë®', '1m':'1Êúà', '3m':'3Êúà', '1y':'1Âπ¥', 'all':'ÊàêÁ´ãÊù•' };
            document.getElementById('chartTypeLabel').innerHTML = `${rangeLabel[currentTimeRange] || ''}ÂáÄÂÄºËµ∞Âäø`;

            chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: (params) => {
                        const pLine = Array.isArray(params) ? params.find(p => p.seriesType === 'line') : null;
                        const date = (pLine?.axisValueLabel || pLine?.axisValue || '').toString();
                        const nav = (pLine?.data === null || pLine?.data === undefined) ? NaN : Number(pLine.data);
                        const navText = Number.isFinite(nav) ? nav.toFixed(4) : '--';

                        let html = `${date}<br/>ÂáÄÂÄºÔºö${navText}`;
                        const items = (buyMarkers.byDate && date) ? buyMarkers.byDate[date] : null;
                        if (Array.isArray(items) && items.length > 0) {
                            html += `<br/><span style="font-weight:800;">‰π∞ÂÖ•Ôºö</span>`;
                            for (const it of items) {
                                const amt = Number(it.amount);
                                const amtText = Number.isFinite(amt) ? amt.toFixed(2) : '--';
                                html += `<br/>${it.buyDate} ¬•${amtText}`;
                            }
                        }
                        const sItems = (sellMarkers.byDate && date) ? sellMarkers.byDate[date] : null;
                        if (Array.isArray(sItems) && sItems.length > 0) {
                            html += `<br/><span style="font-weight:800;">ÂçñÂá∫Ôºö</span>`;
                            for (const it of sItems) {
                                if (it.all) {
                                    html += `<br/>${it.sellDate} Ê∏Ö‰ªì`;
                                } else {
                                    const amt = Number(it.amount);
                                    const amtText = Number.isFinite(amt) ? amt.toFixed(2) : '--';
                                    html += `<br/>${it.sellDate} ¬•${amtText}`;
                                }
                            }
                        }
                        return html;
                    }
                },
                xAxis: {
                    data: labels,
                    axisTick: { show: true },
                    minorTick: { show: false },
                    axisLabel: {
                        color: '#737373',
                        interval: 'auto',
                        formatter: null
                    }
                },
                series: [
                    { name: 'ÂáÄÂÄº', data: values },
                    {
                        name: '‰π∞ÂÖ•',
                        type: 'scatter',
                        data: buyMarkers.data,
                        symbol: 'circle',
                        symbolSize: 9,
                        itemStyle: { color: '#ef4444', borderColor: '#ffffff', borderWidth: 2 },
                        emphasis: { scale: 1.25 },
                        z: 5
                    },
                    {
                        name: 'ÂçñÂá∫',
                        type: 'scatter',
                        data: sellMarkers.data,
                        symbol: 'diamond',
                        symbolSize: 10,
                        itemStyle: { color: '#10b981', borderColor: '#ffffff', borderWidth: 2 },
                        emphasis: { scale: 1.25 },
                        z: 5
                    }
                ]
            });
        }

        function resetHistoryTable(code) {
            historyTableState.code = code;
            historyTableState.rendered = 0;
            const tbody = document.getElementById('historyTableBody');
            if (tbody) tbody.innerHTML = '';
            appendHistoryTableRows();
        }

        function appendHistoryTableRows() {
            const code = historyTableState.code;
            const all = code ? historyCache[code] : null;
            const tbody = document.getElementById('historyTableBody');
            if (!tbody) return;
            if (!all || all.length === 0) {
                if (historyTableState.rendered === 0) {
                    tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">ÊöÇÊó†Êï∞ÊçÆ</td></tr>`;
                }
                return;
            }

            const start = historyTableState.rendered;
            const end = Math.min(start + historyTableState.pageSize, all.length);
            if (start >= end) return;

            const rows = [];
            for (let k = start; k < end; k++) {
                const i = all.length - 1 - k;
                if (i < 0) break;
                const date = tsToDateStr(all[i].x);
                const val = all[i].y;
                const pct = i > 0 ? (((all[i].y - all[i - 1].y) / all[i - 1].y) * 100) : 0;

                let dayProfitText = '--';
                let dayProfitClass = '';
                const fund = funds.find(f => f.code === code);
                if (fund && i > 0) {
                    // ËÆ°ÁÆóÂà∞‚Äú‰∏ä‰∏Ä‰∫§ÊòìÊó•(all[i-1])‚Äù‰∏∫Ê≠¢ÁöÑÂÆûÈôÖÊåÅÊúâ‰ªΩÈ¢ùÔºà‰π∞ÂÖ•-ÂçñÂá∫Ôºâ
                    const prevDate = tsToDateStr(all[i - 1].x);
                    const buys = getFundBuys(fund);
                    const sells = getFundSells(fund);
                    const txs = [];
                    for (const b of buys) {
                        const bp = getFirstHistoryPointOnOrAfter(code, b.date);
                        const eff = bp?.date;
                        const nav0 = bp ? Number(bp.y) : NaN;
                        if (!eff || eff > prevDate || !Number.isFinite(nav0) || nav0 <= 0) continue;
                        txs.push({ type: 'buy', effDate: eff, amount: Number(b.amount), nav: nav0 });
                    }
                    for (const s of sells) {
                        const bp = getFirstHistoryPointOnOrAfter(code, s.date);
                        const eff = bp?.date;
                        const nav0 = bp ? Number(bp.y) : NaN;
                        if (!eff || eff > prevDate || !Number.isFinite(nav0) || nav0 <= 0) continue;
                        txs.push({ type: 'sell', effDate: eff, amount: s.amount, all: !!s.all, nav: nav0 });
                    }
                    txs.sort((a, b) => (a.effDate < b.effDate ? -1 : (a.effDate > b.effDate ? 1 : (a.type === b.type ? 0 : (a.type === 'buy' ? -1 : 1)))));

                    let invested0 = 0;
                    let sharesPrev = 0;
                    for (const tx of txs) {
                        if (tx.type === 'buy') {
                            const sh0 = tx.amount / tx.nav;
                            if (!Number.isFinite(sh0) || sh0 <= 0) continue;
                            sharesPrev += sh0;
                            invested0 += tx.amount;
                        } else {
                            if (sharesPrev <= 0) continue;
                            const avgCost = invested0 > 0 ? (invested0 / sharesPrev) : 0;
                            let sellShares = 0;
                            if (tx.all) sellShares = sharesPrev;
                            else sellShares = tx.amount / tx.nav;
                            if (!Number.isFinite(sellShares) || sellShares <= 0) continue;
                            sellShares = Math.min(sellShares, sharesPrev);
                            sharesPrev -= sellShares;
                            invested0 -= avgCost * sellShares;
                            if (sharesPrev <= 0.00000001) { sharesPrev = 0; invested0 = 0; }
                            if (invested0 < 0) invested0 = 0;
                        }
                    }

                    if (sharesPrev <= 0) {
                        const legacy = getPositionFromLegacy(fund);
                        if (legacy.has) sharesPrev = Number(legacy.shares) || 0;
                    }
                    if (Number.isFinite(sharesPrev) && sharesPrev > 0) {
                        const dayProfit = (all[i].y - all[i - 1].y) * sharesPrev;
                        dayProfitText = '¬•' + dayProfit.toFixed(2);
                        dayProfitClass = dayProfit >= 0 ? 'positive' : 'negative';
                    }
                }

                const pctText = (i > 0)
                    ? ((pct >= 0 ? '+' : '') + pct.toFixed(2) + '%')
                    : '--';
                rows.push(`<tr><td>${date}</td><td>${val.toFixed(4)}</td><td class="${i > 0 ? (pct>=0?'positive':'negative') : ''}">${pctText}</td><td class="${dayProfitClass}">${dayProfitText}</td></tr>`);
            }

            if (historyTableState.rendered === 0) tbody.innerHTML = '';
            tbody.insertAdjacentHTML('beforeend', rows.join(''));
            historyTableState.rendered = end;
        }

        // ÊãâÂèñ pingzhongdata ÂÖ®ÂéÜÂè≤Âπ∂ÁºìÂ≠òÔºåÁÑ∂ÂêéÊ∏≤Êüì
        async function fetchHistoryData(code, renderChart = true) {
            if (historyCache[code]) {
                if (renderChart) renderHistoryChart(code);
                resetHistoryTable(code);
                return;
            }

            try {
                console.log(`üîÑ [ÂéÜÂè≤-pingzhongdata] ÊãâÂèñ ${code}...`);
                await loadScript(`https://fund.eastmoney.com/pingzhongdata/${code}.js?rt=${Date.now()}`, 12000);
                const raw = window.Data_netWorthTrend;
                if (!Array.isArray(raw) || raw.length === 0) throw new Error('Data_netWorthTrend ‰∏∫Á©∫');

                // ÁºìÂ≠òÂÖ®ÈÉ®Êï∞ÊçÆÔºàÊØèÊù° {x: Êó∂Èó¥Êà≥, y: ÂáÄÂÄº}Ôºâ
                historyCache[code] = raw.map(item => ({ x: item.x, y: item.y }));
                console.log(`‚úÖ [ÂéÜÂè≤-pingzhongdata] ${code} ÂÖ± ${raw.length} Êù°ÔºåÂ∑≤ÁºìÂ≠ò`);

                // Áî®ÊúÄÊñ∞‰∏ÄÊù°ÂêåÊ≠•ÂáÄÂÄº
                if (selectedFund && selectedFund.code === code) {
                    const latest = raw[raw.length - 1];
                    const prev   = raw.length >= 2 ? raw[raw.length - 2] : null;
                    const jzrq   = tsToDateStr(latest.x);
                    if (jzrq > (selectedFund.navDate || '')) {
                        selectedFund.navDate  = jzrq;
                        selectedFund.currentNav = latest.y;
                        saveFunds();
                        updateMainDisplay(selectedFund);
                    }
                }

                if (renderChart) renderHistoryChart(code);
                resetHistoryTable(code);
            } catch(e) {
                console.error('üí• ÂéÜÂè≤Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•:', e);
                document.getElementById('historyTableBody').innerHTML = `<tr><td colspan="4" style="text-align:center;color:var(--gray-500);padding:40px;">Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•</td></tr>`;
            }
        }

        document.getElementById('historyScroll')?.addEventListener('scroll', (e) => {
            const el = e.target;
            if (!el) return;
            if (el.scrollTop + el.clientHeight >= el.scrollHeight - 20) {
                appendHistoryTableRows();
            }
        });

        function startRealtimeUpdate() { startUnifiedRefreshLoop(); }
        function stopRealtimeUpdate() { /* unified loop handles stop */ }
        function startAutoUpdate() { startUnifiedRefreshLoop(); }

        function startUnifiedRefreshLoop() {
            if (refreshInterval) return;
            refreshInterval = setInterval(() => {
                refreshLock = refreshLock.then(async () => {
                    const status = getMarketStatus();
                    const now = Date.now();

                    // ‰ºëÂ∏ÇÊúüÈó¥ÔºöÊöÇÂÅúÊâÄÊúâËΩÆËØ¢‰ªªÂä°ÔºåÈô§‚ÄúÈúÄË¶ÅË°•ÂÖ®‚ÄùÁöÑ‰º∞ÂÄºÊ∫ê
                    // - ‰∫§Êòì‰∏≠/ÁõòÂêéË°•ÂÖ®ÔºöÁÖßÂ∏∏Âà∑Êñ∞Ôºà‰º∞ÂÄº/ÊåÅ‰ªì/ÊåáÊï∞Ôºâ
                    // - ÂçàÈó¥‰ºëÂ∏ÇÔºö‰ªÖ‰ΩéÈ¢ëÂà∑Êñ∞‚ÄúÈÄâ‰∏≠Âü∫Èáë‚ÄùÁöÑ‰º∞ÂÄºÔºåÂÖ∂‰ªñÊ®°ÂùóÊöÇÂÅú
                    // - ÁõòÂâç/ÁõòÂêé/Âë®Êú´Á≠âÔºöÂÖ®ÈÉ®ÊöÇÂÅú
                    if (!status.canRealtimeUpdate) {
                        if (status.reason !== 'ÂçàÈó¥‰ºëÂ∏Ç') return;
                        const minMiddayFundInterval = 15000;
                        if (!selectedFund) return;
                        // Âçà‰ºëË°•ÂÖ®ÔºöÂ¶ÇÊûúÂ∑≤ÁªèÊãøÂà∞ 11:30Ôºà‰∏äÂçàÊî∂ÁõòÔºâÊï∞ÊçÆÔºåÂ∞±‰∏çÂÜçÈáçÂ§çËØ∑Ê±ÇÔºåÁ≠â 13:00 ÂêéÂÜçÊÅ¢Â§ç
                        const sh = getShanghaiTimeParts();
                        const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
                        const middayEndIdx = getRealtimeMinuteIndexFromGzTime(`${todayStr} 11:30`);
                        const curIdx = getRealtimeMinuteIndexFromGzTime(selectedFund.estimatedTime);
                        if (middayEndIdx >= 0 && curIdx >= middayEndIdx) return;
                        if (now - lastFundRefreshAt < minMiddayFundInterval) return;
                        lastFundRefreshAt = now;
                        await fetchFundData(selectedFund, { suppressRender: true });
                        renderFundList();
                        updateMainDisplay(selectedFund);
                        if (currentTimeRange === 'realtime') updateRealtimeChart();
                        return;
                    }

                    const minFundInterval = 2900;
                    const minIndicesInterval = 2900;

                    // ÂÖ®Â±ÄÈôêÊµÅÔºöÊØèÁßíÊúÄÂ§ö‰∏ÄÊ¨°‚ÄúÁΩëÁªú‰ªªÂä°‚ÄùÔºåÁî®ËΩÆËØ¢Ë∞ÉÂ∫¶‰øùËØÅÂêÑÊ®°ÂùóÈÉΩËÉΩÊõ¥Êñ∞
                    // tick%4:
                    //   0/1: ËΩÆËØ¢Âà∑Êñ∞‰∏ÄÂè™Âü∫Èáë‰º∞ÂÄºÔºàÈÅøÂÖçÂ§öÂü∫ÈáëÂêåÁßíÂ§öËØ∑Ê±ÇÔºâ
                    //   2:   Âà∑Êñ∞ÈÄâ‰∏≠Âü∫ÈáëÊåÅ‰ªìÊ∂®Ë∑åÔºàÊâπÈáèÊé•Âè£‰∏ÄÊ¨°ËØ∑Ê±ÇÔºâ
                    //   3:   Âà∑Êñ∞ÊåáÊï∞
                    refreshTick = (refreshTick + 1) % 4;

                    if ((refreshTick === 0 || refreshTick === 1) && funds.length > 0 && now - lastFundRefreshAt >= minFundInterval) {
                        lastFundRefreshAt = now;
                        fundRefreshCursor = fundRefreshCursor % funds.length;
                        const f = funds[fundRefreshCursor];
                        fundRefreshCursor++;
                        await fetchFundData(f, { suppressRender: true });
                        renderFundList();
                        if (selectedFund?.code === f.code) {
                            updateMainDisplay(selectedFund);
                            if (currentTimeRange === 'realtime') updateRealtimeChart();
                        }
                        return;
                    }

                    if (refreshTick === 2 && selectedFund) {
                        // ‰∫§ÊòìÊó∂ÊØèÁßí‰ªÖÊõ¥Êñ∞‚ÄúÊåÅ‰ªìÊ∂®Ë∑åÂπÖ‚ÄùÔºå‰∏çÈáçÁªòÊåÅ‰ªì/ÊùøÂùóÔºàÊâπÈáè‰∏ÄÊ¨°ËØ∑Ê±ÇÔºâ
                        await loadHoldingsAndSectors(selectedFund, { updateOnly: true });
                        updateDayGrowthDisplay(selectedFund);
                        return;
                    }

                    if (refreshTick === 3 && now - lastIndicesRefreshAt >= minIndicesInterval) {
                        lastIndicesRefreshAt = now;
                        await fetchMarketIndices();
                        return;
                    }

                    // ÁªìÊûÑÊÄßÊåÅ‰ªì/ÊùøÂùóÔºöÁª¥ÊåÅ‰ΩéÈ¢ëÔºà‰∏çÂç†Áî®ÊØèÁßíÈ¢ÑÁÆóÔºåÂè™ÊúâËΩÆÂà∞‰∏îË∂ÖÊó∂ÊâçÂà∑Êñ∞Ôºâ
                    if (selectedFund && now - lastHoldingsRefreshAt >= 30000) {
                        lastHoldingsRefreshAt = now;
                        await loadHoldingsAndSectors(selectedFund, { silent: true });
                        return;
                    }
                }).catch(err => console.warn('unified refresh loop error:', err));
            }, 3000);
        }

        function stopUnifiedRefreshLoop() {
            if (!refreshInterval) return;
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
        function showToast(msg, type='success', durationMs=3000, closable=false) {
            let container = document.getElementById('toastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toastContainer';
                container.className = 'toast-container';
                document.body.appendChild(container);
            }
            const t = document.createElement('div');
            t.className = `toast ${type}`;
            const row = document.createElement('div');
            row.className = 'toast-row';
            const m = document.createElement('div');
            m.className = 'toast-msg';
            m.textContent = msg;
            row.appendChild(m);
            let timer = null;
            const remove = () => {
                if (timer) clearTimeout(timer);
                t.remove();
                const c = document.getElementById('toastContainer');
                if (c && c.children.length === 0) c.remove();
            };
            if (closable) {
                const btn = document.createElement('button');
                btn.className = 'toast-close';
                btn.type = 'button';
                btn.textContent = '√ó';
                btn.onclick = remove;
                row.appendChild(btn);
            }
            t.appendChild(row);
            container.appendChild(t);
            const d = Number(durationMs);
            if (Number.isFinite(d) && d > 0) timer = setTimeout(remove, d);
        }

        let _suggestTimer = null;
        let _suggestItems = [];
        let _suggestActive = -1;

        async function fetchFundSuggest(keyword) {
            const key = (keyword || '').trim();
            if (!key) return [];
            const url = `https://fundsuggest.eastmoney.com/FundSearch/api/FundSearchAPI.ashx?m=1&key=${encodeURIComponent(key)}`;
            const json = await runWithSourceStat('fund_suggest_jsonp', async () => await fetchJsonp(url, 'callback', 8000));
            const arr = json?.Datas || json?.data || [];
            if (!Array.isArray(arr)) return [];
            return arr.map(x => {
                const code = (x.CODE || x.FCODE || x.code || '').toString();
                const name = (x.NAME || x.SHORTNAME || x.name || '').toString();
                const type = (x.JJType || x.type || '').toString();
                return { code, name, type };
            }).filter(x => /^\d{6}$/.test(x.code) && x.name);
        }

        function renderFundSuggest(items) {
            const box = document.getElementById('fundSuggest');
            if (!box) return;
            _suggestItems = Array.isArray(items) ? items.slice(0, 12) : [];
            _suggestActive = -1;
            if (_suggestItems.length === 0) {
                box.style.display = 'none';
                box.innerHTML = '';
                return;
            }
            box.style.display = 'block';
            box.innerHTML = _suggestItems.map((it, idx) => {
                const meta = it.type ? it.type : 'Âü∫Èáë';
                return `<div class="fund-suggest-item" data-idx="${idx}" onclick="selectSuggestItem(${idx})"><div class="fund-suggest-left"><div class="fund-suggest-name">${it.name}</div><div class="fund-suggest-meta">${meta}</div></div><div class="fund-suggest-code">${it.code}</div></div>`;
            }).join('');
        }

        function selectSuggestItem(idx) {
            const it = _suggestItems[idx];
            if (!it) return;
            const input = document.getElementById('fundCode');
            if (input) input.value = it.code;
            const box = document.getElementById('fundSuggest');
            if (box) { box.style.display = 'none'; box.innerHTML = ''; }
            _suggestItems = [];
            _suggestActive = -1;
            input?.focus();
        }

        function moveSuggestActive(delta) {
            const box = document.getElementById('fundSuggest');
            if (!box || box.style.display === 'none') return;
            const items = box.querySelectorAll('.fund-suggest-item');
            if (!items || items.length === 0) return;
            _suggestActive += delta;
            if (_suggestActive < 0) _suggestActive = items.length - 1;
            if (_suggestActive >= items.length) _suggestActive = 0;
            items.forEach((el, i) => el.classList.toggle('active', i === _suggestActive));
            const activeEl = items[_suggestActive];
            if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
        }

        document.getElementById('fundCode')?.addEventListener('input', (e) => {
            const v = (e.target.value || '').trim();
            clearTimeout(_suggestTimer);
            if (v.length < 2 || /^\d{6}$/.test(v)) { renderFundSuggest([]); return; }
            _suggestTimer = setTimeout(async () => {
                try {
                    const items = await fetchFundSuggest(v);
                    renderFundSuggest(items);
                } catch {
                    renderFundSuggest([]);
                }
            }, 220);
        });

        document.getElementById('fundCode')?.addEventListener('keydown', (e) => {
            const box = document.getElementById('fundSuggest');
            const visible = box && box.style.display !== 'none';
            if (!visible) {
                if (e.key === 'Enter') { addFund(); e.preventDefault(); }
                return;
            }
            if (e.key === 'ArrowDown') { moveSuggestActive(1); e.preventDefault(); return; }
            if (e.key === 'ArrowUp') { moveSuggestActive(-1); e.preventDefault(); return; }
            if (e.key === 'Enter') {
                if (_suggestActive >= 0) { selectSuggestItem(_suggestActive); }
                else if (_suggestItems.length > 0) { selectSuggestItem(0); }
                e.preventDefault();
                return;
            }
            if (e.key === 'Escape') { renderFundSuggest([]); return; }
        });

        document.addEventListener('click', (e) => {
            const box = document.getElementById('fundSuggest');
            const input = document.getElementById('fundCode');
            if (!box || !input) return;
            if (e.target === input || box.contains(e.target)) return;
            renderFundSuggest([]);
        });
    </script>
</body>
</html>
