<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FundFlow - æ™ºèƒ½åŸºé‡‘ç›‘æ§ç³»ç»Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #3b82f6; --primary-dark: #2563eb; --primary-light: #60a5fa; --primary-ultra-light: #dbeafe; --success: #ef4444; --danger: #10b981; --warning: #f59e0b; --purple: #8b5cf6; --purple-dark: #7c3aed; --gray-50: #fafafa; --gray-100: #f5f5f5; --gray-200: #e5e5e5; --gray-300: #d4d4d4; --gray-400: #a3a3a3; --gray-500: #737373; --gray-600: #525252; --gray-700: #404040; --gray-800: #262626; --gray-900: #171717; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #f0fdf4 100%); color: var(--gray-900); overflow-x: hidden; }
        .app-container { display: flex; height: 100vh; position: relative; }
        
        /* ç§»åŠ¨ç«¯èœå•æŒ‰é’® */
        .mobile-menu-btn { display: none; position: fixed; top: 20px; left: 20px; z-index: 1001; width: 48px; height: 48px; background: white; border: 2px solid var(--gray-200); border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1); flex-direction: column; align-items: center; justify-content: center; gap: 4px; }
        .mobile-menu-btn span { width: 24px; height: 3px; background: var(--gray-700); border-radius: 2px; transition: all 0.3s; }
        .mobile-menu-btn.active span:nth-child(1) { transform: rotate(45deg) translate(6px, 6px); }
        .mobile-menu-btn.active span:nth-child(2) { opacity: 0; }
        .mobile-menu-btn.active span:nth-child(3) { transform: rotate(-45deg) translate(6px, -6px); }
        
        .sidebar { width: 420px; background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border-right: 1px solid rgba(229, 229, 229, 0.6); display: flex; flex-direction: column; overflow: hidden; box-shadow: 4px 0 20px rgba(0, 0, 0, 0.03); transition: transform 0.3s; }
        .sidebar-header { padding: 20px 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .logo-card { background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #ec4899 100%); border-radius: 16px; padding: 14px 20px; color: white; box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3), 0 2px 8px rgba(139, 92, 246, 0.2); position: relative; overflow: hidden; }
        .logo-card::before { content: ''; position: absolute; top: -50%; right: -30px; width: 140px; height: 200%; background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0) 100%); transform: rotate(20deg); animation: shimmer 3s infinite; }
        @keyframes shimmer { 0% { transform: translateX(-100%) rotate(20deg); } 100% { transform: translateX(300%) rotate(20deg); } }
        .logo-content { position: relative; z-index: 1; }
        .logo-summary { position: absolute; top: 10px; right: 12px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px; font-size: 0.9rem; color: rgba(255,255,255,0.95); font-weight: 700; }
        .logo-summary .line { display: grid; grid-template-columns: auto auto; column-gap: 8px; align-items: baseline; }
        .logo-summary .line > span:first-child { justify-self: end; }
        .logo-summary .line > span:last-child { justify-self: end; text-align: right; font-variant-numeric: tabular-nums; min-width: 92px; }
        .logo-summary .label { opacity: 0.9; font-weight: 600; }
        .logo-icon { width: 32px; height: 32px; background: rgba(255, 255, 255, 0.25); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.125rem; margin-bottom: 6px; backdrop-filter: blur(10px); }
        .logo { font-size: 1.125rem; font-weight: 800; letter-spacing: -0.02em; margin-bottom: 4px; }
        .logo-subtitle { font-size: 0.75rem; opacity: 0.95; font-weight: 500; display: flex; align-items: center; gap: 8px; }
        .status-indicator { width: 7px; height: 7px; background: #10b981; border-radius: 50%; animation: pulse 2s infinite; box-shadow: 0 0 10px #10b981; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.15); } }
        
        /* å¸‚åœºæŒ‡æ•° */
        .market-indices { padding: 0; background: transparent; border: none; }
        .indices-toggle { width: 100%; padding: 16px 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border: none; border-bottom: 1px solid rgba(229, 229, 229, 0.6); cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s; }
        .indices-toggle:hover { background: rgba(249, 250, 251, 0.95); }
        .indices-toggle-left { display: flex; align-items: center; gap: 10px; }
        .indices-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); text-transform: uppercase; letter-spacing: 0.08em; display: flex; align-items: center; gap: 8px; margin: 0; }
        .indices-arrow { font-size: 0.875rem; color: var(--gray-500); transition: transform 0.3s; }
        .indices-arrow.open { transform: rotate(180deg); }
        .indices-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .indices-content.open { max-height: 2000px; }
        .indices-inner { padding: 16px 20px; }
        
        /* ä¿®å¤ï¼šå¼ºåˆ¶3åˆ—å¸ƒå±€ */
        .indices-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; } 
        
        .index-card { background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(249,250,251,0.9) 100%); border: 1.5px solid var(--gray-200); border-radius: 12px; padding: 12px 10px; transition: all 0.3s; cursor: pointer; display: flex; flex-direction: column; justify-content: space-between; min-height: 80px; }
        .index-card:hover { border-color: var(--primary-light); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.12); }
        .index-card.positive { background: linear-gradient(135deg, rgba(254, 242, 242, 0.9) 0%, rgba(255, 255, 255, 0.9) 100%); border-color: rgba(239, 68, 68, 0.3); }
        .index-card.negative { background: linear-gradient(135deg, rgba(236, 253, 245, 0.9) 0%, rgba(255, 255, 255, 0.9) 100%); border-color: rgba(16, 185, 129, 0.3); }
        .index-card.selected { border-color: var(--primary); box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2); grid-column: span 3; } /* é€‰ä¸­æ—¶å æ»¡ä¸€è¡Œ */
        
        .index-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px; }
        .index-name { font-size: 0.75rem; font-weight: 700; color: var(--gray-800); display: flex; align-items: center; gap: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
        .index-status-badge { font-size: 0.6rem; padding: 1px 4px; border-radius: 4px; background: var(--gray-100); color: var(--gray-500); font-weight: normal; margin-left: auto; display: none;}
        .index-card.closed .index-status-badge { display: inline-block; }
        .index-flag { font-size: 0.875rem; }
        
        .index-body { display: flex; flex-direction: column; align-items: flex-start; }
        .index-value { font-size: 1rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; color: var(--gray-900); line-height: 1.2; margin-bottom: 2px; }
        .index-change { font-size: 0.75rem; font-weight: 700; display: flex; align-items: center; gap: 2px; }
        .index-card.positive .index-change { color: #dc2626; }
        .index-card.negative .index-change { color: #059669; }
        
        .index-chart-container { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--gray-200); width: 100%; height: 180px; }
        .index-mini-chart { width: 100%; height: 100%; }
        .indices-refresh { margin-top: 12px; width: 100%; padding: 8px; background: var(--gray-50); border: 1px solid var(--gray-200); border-radius: 8px; font-size: 0.75rem; color: var(--gray-600); cursor: pointer; transition: all 0.2s; font-weight: 600; }
        .indices-refresh:hover { background: var(--gray-100); border-color: var(--gray-300); }
        
        .add-fund-section { padding: 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); }
        .section-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.08em; }
        .input-row { display: grid; grid-template-columns: 1fr auto; gap: 10px; margin-bottom: 10px; }
        .input-field { width: 100%; padding: 12px 16px; border: 2px solid var(--gray-200); border-radius: 12px; font-size: 0.9375rem; font-family: 'JetBrains Mono', monospace; transition: all 0.25s; background: white; }
        .input-field:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12); transform: translateY(-1px); }
        .btn-add { padding: 12px 24px; border: none; border-radius: 12px; font-size: 0.9375rem; font-weight: 700; cursor: pointer; transition: all 0.25s; background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; white-space: nowrap; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); position: relative; overflow: hidden; }
        .btn-add:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); }
        .optional-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .input-small { padding: 10px 14px; font-size: 0.875rem; }
        .helper-text { font-size: 0.75rem; color: var(--gray-500); margin-top: 10px; display: flex; align-items: center; gap: 6px; background: var(--gray-50); padding: 8px 12px; border-radius: 8px; border-left: 3px solid var(--primary-light); }
        .fund-suggest { margin-top: 8px; border: 1.5px solid var(--gray-200); border-radius: 12px; background: white; overflow: hidden; box-shadow: 0 8px 20px rgba(0,0,0,0.06); max-height: 260px; overflow-y: auto; display: none; }
        .fund-suggest-item { padding: 10px 12px; cursor: pointer; transition: background 0.15s; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .fund-suggest-item:hover, .fund-suggest-item.active { background: var(--gray-50); }
        .fund-suggest-left { min-width: 0; }
        .fund-suggest-name { font-size: 0.875rem; font-weight: 700; color: var(--gray-800); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .fund-suggest-meta { font-size: 0.75rem; color: var(--gray-500); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .fund-suggest-code { font-family: 'JetBrains Mono', monospace; font-size: 0.8125rem; font-weight: 800; color: var(--gray-700); background: var(--gray-100); padding: 4px 8px; border-radius: 8px; flex-shrink: 0; }
        .fund-list { flex: 1; overflow-y: auto; padding: 16px; }
        .fund-list::-webkit-scrollbar { width: 6px; }
        .fund-list::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 10px; }
        .fund-item { background: white; border: 2px solid transparent; border-radius: 16px; padding: 18px; margin-bottom: 14px; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .fund-item:hover { border-color: var(--primary-light); transform: translateX(6px) translateY(-2px); box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15); }
        .fund-item.active { background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%); border-color: var(--primary); transform: translateX(8px); }
        .fund-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 14px; }
        .fund-info { flex: 1; }
        .fund-name { font-size: 0.9375rem; font-weight: 700; color: var(--gray-900); margin-bottom: 6px; }
        .fund-code { font-size: 0.75rem; color: var(--gray-500); font-family: 'JetBrains Mono', monospace; background: var(--gray-100); padding: 3px 8px; border-radius: 6px; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; }
        .fund-code-chg { font-family: 'Inter', sans-serif; font-weight: 700; font-size: 0.6875rem; padding: 1px 5px; border-radius: 4px; white-space: nowrap; }
        .fund-code-chg.positive { background: #fef2f2; color: #dc2626; }
        .fund-code-chg.negative { background: #ecfdf5; color: #059669; }
        .fund-code-chg.neutral { background: var(--gray-100); color: var(--gray-500); }
        .fund-item.card-expanded .fund-code-chg { display: none; }
        .fund-item.card-collapsed .fund-code-chg { display: inline-block; }
        .fund-actions { display: flex; gap: 6px; }
        .btn-icon { width: 32px; height: 32px; border: none; background: var(--gray-100); border-radius: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .btn-icon:hover { background: var(--gray-200); transform: scale(1.1); }
        .fund-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 12px; }
        .metric-card { background: linear-gradient(135deg, var(--gray-50) 0%, white 100%); padding: 12px; border-radius: 12px; border: 1px solid var(--gray-200); }
        .metric-label { font-size: 0.6875rem; color: var(--gray-600); margin-bottom: 4px; text-transform: uppercase; font-weight: 600; display: flex; justify-content: space-between; }
        .metric-value { font-size: 1.125rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; }
        .positive { color: var(--success); }
        .negative { color: var(--danger); }
        /* åŸºé‡‘å¡ç‰‡æŠ˜å  */
        .fund-body { max-height: 200px; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1); }
        .fund-body.collapsed { max-height: 0; }
        .fund-header { cursor: pointer; user-select: none; }
        .fund-collapse-arrow { font-size: 0.7rem; color: var(--gray-400); transition: transform 0.3s; margin-left: 4px; display: inline-block; }
        .fund-collapse-arrow.collapsed { transform: rotate(-90deg); }
        
        /* ä¸»é¡µæ ‡é¢˜æ æŠ˜å  */
        .header-collapse-btn { background: none; border: 1.5px solid var(--gray-200); border-radius: 8px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--gray-500); font-size: 0.875rem; transition: all 0.2s; }
        .header-collapse-btn:hover { border-color: var(--primary-light); color: var(--primary); background: var(--primary-ultra-light); }
        .stats-grid-wrapper { max-height: 520px; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1), margin 0.35s; padding: 6px 0; }
        .stats-grid-wrapper.collapsed { max-height: 0; margin-top: 0 !important; padding: 0; }
        .stats-grid-wrapper { margin-top: 16px; }
        
        /* æ—¥æ¶¨è·Œä¼°ç®—æ ‡è®° */
        .day-growth-source { display: inline-flex; align-items: center; font-size: 0.6875rem; font-weight: 600; padding: 2px 6px; border-radius: 4px; margin-left: 6px; line-height: 1; border: 1px solid transparent; user-select: none; }
        .day-growth-source.est { background: rgba(139,92,246,0.1); color: #7c3aed; border-color: rgba(139,92,246,0.22); }
        .day-growth-source.official { background: var(--gray-100); color: var(--gray-500); border-color: var(--gray-200); }
        
        /* æ·»åŠ åŸºé‡‘åŒºåŸŸæŠ˜å  */
        .add-fund-toggle { width: 100%; padding: 14px 24px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border: none; border-bottom: 1px solid rgba(229,229,229,0.6); cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: background 0.2s; }
        .add-fund-toggle:hover { background: rgba(249,250,251,0.98); }
        .add-fund-toggle-left { display: flex; align-items: center; gap: 10px; }
        .add-fund-toggle-title { font-size: 0.8125rem; font-weight: 700; color: var(--gray-700); text-transform: uppercase; letter-spacing: 0.08em; }
        .add-fund-arrow { font-size: 0.75rem; color: var(--gray-500); transition: transform 0.3s; }
        .add-fund-arrow.open { transform: rotate(180deg); }
        .add-fund-body { max-height: 0; overflow: hidden; transition: max-height 0.35s cubic-bezier(.4,0,.2,1); background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(229,229,229,0.6); }
        .add-fund-body.open { max-height: 300px; }
        .add-fund-inner { padding: 16px 24px 20px; }

        /* æŒä»“ç¼–è¾‘å¯¹è¯æ¡† */
        .pos-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); backdrop-filter: blur(4px); z-index: 20000; display: none; align-items: center; justify-content: center; }
        .pos-modal-overlay.active { display: flex; }
        .pos-modal { background: white; border-radius: 20px; width: 360px; max-width: 92vw; box-shadow: 0 24px 60px rgba(0,0,0,0.22); overflow: hidden; animation: posModalIn 0.22s cubic-bezier(.4,0,.2,1); }
        @keyframes posModalIn { from { transform: translateY(24px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .pos-modal-header { padding: 22px 24px 16px; display: flex; justify-content: space-between; align-items: center; }
        .pos-modal-title { font-size: 1.0625rem; font-weight: 800; color: var(--gray-900); }
        .pos-modal-close { width: 28px; height: 28px; border: none; background: var(--gray-100); border-radius: 8px; cursor: pointer; font-size: 1.125rem; color: var(--gray-500); display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
        .pos-modal-close:hover { background: var(--gray-200); color: var(--gray-700); }
        .pos-modal-body { padding: 0 24px 8px; }
        .pos-field { margin-bottom: 14px; }
        .pos-field label { display: block; font-size: 0.75rem; font-weight: 700; color: var(--gray-600); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.04em; }
        .pos-field input { width: 100%; padding: 10px 14px; border: 2px solid var(--gray-200); border-radius: 10px; font-size: 0.9375rem; font-family: 'JetBrains Mono', monospace; font-weight: 600; transition: border-color 0.2s; background: var(--gray-50); }
        .pos-field input:focus { outline: none; border-color: var(--primary); background: white; }
        .pos-field input:disabled { opacity: 0.45; cursor: not-allowed; }
        .pos-quick-label { font-size: 0.6875rem; font-weight: 700; color: var(--gray-500); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.04em; }
        .pos-quick-row { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 14px; }
        .pos-quick-btn { flex: 1; min-width: 0; padding: 7px 4px; border: 1.5px solid var(--gray-200); border-radius: 8px; background: white; font-size: 0.75rem; font-weight: 700; color: var(--gray-700); cursor: pointer; transition: all 0.15s; text-align: center; white-space: nowrap; }
        .pos-quick-btn:hover { border-color: var(--primary-light); color: var(--primary); background: var(--primary-ultra-light); }
        .pos-quick-btn.danger { border-color: #fca5a5; color: #dc2626; }
        .pos-quick-btn.danger:hover { background: #fef2f2; border-color: #ef4444; }
        .pos-quick-btn.success { border-color: #6ee7b7; color: #059669; }
        .pos-quick-btn.success:hover { background: #ecfdf5; border-color: #10b981; }
        .pos-modal-footer { padding: 16px 24px 22px; display: flex; gap: 10px; justify-content: flex-end; }
        .pos-btn-cancel { padding: 9px 20px; border: 2px solid var(--gray-200); border-radius: 10px; background: white; font-size: 0.875rem; font-weight: 700; color: var(--gray-700); cursor: pointer; transition: all 0.15s; }
        .pos-btn-cancel:hover { border-color: var(--gray-300); background: var(--gray-50); }
        .pos-btn-save { padding: 9px 24px; border: none; border-radius: 10px; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; font-size: 0.875rem; font-weight: 700; cursor: pointer; transition: all 0.15s; box-shadow: 0 3px 10px rgba(59,130,246,0.3); }
        .pos-btn-save:hover { transform: translateY(-1px); box-shadow: 0 5px 16px rgba(59,130,246,0.4); }
        
        .fund-chart { height: 80px; background: var(--gray-50); border-radius: 10px; overflow: hidden; border: 1px solid var(--gray-200); }
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(255, 255, 255, 0.5); backdrop-filter: blur(10px); }
        .main-header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border-bottom: 1px solid rgba(229, 229, 229, 0.6); padding: 24px 32px; }
        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .fund-title-main { font-size: 1.75rem; font-weight: 800; color: var(--gray-900); margin-bottom: 8px; }
        .fund-meta { display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
        .fund-code-large { font-family: 'JetBrains Mono', monospace; font-size: 0.875rem; color: var(--gray-600); background: var(--gray-50); padding: 6px 14px; border-radius: 10px; font-weight: 600; border: 1px solid var(--gray-200); }
        .market-status { display: flex; align-items: center; gap: 8px; padding: 6px 14px; border-radius: 10px; font-size: 0.8125rem; font-weight: 600; }
        .market-status.open { background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; }
        .market-status.closed { background: var(--gray-50); color: var(--gray-700); border: 1px solid var(--gray-200); }
        .update-time { font-size: 0.8125rem; color: var(--gray-600); background: var(--gray-50); padding: 6px 14px; border-radius: 10px; border: 1px solid var(--gray-200); }
        .remind-chip { font-size: 0.8125rem; color: #b45309; background: rgba(245, 158, 11, 0.10); padding: 6px 12px; border-radius: 10px; border: 1px solid rgba(245, 158, 11, 0.22); cursor: pointer; user-select: none; font-weight: 700; display: inline-flex; align-items: center; gap: 6px; }
        .remind-chip.active { color: #047857; background: rgba(16, 185, 129, 0.10); border-color: rgba(16, 185, 129, 0.22); }
        .remind-chip.fired { color: var(--gray-700); background: var(--gray-50); border-color: var(--gray-200); }
        .remind-chip.alert { color: #b91c1c; background: #fef2f2; border-color: #fecaca; }
        .remind-chip.ring { animation: remindRing 0.8s ease-in-out infinite; transform-origin: 50% 0%; }
        @keyframes remindRing { 0% { transform: rotate(0deg); } 15% { transform: rotate(10deg); } 30% { transform: rotate(-10deg); } 45% { transform: rotate(8deg); } 60% { transform: rotate(-8deg); } 75% { transform: rotate(4deg); } 100% { transform: rotate(0deg); } }
        .remind-fired-hint { display: none; font-size: 0.75rem; color: var(--gray-700); background: white; border: 1px solid var(--gray-200); padding: 6px 10px; border-radius: 10px; cursor: pointer; user-select: none; max-width: 420px; }
        .remind-fired-hint.show { display: inline-flex; align-items: center; }
        .remind-fired-hint:hover { border-color: var(--gray-300); box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08); }
        .remind-fired-hint .rfh-viewport { height: 18px; overflow: hidden; display: block; }
        .remind-fired-hint .rfh-inner { display: block; will-change: transform; }
        .remind-fired-hint .rfh-item { height: 18px; line-height: 18px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
        .stat-card { background: white; padding: 20px; border-radius: 16px; border: 2px solid var(--gray-200); transition: all 0.3s; position: relative; overflow: hidden; }
        .stat-card:hover { border-color: var(--primary-light); transform: translateY(-4px); box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15); }
        .stat-label { font-size: 0.75rem; color: var(--gray-600); margin-bottom: 8px; text-transform: uppercase; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
        .stat-value { font-size: 1.875rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; margin-bottom: 6px; }
        .stat-change { font-size: 0.875rem; font-weight: 600; display: flex; align-items: center; gap: 4px; }
        .chart-section { flex: 1; padding: 32px; overflow-y: auto; }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
        .chart-title { font-size: 1.25rem; font-weight: 800; color: var(--gray-900); }
        .time-tabs { display: flex; gap: 8px; background: white; padding: 6px; border-radius: 14px; border: 1px solid var(--gray-200); }
        .time-tab { padding: 8px 18px; border: none; background: transparent; border-radius: 10px; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.2s; color: var(--gray-600); }
        .time-tab.active { background: var(--primary); color: white; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
        .chart-row { display: flex; gap: 24px; height: 480px; margin-bottom: 24px; }
        .chart-main { flex: 2; min-width: 0; display: flex; flex-direction: column; }
        .chart-side { flex: 1; min-width: 340px; display: flex; flex-direction: column; }
        .chart-container { background: white; border-radius: 20px; padding: 24px; height: 100%; display: flex; flex-direction: column; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); margin-bottom: 0; }
        #klineChart { width: 100%; flex: 1; min-height: 0; }
        .side-card { background: white; border-radius: 20px; padding: 24px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); display: flex; flex-direction: column; height: 100%; min-height: 0; overflow: hidden; }
        .table-header { font-size: 1.125rem; font-weight: 800; color: var(--gray-900); margin-bottom: 16px; padding-bottom: 16px; border-bottom: 2px solid var(--gray-100); flex-shrink: 0; }
        .sector-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; flex-shrink: 0; }
        .sector-tag { display: inline-flex; align-items: center; padding: 4px 10px; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: var(--gray-50); border: 1px solid var(--gray-200); color: var(--gray-600); }
        .sector-tag.top10-weight { background: rgba(59, 130, 246, 0.08); border-color: rgba(59, 130, 246, 0.22); color: var(--primary-dark); }
        .sector-tag.positive { background: #fef2f2; border-color: #fee2e2; color: #dc2626; }
        .sector-tag.negative { background: #ecfdf5; border-color: #d1fae5; color: #059669; }

        .prebuy-tag { position: relative; display: inline-flex; align-items: center; padding: 2px 6px; margin-left: 6px; border-radius: 4px; font-size: 0.6875rem; font-weight: 600; line-height: 1; background: rgba(59, 130, 246, 0.10); border: 1px solid rgba(59, 130, 246, 0.22); color: var(--primary-dark); cursor: default; user-select: none; }
        .prebuy-tag::before,
        .prebuy-tag::after { opacity: 0; visibility: hidden; pointer-events: none; transform: translate(-50%, -6px); transition: opacity 0.16s ease, transform 0.16s ease, visibility 0.16s ease; }
        .prebuy-tag::after { content: attr(data-tooltip); position: absolute; left: 50%; bottom: calc(100% + 12px); width: max-content; max-width: min(360px, 70vw); white-space: normal; overflow-wrap: anywhere; word-break: break-word; padding: 10px 12px; border-radius: 12px; font-size: 0.8rem; font-weight: 600; line-height: 1.35; color: rgba(255,255,255,0.95); background: rgba(17,24,39,0.92); box-shadow: 0 12px 34px rgba(0,0,0,0.18); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 30; }
        .prebuy-tag::before { content: ''; position: absolute; left: 50%; bottom: calc(100% + 6px); width: 12px; height: 12px; background: rgba(17,24,39,0.92); transform: translate(-50%, -6px) rotate(45deg); border-radius: 3px; box-shadow: 0 8px 18px rgba(0,0,0,0.12); z-index: 29; }
        .prebuy-tag:hover::before,
        .prebuy-tag:hover::after,
        .prebuy-tag:focus-visible::before,
        .prebuy-tag:focus-visible::after { opacity: 1; visibility: visible; transform: translate(-50%, 0); }
        .side-scroll { flex: 1; overflow-y: auto; padding-right: 4px; }
        .side-scroll::-webkit-scrollbar { width: 4px; }
        .side-scroll::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 10px; }
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        .side-scroll thead th { position: sticky; top: 0; background: white; z-index: 10; padding: 10px 8px; text-align: left; font-size: 0.75rem; font-weight: 700; color: var(--gray-500); border-bottom: 1px solid var(--gray-200); }
        .data-table-container thead th { padding: 10px 8px; text-align: left; font-size: 0.75rem; font-weight: 700; color: var(--gray-500); border-bottom: 1px solid var(--gray-200); }
        tbody td { padding: 10px 8px; border-bottom: 1px solid var(--gray-50); font-size: 0.875rem; color: var(--gray-800); }
        .side-scroll tbody tr { cursor: pointer; transition: background 0.15s; }
        .side-scroll tbody tr:hover { background: var(--gray-50); }
        .side-scroll tbody tr:hover td:first-child { color: var(--primary); text-decoration: underline; text-underline-offset: 3px; }
        .history-scroll { max-height: 360px; overflow-y: auto; }
        .data-table-container { background: white; border-radius: 20px; padding: 24px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06); border: 2px solid var(--gray-100); }
        .toast-container { position: fixed; top: 24px; right: 24px; display: flex; flex-direction: column; gap: 12px; z-index: 10000; pointer-events: none; }
        .toast { padding: 16px 24px; border-radius: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15); animation: slideIn 0.3s ease-out; background: white; border: 2px solid var(--gray-200); pointer-events: auto; }
        .toast.success { border-color: #10b981; background: #ecfdf5; }
        .toast.error { border-color: #ef4444; background: #fef2f2; }
        .toast .toast-row { display: flex; align-items: flex-start; gap: 12px; }
        .toast .toast-msg { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; line-height: 1.35; }
        .toast .toast-close { margin-left: auto; border: none; background: transparent; cursor: pointer; font-size: 1rem; line-height: 1; color: var(--gray-700); padding: 0 2px; }
        .toast .toast-close:hover { color: var(--gray-900); }
        @keyframes slideIn { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .empty-state { text-align: center; padding: 60px 32px; color: var(--gray-500); }
        .empty-icon { font-size: 4rem; margin-bottom: 16px; opacity: 0.5; }
        .empty-text { font-size: 1.125rem; font-weight: 600; color: var(--gray-700); margin-bottom: 8px; }
        .empty-subtext { font-size: 0.9375rem; }
        
        /* æ•°æ®æºçŠ¶æ€æŒ‡ç¤ºå™¨ */
        .source-indicator { position: fixed; bottom: 20px; left: 20px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 12px 16px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 1px solid var(--gray-200); font-size: 0.8125rem; z-index: 100; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: all 0.3s; }
        .source-indicator:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .source-indicator .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #10b981; animation: pulse 2s infinite; }
        .source-indicator .status-text { font-weight: 600; color: var(--gray-700); }
        .source-indicator .source-name { font-family: 'JetBrains Mono', monospace; color: var(--gray-500); font-size: 0.75rem; }
        
        /* æ•°æ®æºç»Ÿè®¡å¼¹çª— */
        .source-stats-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10001; display: none; align-items: center; justify-content: center; }
        .source-stats-modal.active { display: flex; }
        .source-stats-content { background: white; border-radius: 20px; padding: 32px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .source-stats-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 2px solid var(--gray-100); }
        .source-stats-title { font-size: 1.25rem; font-weight: 800; }
        .source-stats-close { width: 32px; height: 32px; border: none; background: var(--gray-100); border-radius: 8px; cursor: pointer; font-size: 1.25rem; }
        .source-stats-table { width: 100%; }
        .source-stats-table th { text-align: left; padding: 10px; background: var(--gray-50); font-size: 0.75rem; font-weight: 700; color: var(--gray-600); }
        .source-stats-table td { padding: 12px 10px; border-bottom: 1px solid var(--gray-100); font-size: 0.875rem; }
        .source-stats-table .success-rate { font-weight: 700; }
        .source-stats-table .success-rate.high { color: #10b981; }
        .source-stats-table .success-rate.medium { color: #f59e0b; }
        .source-stats-table .success-rate.low { color: #ef4444; }

        .swipe-hint { position: fixed; left: 12px; right: 12px; top: 50%; transform: translateY(-50%); display: none; align-items: center; justify-content: space-between; pointer-events: none; z-index: 2000; }
        .swipe-hint.show { display: flex; }
        .swipe-hint .arrow { width: 40px; height: 40px; border-radius: 999px; display: flex; align-items: center; justify-content: center; font-size: 26px; font-weight: 900; color: rgba(255,255,255,0.95); background: rgba(17,24,39,0.35); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); animation: swipeHintPulse 1.4s ease-in-out infinite; }
        .swipe-hint .text { flex: 1; text-align: center; margin: 0 10px; color: rgba(255,255,255,0.92); font-weight: 700; font-size: 0.95rem; text-shadow: 0 2px 10px rgba(0,0,0,0.35); }
        @keyframes swipeHintPulse { 0%,100% { transform: scale(1); opacity: 0.85; } 50% { transform: scale(1.08); opacity: 1; } }

        @media (hover: hover) and (pointer: fine) {
            .swipe-hint, .swipe-hint.show { display: none !important; }
        }
        
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 1200px) { 
            .chart-row { height: auto; flex-direction: column; } 
            .chart-container { height: 400px; margin-bottom: 24px; } 
            .chart-side { min-width: 100%; }
            .side-card { height: 400px; } 
            .stats-grid { grid-template-columns: repeat(2, 1fr); } 
        }
        
        @media (max-width: 768px) { 
            .mobile-menu-btn { display: flex; }
            .sidebar { 
                width: 100%; 
                max-width: 380px;
                position: fixed; 
                z-index: 1000; 
                height: 100vh;
                transform: translateX(-100%); 
                transition: transform 0.3s; 
            }
            .sidebar.open { transform: translateX(0); }
            .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999; }
            .sidebar-overlay.active { display: block; }
            .main-content { margin-left: 0; touch-action: pan-y; }
            .main-header { padding: 80px 16px 16px; }
            .fund-title-main { font-size: 1.25rem; }
            .stats-grid { grid-template-columns: 1fr; gap: 12px; }
            .stat-card { padding: 16px; }
            .stat-value { font-size: 1.5rem; }
            .chart-section { padding: 16px; }
            .chart-container { padding: 16px; }
            .side-card { padding: 16px; }
            .fund-meta { gap: 8px; }
            .chart-header { flex-direction: column; align-items: flex-start; gap: 12px; }
            .time-tabs { width: 100%; justify-content: space-between; }
            .time-tab { padding: 8px 12px; font-size: 0.8125rem; }
            .input-row { grid-template-columns: 1fr; }
            .btn-add { width: 100%; }
            .source-indicator { display: none; } /* ç§»åŠ¨ç«¯éšè—æ•°æ®æºæŒ‡ç¤ºå™¨ */
            .market-indices { padding: 0; }
            .indices-toggle { padding: 12px 16px; }
            .indices-inner { padding: 16px; }
            /* ç§»åŠ¨ç«¯æ¢å¤1åˆ— */
            .indices-grid { grid-template-columns: 1fr; gap: 8px; }
            .index-card { padding: 10px 12px; min-height: auto; }
            .index-card.selected { grid-column: span 1; }
            .index-value { font-size: 1rem; }
        }
        
        @media (max-width: 480px) {
            .optional-inputs { grid-template-columns: 1fr; }
            .fund-code-large, .market-status, .update-time { font-size: 0.75rem; padding: 4px 10px; }
        }
    </style>
</head>
<body>
    <button class="mobile-menu-btn" id="mobileMenuBtn">
        <span></span>
        <span></span>
        <span></span>
    </button>
    
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="source-indicator" id="sourceIndicator">
        <div class="status-dot"></div>
        <div class="status-text">æ•°æ®æºè¿è¡Œä¸­</div>
        <div class="source-name" id="currentSourceName">fundgz_jsonp</div>
    </div>
    
    <div class="source-stats-modal" id="sourceStatsModal">
        <div class="source-stats-content">
            <div class="source-stats-header">
                <h3 class="source-stats-title">ğŸ“Š æ•°æ®æºç»Ÿè®¡</h3>
                <button class="source-stats-close" onclick="closeSourceStats()">Ã—</button>
            </div>
            <table class="source-stats-table">
                <thead>
                    <tr>
                        <th>æ•°æ®æº</th>
                        <th>æˆåŠŸ</th>
                        <th>å¤±è´¥</th>
                        <th>æˆåŠŸç‡</th>
                        <th>å¹³å‡è€—æ—¶</th>
                    </tr>
                </thead>
                <tbody id="sourceStatsTableBody">
                    <tr><td colspan="5" style="text-align: center; padding: 20px; color: var(--gray-500);">æš‚æ— æ•°æ®</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- æŒä»“ç¼–è¾‘å¯¹è¯æ¡† -->
    <div class="pos-modal-overlay" id="posModalOverlay" onclick="posModalBgClick(event)">
        <div class="pos-modal">
            <div class="pos-modal-header">
                <div class="pos-modal-title" id="posModalTitle">ç¼–è¾‘æŒä»“</div>
                <button class="pos-modal-close" onclick="closePosModal()">Ã—</button>
            </div>
            <div class="pos-modal-body">
                <div class="pos-field">
                    <label>åŸºé‡‘ä»£ç </label>
                    <input type="text" id="posCode" disabled>
                </div>
                <div class="pos-field">
                    <label>ä¹°å…¥é‡‘é¢</label>
                    <input type="number" id="posAmount" placeholder="å¦‚ 10000" step="0.01">
                </div>
                <div class="pos-field">
                    <label>ä¹°å…¥æ—¶é—´</label>
                    <input type="date" id="posBuyDate">
                </div>
                <div class="pos-quick-label">å¿«é€Ÿæ“ä½œ</div>
                <div class="pos-quick-row">
                    <button class="pos-quick-btn danger" onclick="posQuickAction('clear')">æ¸…ä»“</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('half')">1/2</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('third')">1/3</button>
                    <button class="pos-quick-btn" onclick="posQuickAction('quarter')">1/4</button>
                    <button class="pos-quick-btn success" onclick="posQuickAction('double')">2Ã—</button>
                </div>
            </div>
            <div class="pos-modal-footer">
                <button class="pos-btn-cancel" onclick="closePosModal()">å–æ¶ˆ</button>
                <button class="pos-btn-save" onclick="savePosModal()">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="logo-card">
                    <div class="logo-content">
                        <div class="logo-icon">ğŸ“ˆ</div>
                        <div class="logo">FundFlow</div>
                        <div class="logo-subtitle"><span class="status-indicator"></span><span>å®æ—¶ç›‘æ§ç³»ç»Ÿ</span></div>
                        <div class="logo-summary">
                            <div class="line"><span class="label">æŒä»“é‡‘é¢</span><span id="allPositionAmount">--</span></div>
                            <div class="line"><span class="label">æŒä»“æ”¶ç›Š</span><span id="allPositionProfit">--</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="market-indices">
                <button class="indices-toggle" onclick="toggleIndices()">
                    <div class="indices-toggle-left">
                        <div class="indices-title">
                            <span>ğŸ“Š</span>
                            <span>å¸‚åœºæŒ‡æ•°</span>
                        </div>
                    </div>
                    <span class="indices-arrow" id="indicesArrow">â–¼</span>
                </button>
                
                <div class="indices-content" id="indicesContent">
                    <div class="indices-inner">
                        <div class="indices-grid" id="indicesGrid">
                            </div>
                        <button class="indices-refresh" onclick="fetchMarketIndices()">ğŸ”„ åˆ·æ–°æŒ‡æ•°</button>
                    </div>
                </div>
            </div>
            
            <div class="add-fund-section" style="padding:0; border-bottom:none;">
                <button class="add-fund-toggle" onclick="toggleAddFund()">
                    <div class="add-fund-toggle-left">
                        <span>ï¼‹</span>
                        <span class="add-fund-toggle-title">æ·»åŠ åŸºé‡‘</span>
                    </div>
                    <span class="add-fund-arrow" id="addFundArrow">â–¼</span>
                </button>
                <div class="add-fund-body" id="addFundBody">
                    <div class="add-fund-inner">
                        <div class="input-row">
                            <input type="text" id="fundCode" class="input-field" placeholder="è¾“å…¥åŸºé‡‘ä»£ç ">
                            <button onclick="addFund()" class="btn-add">æ·»åŠ </button>
                        </div>
                        <div class="fund-suggest" id="fundSuggest"></div>
                        <div class="optional-inputs">
                            <input type="number" id="buyAmount" class="input-field input-small" placeholder="ä¹°å…¥é‡‘é¢(å¯é€‰)">
                            <input type="date" id="buyDate" class="input-field input-small" placeholder="ä¹°å…¥æ—¶é—´(å¯é€‰)">
                        </div>
                        <div class="helper-text"><span>ğŸ’¡</span><span>è¾“å…¥æŒä»“ä¿¡æ¯å¯æŸ¥çœ‹æ”¶ç›Šè¯¦æƒ…</span></div>
                    </div>
                </div>
            </div>
            <div class="fund-list" id="fundList"></div>
        </aside>

        <main class="main-content">
            <div class="swipe-hint" id="swipeHint" aria-hidden="true">
                <div class="arrow left">â€¹</div>
                <div class="text">å·¦å³æ»‘åŠ¨åˆ‡æ¢åŸºé‡‘</div>
                <div class="arrow right">â€º</div>
            </div>
            <div class="main-header">
                <div class="header-top">
                    <div class="fund-title-section">
                        <h1 class="fund-title-main" id="selectedFundName">é€‰æ‹©ä¸€ä¸ªåŸºé‡‘å¼€å§‹ç›‘æ§</h1>
                        <div class="fund-meta">
                            <span class="fund-code-large" id="selectedFundCode">--</span>
                            <div class="market-status closed" id="marketStatus"><span>â¸</span><span id="marketStatusText">ä¼‘å¸‚ä¸­</span></div>
                            <div class="update-time" id="updateTime">--</div>
                            <div class="remind-chip" id="remindChip" onclick="openReminderPrompt(event)">æé†’</div>
                            <div class="remind-fired-hint" id="remindFiredHint" onclick="jumpToLastFiredReminder(event)"></div>
                        </div>
                    </div>
                    <button class="header-collapse-btn" id="headerCollapseBtn" onclick="toggleHeaderStats()" title="æŠ˜å /å±•å¼€">â–¼</button>
                </div>
                <div class="stats-grid-wrapper" id="statsGridWrapper">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">å½“å‰å‡€å€¼ <span id="navDateLabel" style="background:var(--gray-100); padding:2px 6px; border-radius:4px; font-weight:500; font-size:0.65rem;">--</span></div>
                            <div class="stat-value" id="currentNav">--</div>
                            <div class="stat-change" id="navChange">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label"><span id="estLabel">ä¼°ç®—å‡€å€¼</span></div>
                            <div class="stat-value" id="estimatedNav">--</div>
                            <div class="stat-change" id="estimatedChange">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">æ—¥æ¶¨è·Œå¹…</div>
                            <div class="stat-value" id="dayGrowth">--</div>
                            <div class="stat-change" id="dayGrowthChange">--<span class="day-growth-source official" id="dayGrowthSource"></span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">æŒä»“æ”¶ç›Š</div>
                            <div class="stat-value" id="totalProfit">--</div>
                            <div class="stat-change" id="profitPercent">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <div class="chart-header">
                    <h2 class="chart-title" id="chartTypeLabel">å‡€å€¼èµ°åŠ¿å›¾</h2>
                    <div class="time-tabs">
                        <button class="time-tab active" onclick="changeTimeRange('realtime')">å®æ—¶</button>
                        <button class="time-tab" onclick="changeTimeRange('5d')">1å‘¨</button>
                        <button class="time-tab" onclick="changeTimeRange('1m')">1æœˆ</button>
                        <button class="time-tab" onclick="changeTimeRange('3m')">3æœˆ</button>
                        <button class="time-tab" onclick="changeTimeRange('1y')">1å¹´</button>
                        <button class="time-tab" onclick="changeTimeRange('all')">æˆç«‹æ¥</button>
                    </div>
                </div>
                <div class="chart-row">
                    <div class="chart-main">
                        <div class="chart-container"><div id="klineChart"></div></div>
                    </div>
                    <div class="chart-side">
                        <div class="side-card">
                            <div class="table-header">åŸºé‡‘æŒä»“ï¼ˆTOP 10ï¼‰</div>
                            <div id="sectorTags" class="sector-tags"><span style="font-size: 0.8125rem; color: var(--gray-500);">æš‚æ— æ•°æ®</span></div>
                            <div class="side-scroll">
                                <table>
                                    <thead><tr><th>è‚¡ç¥¨</th><th>ä»£ç </th><th>å æ¯”</th><th>æ¶¨è·Œå¹…</th></tr></thead>
                                    <tbody id="holdingsTableBody"><tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">è¯·é€‰æ‹©åŸºé‡‘</td></tr></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="data-table-container">
                    <div class="table-header">å†å²å‡€å€¼æ•°æ®</div>
                    <div class="history-scroll" id="historyScroll">
                        <table>
                            <thead><tr><th>æ—¥æœŸ</th><th>å•ä½å‡€å€¼</th><th>æ—¥å¢é•¿ç‡</th><th>æ—¥å‡€æ”¶ç›Š</th></tr></thead>
                            <tbody id="historyTableBody"><tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">æš‚æ— æ•°æ®</td></tr></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let funds = JSON.parse(localStorage.getItem('funds') || '[]');
        let selectedFund = null;
        let holdingsCache = {}; // { [fundCode]: { holdings: [{code, ratio, chg}], top10Weight, top10Contribution, estDayChg, timestamp } }
        let chart = null;
        let miniCharts = {};
        let updateInterval = null;
        let realtimeInterval = null;
        let currentTimeRange = 'realtime';
        let historyCache = {}; // { [fundCode]: [{x, y}, ...] } ç¼“å­˜ pingzhongdata å…¨éƒ¨å†å²
        let historyTableState = { code: null, rendered: 0, pageSize: 10 };
        let fundgzQueue = Promise.resolve();
        let marketIndices = {};
        let selectedIndexKey = null;
        let indexCharts = {};
        let indexTrendCache = {}; // { [indexKey]: { times: [], prices: [], preClose: number, updatedAt: number } }
        let refreshInterval = null;
        let refreshLock = Promise.resolve();
        let lastFundRefreshAt = 0;
        let lastIndicesRefreshAt = 0;
        let lastHoldingsRefreshAt = 0;
        let refreshTick = 0;
        let fundRefreshCursor = 0;

        // æ·»åŠ åŸºé‡‘åŒºåŸŸæŠ˜å 
        function toggleAddFund() {
            const body = document.getElementById('addFundBody');
            const arrow = document.getElementById('addFundArrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        // ============================================================
        // æŒä»“ç¼–è¾‘å¯¹è¯æ¡†
        // ============================================================
        let _posEditCode = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„åŸºé‡‘ä»£ç 

        function openPosModal(code) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            _posEditCode = code;
            document.getElementById('posModalTitle').textContent = `ç¼–è¾‘æŒä»“ â€” ${fund.name || code}`;
            document.getElementById('posCode').value = code;
            document.getElementById('posAmount').value = fund.buyAmount != null ? fund.buyAmount : (fund.holdingCost != null && fund.holdingShares != null ? (fund.holdingCost * fund.holdingShares) : '');
            document.getElementById('posBuyDate').value = fund.buyDate != null ? fund.buyDate : '';
            document.getElementById('posModalOverlay').classList.add('active');
            // çŸ­å»¶è¿Ÿå focus é‡‘é¢è¾“å…¥æ¡†
            setTimeout(() => document.getElementById('posAmount').focus(), 120);
        }

        function closePosModal() {
            document.getElementById('posModalOverlay').classList.remove('active');
            _posEditCode = null;
        }

        function posModalBgClick(e) {
            if (e.target === document.getElementById('posModalOverlay')) closePosModal();
        }

        function savePosModal() {
            if (!_posEditCode) return;
            const fund = funds.find(f => f.code === _posEditCode);
            if (!fund) return;
            const amountVal = document.getElementById('posAmount').value.trim();
            const buyDateVal = (document.getElementById('posBuyDate').value || '').trim();
            fund.buyAmount = amountVal !== '' ? parseFloat(amountVal) : null;
            fund.buyDate = buyDateVal !== '' ? buyDateVal : null;
            if (fund.buyAmount !== null && isNaN(fund.buyAmount)) fund.buyAmount = null;
            if (fund.buyAmount !== null && fund.buyAmount <= 0) fund.buyAmount = null;
            // æ—§å­—æ®µä¿ç•™ä½†ä¸å†ç»´æŠ¤
            saveFunds();
            closePosModal();
            renderFundList();
            if (historyTableState?.code === fund.code) resetHistoryTable(fund.code);
            if (selectedFund?.code === _posEditCode || selectedFund?.code === fund.code) updateMainDisplay(fund);
            showToast('æŒä»“ä¿¡æ¯å·²æ›´æ–°');
        }

        function posQuickAction(action) {
            const amountInput = document.getElementById('posAmount');
            const current = parseFloat(amountInput.value) || 0;
            switch (action) {
                case 'clear':
                    amountInput.value = '0';
                    break;
                case 'half':
                    amountInput.value = (current / 2).toFixed(2);
                    break;
                case 'third':
                    amountInput.value = (current / 3).toFixed(2);
                    break;
                case 'quarter':
                    amountInput.value = (current / 4).toFixed(2);
                    break;
                case 'double':
                    amountInput.value = (current * 2).toFixed(2);
                    break;
            }
            amountInput.dispatchEvent(new Event('input'));
        }

        // ä¸»é¡µæ ‡é¢˜æ  stats æŠ˜å /å±•å¼€
        function toggleHeaderStats() {
            const wrapper = document.getElementById('statsGridWrapper');
            const btn = document.getElementById('headerCollapseBtn');
            if (!wrapper) return;
            wrapper.classList.toggle('collapsed');
            if (btn) btn.textContent = wrapper.classList.contains('collapsed') ? 'â–²' : 'â–¼';
        }

        // æŠ˜å /å±•å¼€å¸‚åœºæŒ‡æ•°
        function toggleIndices() {
            const content = document.getElementById('indicesContent');
            const arrow = document.getElementById('indicesArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
            if (content.classList.contains('open') && Object.keys(marketIndices).length === 0) {
                fetchMarketIndices();
            }
        }

        // å¸‚åœºæŒ‡æ•°é…ç½®
        const MARKET_INDICES = {
            sh000001: { name: 'ä¸Šè¯æŒ‡æ•°', flag: 'ğŸ‡¨ğŸ‡³', secid: '1.000001', type: 'cn' },
            sz399001: { name: 'æ·±è¯æˆæŒ‡', flag: 'ğŸ‡¨ğŸ‡³', secid: '0.399001', type: 'cn' },
            sz399006: { name: 'åˆ›ä¸šæ¿æŒ‡', flag: 'ğŸ‡¨ğŸ‡³', secid: '0.399006', type: 'cn' },
            us_dji: { name: 'é“ç¼æ–¯', flag: 'ğŸ‡ºğŸ‡¸', secid: '100.DJIA', type: 'us' },
            us_ixic: { name: 'çº³æ–¯è¾¾å…‹', flag: 'ğŸ‡ºğŸ‡¸', secid: '100.NDX', type: 'us' },
            us_spx: { name: 'æ ‡æ™®500', flag: 'ğŸ‡ºğŸ‡¸', secid: '100.SPX', type: 'us' }
        };

        async function fetchMarketIndices() {
            const grid = document.getElementById('indicesGrid');
            if (!grid) return;

            const nowTs = Date.now();
            const trendTasks = [];
            for (const [k, cfg] of Object.entries(MARKET_INDICES)) {
                if (cfg.type !== 'cn') continue;
                const cached = indexTrendCache[k];
                const fresh = cached && (nowTs - (cached.updatedAt || 0) < 20000);
                if (!fresh) trendTasks.push(fetchIndexTrendSnapshot(k, cfg));
            }
            if (trendTasks.length > 0) {
                await Promise.allSettled(trendTasks);
            }

            const indexSources = [
                {
                    name: 'eastmoney_api',
                    fetch: async (secid) => {
                        const url = `https://push2.eastmoney.com/api/qt/stock/get?secid=${secid}&fields=f43,f3,f169,f170,f60,f86&_=${Date.now()}`;
                        return await runWithSourceStat('index_stock_get_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                    }
                }
            ];

            const indexCards = [];
            
            for (const [key, config] of Object.entries(MARKET_INDICES)) {
                let data = null;
                
                for (const source of indexSources) {
                    try {
                        const result = await Promise.race([
                            source.fetch(config.secid),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 8000))
                        ]);
                        if (result?.data) { data = result.data; break; }
                    } catch (error) {
                        console.warn(`[æŒ‡æ•°-${config.name}-${source.name}] å¤±è´¥:`, error.message);
                        continue;
                    }
                }

                if (data) {
                    const price = (data.f43 !== undefined && data.f43 !== null && data.f43 !== '-') ? data.f43 : data.f60;
                    const priceNum = Number(price);
                    const isCn = config.type === 'cn';
                    let isClosed = false;
                    if (isCn) {
                        const s = getMarketStatus();
                        isClosed = !s.isOpen;
                    } else {
                        if (config.type === 'us') {
                            isClosed = !isUsMarketOpenNow();
                        } else {
                            const today = new Date();
                            const day = today.getDay();
                            if (day === 0 || day === 6) isClosed = true;
                        }
                    }

                    let changePct = 0;
                    const f3Num = (data.f3 !== undefined && data.f3 !== null && data.f3 !== '-') ? parseFloat(data.f3) : NaN;
                    const f170Num = (data.f170 !== undefined && data.f170 !== null && data.f170 !== '-') ? Number(data.f170) : NaN;
                    const closeRawNum = Number(data.f43);
                    const preCloseRawNum = Number(data.f60);
                    const closeForPctNum = Number.isFinite(closeRawNum) ? closeRawNum : priceNum;
                    // Aè‚¡åœ¨ä¼‘å¸‚æ—¶ï¼šç”¨æœ€è¿‘æ”¶ç›˜å£å¾„ï¼ˆæ”¶ç›˜ä»· vs æ˜¨æ”¶ï¼‰
                    if (isCn && isClosed) {
                        if (Number.isFinite(closeForPctNum) && Number.isFinite(preCloseRawNum) && preCloseRawNum !== 0) {
                            changePct = (closeForPctNum - preCloseRawNum) / preCloseRawNum * 100;
                        } else if (Number.isFinite(f170Num) && Number.isFinite(priceNum)) {
                            const preClose = priceNum - f170Num;
                            if (preClose) changePct = (f170Num / preClose) * 100;
                        } else if (Number.isFinite(f3Num)) {
                            changePct = f3Num;
                        }
                    } else {
                        // äº¤æ˜“ä¸­ï¼ˆæˆ–éAè‚¡æŒ‡æ•°ï¼‰ï¼šä¼˜å…ˆç”¨æ¥å£å®æ—¶æ¶¨è·Œå¹…
                        if (Number.isFinite(f3Num)) {
                            changePct = f3Num;
                        } else if (Number.isFinite(f170Num) && Number.isFinite(priceNum)) {
                            const preClose = priceNum - f170Num;
                            if (preClose) changePct = (f170Num / preClose) * 100;
                        }
                    }

                    // å…œåº•ï¼šéƒ¨åˆ†æŒ‡æ•°åœ¨äº¤æ˜“ä¸­ f3/f170 å¯èƒ½ç¼ºå¤±æˆ–è¿”å› 0ï¼Œä½† f43/f60 æ˜¯å¯é çš„ï¼ˆç°ä»·/æ˜¨æ”¶ï¼‰
                    if ((!Number.isFinite(changePct) || Math.abs(changePct) < 1e-9) && Number.isFinite(closeForPctNum) && Number.isFinite(preCloseRawNum) && preCloseRawNum !== 0) {
                        changePct = (closeForPctNum - preCloseRawNum) / preCloseRawNum * 100;
                    }
                    const updateTime = data.f86 || '--';
                    const isPositive = changePct >= 0;
                    let finalPrice = price > 10000 && config.type === 'cn' ? (price/100).toFixed(2) : (price/100).toFixed(2);
                    let formattedChange = (changePct !== undefined) ? (isPositive ? '+' : '') + parseFloat(changePct).toFixed(2) + '%' : '--';
                    
                    let timeStr = '--';
                    if (updateTime && updateTime !== '--') {
                        const d = new Date(updateTime * 1000);
                        timeStr = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                    }

                    // å¦‚æœè¯¥æŒ‡æ•°å·²ç»å±•å¼€è¿‡å¹¶æ‹‰å–äº† trends2/getï¼Œåˆ™ç”¨èµ°åŠ¿ç¼“å­˜è¦†ç›–å¡ç‰‡ä»·æ ¼ä¸æ¶¨è·Œå¹…ï¼Œç¡®ä¿ä¸å›¾å¯¹é½
                    {
                        const cached = indexTrendCache[key];
                        const fresh = cached && (nowTs - (cached.updatedAt || 0) < 2 * 60 * 1000);
                        const lastPrice = fresh ? cached.prices?.[cached.prices.length - 1] : NaN;
                        const preClose = fresh ? cached.preClose : NaN;
                        const pct = (fresh && Number.isFinite(lastPrice) && Number.isFinite(preClose) && preClose !== 0) ? ((lastPrice - preClose) / preClose * 100) : NaN;
                        if (fresh && Number.isFinite(lastPrice)) {
                            finalPrice = lastPrice.toFixed(2);
                            if (Number.isFinite(pct)) {
                                changePct = pct;
                                formattedChange = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                            }
                            if (Array.isArray(cached.times) && cached.times.length > 0) timeStr = cached.times[cached.times.length - 1] || timeStr;
                        }
                    }
                    
                    marketIndices[key] = { price: finalPrice, change: changePct, changePct: formattedChange, time: timeStr, secid: config.secid, name: config.name };
                    
                    indexCards.push(`
                        <div class="index-card ${isPositive ? 'positive' : 'negative'} ${selectedIndexKey === key ? 'selected' : ''} ${isClosed ? 'closed' : ''}" 
                             onclick="selectIndex('${key}')" id="indexCard_${key}">
                            <div class="index-header">
                                <div class="index-name"><span class="index-flag">${config.flag}</span>${config.name}</div>
                                <span class="index-status-badge">${isClosed ? 'ä¼‘å¸‚' : 'äº¤æ˜“ä¸­'}</span>
                            </div>
                            <div class="index-body">
                                <div class="index-value">${finalPrice}</div>
                                <div class="index-change">${formattedChange}</div>
                            </div>
                            <div class="index-chart-container" id="chartContainer_${key}" style="display: none;">
                                <div class="index-mini-chart" id="indexChart_${key}"></div>
                            </div>
                        </div>
                    `);
                } else {
                    indexCards.push(`
                        <div class="index-card">
                            <div class="index-header"><div class="index-name"><span class="index-flag">${config.flag}</span>${config.name}</div></div>
                            <div class="index-body"><div class="index-value">---</div><div class="index-change">åŠ è½½å¤±è´¥</div></div>
                        </div>
                    `);
                }
            }
            grid.innerHTML = indexCards.join('');

            // è‹¥å½“å‰æœ‰é€‰ä¸­çš„æŒ‡æ•°å¡ç‰‡ï¼ˆå±•å¼€ä¸­ï¼‰ï¼Œåˆ·æ–° DOM åéœ€è¦æ¢å¤å±•å¼€çŠ¶æ€å¹¶é‡ç»˜å›¾è¡¨
            if (selectedIndexKey) {
                const card = document.getElementById(`indexCard_${selectedIndexKey}`);
                const container = document.getElementById(`chartContainer_${selectedIndexKey}`);
                if (card) card.classList.add('selected');
                if (container) container.style.display = 'block';

                // DOM è¢«é‡å»ºåï¼Œæ—§ echarts å®ä¾‹å·²ç»‘å®šæ—§ DOMï¼Œéœ€è¦é‡Šæ”¾å¹¶åœ¨æ–° DOM ä¸Šé‡ç»˜
                if (indexCharts[selectedIndexKey]) {
                    try { indexCharts[selectedIndexKey].dispose(); } catch {}
                    delete indexCharts[selectedIndexKey];
                }

                const cached = indexTrendCache[selectedIndexKey];
                const fresh = cached && (Date.now() - (cached.updatedAt || 0) < 5 * 60 * 1000);
                if (fresh) {
                    drawIndexMiniChart(selectedIndexKey, cached);
                } else {
                    // ç¼“å­˜ä¸å­˜åœ¨æˆ–è¿‡æœŸï¼šé‡æ–°æ‹‰å–ä¸€æ¬¡ï¼ˆåªå¯¹å½“å‰å±•å¼€çš„æŒ‡æ•°æ‰§è¡Œï¼‰
                    fetchAndDrawIndexKline(selectedIndexKey);
                }
            }
        }
        
        async function selectIndex(key) {
            if (selectedIndexKey) {
                const prevCard = document.getElementById(`indexCard_${selectedIndexKey}`);
                const prevContainer = document.getElementById(`chartContainer_${selectedIndexKey}`);
                if (prevCard) prevCard.classList.remove('selected');
                if (prevContainer) prevContainer.style.display = 'none';
            }
            if (selectedIndexKey === key) { selectedIndexKey = null; return; }
            
            selectedIndexKey = key;
            const card = document.getElementById(`indexCard_${key}`);
            const container = document.getElementById(`chartContainer_${key}`);
            
            if (card) card.classList.add('selected');
            if (container) {
                container.style.display = 'block';
                if (indexCharts[key]) indexCharts[key].dispose();
                await fetchAndDrawIndexKline(key);
            }
        }
        
        function parseTrendTime(str) {
            if (!str) return '';
            let match = str.match(/(\d{2}):(\d{2})/);
            if (match) return `${match[1]}:${match[2]}`;
            if (str.length >= 12 && !isNaN(str)) return str.substring(8, 10) + ':' + str.substring(10, 12);
            return str;
        }

        function isAshareTradingTimeLabel(hhmm) {
            const m = (hhmm || '').match(/^(\d{2}):(\d{2})$/);
            if (!m) return true;
            const min = parseInt(m[1], 10) * 60 + parseInt(m[2], 10);
            return (min >= 570 && min <= 690) || (min >= 780 && min <= 900);
        }

        async function fetchIndexTrendSnapshot(key, config) {
            try {
                const url = `https://push2.eastmoney.com/api/qt/stock/trends2/get?secid=${config.secid}&fields1=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13&fields2=f51,f53&_=${Date.now()}`;
                const result = await runWithSourceStat('index_trends2_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                const d = result?.data;
                const trends = d?.trends;
                const preClose = Number(d?.preClose);
                if (!Array.isArray(trends) || trends.length === 0 || !Number.isFinite(preClose)) return;
                const times = [];
                const prices = [];
                for (const item of trends) {
                    const parts = String(item).split(',');
                    const t = parseTrendTime(parts[0]);
                    if (config.type === 'cn' && !isAshareTradingTimeLabel(t)) continue;
                    const p = parseFloat(parts[1]);
                    if (!Number.isFinite(p)) continue;
                    times.push(t);
                    prices.push(p);
                }
                if (times.length === 0 || prices.length === 0) return;
                indexTrendCache[key] = { times, prices, preClose, updatedAt: Date.now() };
            } catch {
            }
        }

        function drawIndexMiniChart(key, cached) {
            const chartDom = document.getElementById(`indexChart_${key}`);
            if (!chartDom) return;
            const times = cached?.times || [];
            const prices = cached?.prices || [];
            const preClose = cached?.preClose;
            if (!Array.isArray(times) || !Array.isArray(prices) || times.length === 0 || prices.length === 0 || !Number.isFinite(preClose)) {
                chartDom.innerHTML = '<div style="text-align:center;color:var(--gray-500);padding:60px 0;font-size:0.75rem;">æš‚æ— æ•°æ®</div>';
                return;
            }

            // ç”¨èµ°åŠ¿æ•°æ®å›å¡«å¡ç‰‡æ˜¾ç¤ºï¼ˆä½¿å¡ç‰‡æ¶¨è·Œå¹…ä¸å›¾ä¸­æœ€æ–°ç‚¹å¯¹é½ï¼‰
            {
                const lastPrice = prices[prices.length - 1];
                const pct = (Number.isFinite(lastPrice) && Number.isFinite(preClose) && preClose !== 0) ? ((lastPrice - preClose) / preClose * 100) : NaN;
                const card = document.getElementById(`indexCard_${key}`);
                if (card && Number.isFinite(lastPrice)) {
                    const valueEl = card.querySelector('.index-value');
                    if (valueEl) valueEl.textContent = lastPrice.toFixed(2);
                    const changeEl = card.querySelector('.index-change');
                    if (changeEl && Number.isFinite(pct)) changeEl.textContent = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                }
                if (marketIndices[key]) {
                    if (Number.isFinite(lastPrice)) marketIndices[key].price = lastPrice.toFixed(2);
                    if (Number.isFinite(pct)) {
                        marketIndices[key].change = pct;
                        marketIndices[key].changePct = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
                    }
                    if (times.length > 0) marketIndices[key].time = times[times.length - 1] || marketIndices[key].time;
                }
            }

            const indexChart = echarts.init(chartDom);
            indexCharts[key] = indexChart;
            indexChart.setOption({
                grid: { left: 30, right: 22, top: 10, bottom: 28, containLabel: true },
                xAxis: {
                    type: 'category', data: times, boundaryGap: true,
                    axisLabel: {
                        fontSize: 9,
                        color: '#999',
                        margin: 8,
                        interval: (index) => {
                            const total = times.length;
                            if (total <= 6) return true;
                            const step = Math.max(1, Math.floor(total / 4));
                            if (index === 0 || index === total - 1) return true;
                            return index % step === 0;
                        },
                        showMinLabel: true,
                        showMaxLabel: true
                    },
                    axisLine: { lineStyle: { color: '#e5e5e5' } }, axisTick: { show: false }
                },
                yAxis: { type: 'value', scale: true, splitLine: { show: false }, axisLabel: { show: false }, axisLine: { show: false }, axisTick: { show: false } },
                series: [{
                    type: 'line', data: prices, smooth: true, symbol: 'none',
                    lineStyle: { width: 1.5, color: prices[prices.length - 1] >= preClose ? '#dc2626' : '#059669' },
                    areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: prices[prices.length - 1] >= preClose ? 'rgba(220, 38, 38, 0.1)' : 'rgba(5, 150, 105, 0.1)' }, { offset: 1, color: 'rgba(255, 255, 255, 0)' }]) }
                }],
                tooltip: {
                    trigger: 'axis', confine: true,
                    backgroundColor: 'rgba(255, 255, 255, 0.95)', borderColor: '#e5e5e5', textStyle: { fontSize: 10 },
                    formatter: (params) => {
                        const param = params[0];
                        const change = ((param.data - preClose) / preClose * 100).toFixed(2);
                        return `${param.name}<br/>${param.data.toFixed(2)} (${change >= 0 ? '+' : ''}${change}%)`;
                    }
                }
            });

            // æ–°å»ºåä¸»åŠ¨ resizeï¼Œé¿å…å®¹å™¨åˆšæ˜¾ç¤ºå‡ºæ¥æ—¶å°ºå¯¸ä¸º 0 å¯¼è‡´ç©ºç™½
            try { indexChart.resize(); } catch {}
        }

        async function fetchAndDrawIndexKline(key) {
            const config = MARKET_INDICES[key];
            if (!config) return;
            const chartDom = document.getElementById(`indexChart_${key}`);
            if (!chartDom) return;
            
            const klineSources = [
                {
                    name: 'eastmoney_trend',
                    fetch: async () => {
                        const url = `https://push2.eastmoney.com/api/qt/stock/trends2/get?secid=${config.secid}&fields1=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13&fields2=f51,f53&_=${Date.now()}`;
                        return await runWithSourceStat('index_trends2_jsonp', async () => await fetchJsonp(url, 'cb', 12000));
                    }
                }
            ];
            
            let trendData = null;
            for (const source of klineSources) {
                try {
                    const result = await source.fetch();
                    if (result?.data?.trends) { trendData = result.data; break; }
                } catch (error) {
                    console.warn(`[Kçº¿-${config.name}-${source.name}] å¤±è´¥:`, error.message);
                    continue;
                }
            }
            
            if (!trendData || !trendData.trends) {
                chartDom.innerHTML = '<div style="text-align:center;color:var(--gray-500);padding:60px 0;font-size:0.75rem;">æš‚æ— æ•°æ®</div>';
                return;
            }
            
            const times = [];
            const prices = [];
            const preClose = trendData.preClose;
            
            trendData.trends.forEach(item => {
                const parts = item.split(',');
                const t = parseTrendTime(parts[0]);
                if (config.type === 'cn' && !isAshareTradingTimeLabel(t)) return;
                const p = parseFloat(parts[1]);
                if (!Number.isFinite(p)) return;
                times.push(t);
                prices.push(p);
            });

            indexTrendCache[key] = { times, prices, preClose, updatedAt: Date.now() };
            drawIndexMiniChart(key, indexTrendCache[key]);
        }

        // ç§»åŠ¨ç«¯èœå•æ§åˆ¶
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        
        mobileMenuBtn?.addEventListener('click', () => { mobileMenuBtn.classList.toggle('active'); sidebar.classList.toggle('open'); sidebarOverlay.classList.toggle('active'); });
        sidebarOverlay?.addEventListener('click', () => { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); });

        // å¤šæ•°æ®æºé…ç½®
        function ensureSourceStat(name) {
            if (!name) return;
            if (!sourceStats[name]) sourceStats[name] = { success: 0, fail: 0, totalTime: 0 };
        }

        async function runWithSourceStat(name, fn) {
            ensureSourceStat(name);
            const startTime = Date.now();
            try {
                const data = await fn();
                const duration = Date.now() - startTime;
                sourceStats[name].success++;
                sourceStats[name].totalTime += duration;
                updateSourceIndicator(name);
                return data;
            } catch (error) {
                const duration = Date.now() - startTime;
                sourceStats[name].fail++;
                throw error;
            }
        }

        function fetchJsonp(url, callbackParam, timeoutMs = 10000) {
            return new Promise((resolve, reject) => {
                const cbName = `__ff_jsonp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                const script = document.createElement('script');
                const sep = url.includes('?') ? '&' : '?';
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error('timeout'));
                }, timeoutMs);
                const cleanup = () => {
                    clearTimeout(timer);
                    try { delete window[cbName]; } catch { window[cbName] = undefined; }
                    script.remove();
                };
                window[cbName] = (data) => {
                    cleanup();
                    resolve(data);
                };
                script.onerror = () => {
                    cleanup();
                    reject(new Error('script load failed'));
                };
                script.src = `${url}${sep}${callbackParam}=${cbName}`;
                document.head.appendChild(script);
            });
        }

        function loadScript(url, timeoutMs = 12000) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error('timeout'));
                }, timeoutMs);
                const cleanup = () => {
                    clearTimeout(timer);
                    script.remove();
                };
                script.onload = () => {
                    cleanup();
                    resolve();
                };
                script.onerror = () => {
                    cleanup();
                    reject(new Error('script load failed'));
                };
                script.src = url;
                document.head.appendChild(script);
            });
        }

        async function fetchApidataViaScript(url, sourceName) {
            return await runWithSourceStat(sourceName, async () => {
                try { delete window.apidata; } catch { window.apidata = undefined; }
                await loadScript(url, 12000);
                const d = window.apidata;
                if (!d) throw new Error('no apidata');
                try { delete window.apidata; } catch { window.apidata = undefined; }
                return d;
            });
        }

        const DATA_SOURCES = {
            fundgz_jsonp: {
                name: 'fundgz_jsonp', priority: 1,
                fetch: async (code) => {
                    return await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        const prev = window.jsonpgz;
                        const timeout = setTimeout(() => { window.jsonpgz = prev; script.remove(); reject(new Error('timeout')); }, 8000);
                        window.jsonpgz = (data) => { clearTimeout(timeout); window.jsonpgz = prev; script.remove(); resolve(data); };
                        script.onerror = () => { clearTimeout(timeout); window.jsonpgz = prev; script.remove(); reject(new Error('script load failed')); };
                        script.src = `https://fundgz.1234567.com.cn/js/${code}.js?rt=${Date.now()}`;
                        document.head.appendChild(script);
                    });
                }
            },
            ttjj_api_jsonp: {
                name: 'ttjj_api_jsonp', priority: 2,
                fetch: async (code) => {
                    const url = `https://api.fund.eastmoney.com/f10/lsjz?fundCode=${code}&pageIndex=1&pageSize=1&_=${Date.now()}`;
                    const json = await fetchJsonp(url, 'callback', 12000);
                    const latest = json?.Data?.LSJZList?.[0];
                    if (!latest) throw new Error('No data');
                    return { name: json.Data.SHORTNAME || code, dwjz: latest.DWJZ, jzrq: latest.FSRQ, gsz: latest.DWJZ, gszzl: latest.JZZZL || '0.00', gztime: latest.FSRQ + ' 15:00' };
                }
            },
            pingzhongdata_script: {
                name: 'pingzhongdata_script', priority: 3,
                fetch: async (code) => {
                    await loadScript(`https://fund.eastmoney.com/pingzhongdata/${code}.js?rt=${Date.now()}`, 12000);
                    const name = (window.fS_name || window.fSName || '').toString();
                    const navData = window.Data_netWorthTrend;
                    if (!name || !Array.isArray(navData) || navData.length === 0) throw new Error('Parse failed');
                    const latest = navData[navData.length - 1];
                    const prev = navData.length >= 2 ? navData[navData.length - 2] : null;
                    const dwjz = latest?.y;
                    const jzrq = new Date(latest?.x).toISOString().split('T')[0];
                    let gszzl = '0.00';
                    if (prev && prev.y) gszzl = (((latest.y - prev.y) / prev.y) * 100).toFixed(2);
                    return { name, dwjz: String(dwjz), jzrq, gsz: String(dwjz), gszzl, gztime: jzrq + ' 15:00' };
                }
            }
        };

        const sourceStats = {};
        Object.values(DATA_SOURCES).forEach(s => ensureSourceStat(s.name));

        async function fetchWithFallback(code) {
            const sources = Object.values(DATA_SOURCES).sort((a, b) => {
                ensureSourceStat(a.name);
                ensureSourceStat(b.name);
                const aSuccessRate = sourceStats[a.name].success / (sourceStats[a.name].success + sourceStats[a.name].fail || 1);
                const bSuccessRate = sourceStats[b.name].success / (sourceStats[b.name].success + sourceStats[b.name].fail || 1);
                if (Math.abs(aSuccessRate - bSuccessRate) > 0.1) return bSuccessRate - aSuccessRate;
                return a.priority - b.priority;
            });
            
            let lastError;
            for (const source of sources) {
                const startTime = Date.now();
                try {
                    console.log(`ğŸ”„ [${source.name}] å°è¯•è·å–æ•°æ®...`);
                    const data = await source.fetch(code);
                    const duration = Date.now() - startTime;
                    if (!data || !data.dwjz || !data.name) throw new Error('æ•°æ®ä¸å®Œæ•´');
                    ensureSourceStat(source.name);
                    sourceStats[source.name].success++;
                    sourceStats[source.name].totalTime += duration;
                    console.log(`âœ… [${source.name}] æˆåŠŸï¼è€—æ—¶: ${duration}ms`);
                    updateSourceIndicator(source.name);
                    return data;
                } catch (error) {
                    const duration = Date.now() - startTime;
                    ensureSourceStat(source.name);
                    sourceStats[source.name].fail++;
                    console.warn(`âŒ [${source.name}] å¤±è´¥: ${error.message} (${duration}ms)`);
                    lastError = error;
                    if (source !== sources[sources.length - 1]) { await new Promise(resolve => setTimeout(resolve, 200)); continue; }
                }
            }
            throw lastError || new Error('æ‰€æœ‰æ•°æ®æºå‡å¤±è´¥');
        }

        function showSourceStats() { console.table(Object.entries(sourceStats).map(([name, stats]) => ({ æ•°æ®æº: name, æˆåŠŸ: stats.success, å¤±è´¥: stats.fail, æˆåŠŸç‡: stats.success + stats.fail > 0 ? ((stats.success / (stats.success + stats.fail)) * 100).toFixed(1) + '%' : 'N/A', å¹³å‡è€—æ—¶: stats.success > 0 ? (stats.totalTime / stats.success).toFixed(0) + 'ms' : 'N/A' }))); }
        window.showSourceStats = showSourceStats;
        
        let lastSuccessfulSource = 'fundgz_jsonp';
        document.getElementById('sourceIndicator')?.addEventListener('click', () => { openSourceStatsModal(); });
        
        function openSourceStatsModal() {
            const modal = document.getElementById('sourceStatsModal');
            const tbody = document.getElementById('sourceStatsTableBody');
            const statsData = Object.entries(sourceStats).map(([name, stats]) => ({ name, success: stats.success, fail: stats.fail, successRate: stats.success + stats.fail > 0 ? ((stats.success / (stats.success + stats.fail)) * 100).toFixed(1) : 'N/A', avgTime: stats.success > 0 ? (stats.totalTime / stats.success).toFixed(0) : 'N/A' })).sort((a, b) => (parseFloat(b.successRate) || 0) - (parseFloat(a.successRate) || 0));
            tbody.innerHTML = statsData.map(stat => { const rate = parseFloat(stat.successRate) || 0; const rateClass = rate >= 80 ? 'high' : rate >= 50 ? 'medium' : 'low'; return `<tr><td style="font-family: 'JetBrains Mono', monospace; font-size: 0.8125rem;">${stat.name}</td><td style="color: #10b981; font-weight: 600;">${stat.success}</td><td style="color: #ef4444; font-weight: 600;">${stat.fail}</td><td class="success-rate ${rateClass}">${stat.successRate}${stat.successRate !== 'N/A' ? '%' : ''}</td><td style="font-family: 'JetBrains Mono', monospace;">${stat.avgTime}${stat.avgTime !== 'N/A' ? 'ms' : ''}</td></tr>`; }).join('') || '<tr><td colspan="5" style="text-align: center; padding: 20px; color: var(--gray-500);">æš‚æ— æ•°æ®</td></tr>';
            modal.classList.add('active');
        }
        function closeSourceStats() { document.getElementById('sourceStatsModal').classList.remove('active'); }
        document.getElementById('sourceStatsModal')?.addEventListener('click', (e) => { if (e.target.id === 'sourceStatsModal') closeSourceStats(); });
        function updateSourceIndicator(sourceName) { lastSuccessfulSource = sourceName; const indicator = document.getElementById('currentSourceName'); if (indicator) indicator.textContent = sourceName; }

        window.addEventListener('DOMContentLoaded', () => { console.log('Higher | 9880699@gmail.com'); initChart(); renderFundList(); fetchMarketIndices(); initMobileSwipeNavigation(); if (funds.length > 0) selectFund(funds[0]); startAutoUpdate(); });

        function renderFundList() {
            const listEl = document.getElementById('fundList');
            if (funds.length === 0) { listEl.innerHTML = `<div class="empty-state"><div class="empty-icon">ğŸ“Š</div><div class="empty-text">è¿˜æ²¡æœ‰æ·»åŠ åŸºé‡‘</div><div class="empty-subtext">è¾“å…¥åŸºé‡‘ä»£ç å¼€å§‹ç›‘æ§</div></div>`; return; }
            listEl.innerHTML = funds.map(fund => {
                const isCollapsed = fund._cardCollapsed !== false; // é»˜è®¤æŠ˜å 
                const status = getMarketStatus();
                const isRealtime = (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚');
                const displayNav = getDisplayNav(fund);
                const badgeVal = getDisplayDayGrowth(fund);
                const badgeOk = Number.isFinite(badgeVal);
                return `
                <div class="fund-item ${selectedFund?.code === fund.code ? 'active' : ''} ${isCollapsed ? 'card-collapsed' : 'card-expanded'}" data-code="${fund.code}">
                    <div class="fund-header" onclick="toggleFundCard('${fund.code}', event)">
                        <div class="fund-info">
                            <div class="fund-name">${fund.name || 'åŠ è½½ä¸­...'}<span class="fund-collapse-arrow ${isCollapsed ? 'collapsed' : ''}" id="arrow_${fund.code}">â–¼</span></div>
                            <div class="fund-code">${fund.code}<span class="fund-code-chg ${badgeOk ? (badgeVal >= 0 ? 'positive' : 'negative') : 'neutral'}">${badgeOk ? (badgeVal >= 0 ? '+' : '') + badgeVal.toFixed(2) + '%' : '--'}</span></div>
                        </div>
                        <div class="fund-actions">
                            <button class="btn-icon btn-edit" onclick="event.stopPropagation(); openPosModal('${fund.code}')" title="ç¼–è¾‘æŒä»“">âœï¸</button>
                            <button class="btn-icon btn-refresh" onclick="event.stopPropagation(); refreshFundByCode('${fund.code}')">ğŸ”„</button>
                            <button class="btn-icon btn-delete" onclick="event.stopPropagation(); deleteFund('${fund.code}')">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="fund-body ${isCollapsed ? 'collapsed' : ''}" id="body_${fund.code}">
                        <div class="fund-metrics">
                            <div class="metric-card"><div class="metric-label">ä¼°ç®—å‡€å€¼</div><div class="metric-value">${displayNav}</div></div>
                            <div class="metric-card"><div class="metric-label">æ—¥æ¶¨è·Œ</div><div class="metric-value ${badgeOk && badgeVal >= 0 ? 'positive' : 'negative'}">${badgeOk ? (badgeVal >= 0 ? '+' : '') + badgeVal.toFixed(2) + '%' : '--'}</div></div>
                        </div>
                        <div class="fund-chart" id="miniChart_${fund.code}"></div>
                    </div>
                </div>`;
            }).join('');
            // ç»‘å®šå¡ç‰‡ä¸»åŒºåŸŸç‚¹å‡» â†’ é€‰ä¸­åŸºé‡‘
            listEl.querySelectorAll('.fund-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.closest('.fund-actions') || e.target.closest('.fund-header')) return;
                    const fund = funds.find(f => f.code === item.dataset.code);
                    if (fund) selectFund(fund);
                });
            });
            funds.forEach(fund => setTimeout(() => initMiniChart(fund), 100));
            updateAllPositionSummary();
        }

        function refreshFundByCode(code) {
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            fetchFundData(fund);
        }

        function initMobileSwipeNavigation() {
            const container = document.querySelector('.main-content');
            if (!container) return;
            const hintEl = document.getElementById('swipeHint');
            const root = document;

            let startX = 0;
            let startY = 0;
            let moved = false;
            let tracking = false;
            let pointerId = null;
            let pointerCaptured = false;

            const minDx = 60;
            const maxDy = 45;
            const ratio = 1.2;

            function isMobile() {
                try {
                    if (window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches) return true;
                } catch (err) { /* ignore */ }
                return window.innerWidth <= 768;
            }

            function canHandle(e) {
                if (!isMobile()) return false;
                if (sidebar?.classList.contains('open') || sidebarOverlay?.classList.contains('active')) return false;
                const t = e?.target;
                if (t && (t.closest('input') || t.closest('textarea') || t.closest('select') || t.closest('button') || t.closest('a'))) return false;
                return true;
            }

            function showHintOnce() {
                if (!hintEl) return;
                if (!isMobile()) return;
                hintEl.classList.add('show');
                hintEl.style.display = 'flex';
                setTimeout(() => {
                    hintEl.classList.remove('show');
                    hintEl.style.display = 'none';
                }, 4200);
            }

            function dismissHint() {
                if (!hintEl) return;
                hintEl.classList.remove('show');
                hintEl.style.display = 'none';
            }

            function gotoDelta(delta) {
                if (!Array.isArray(funds) || funds.length <= 1) return;
                const idx = selectedFund ? funds.findIndex(f => f.code === selectedFund.code) : -1;
                const cur = idx >= 0 ? idx : 0;
                let next = cur + delta;
                if (next < 0) next = funds.length - 1;
                if (next >= funds.length) next = 0;
                const f2 = funds[next];
                if (f2) selectFund(f2);
            }

            function isInteractiveTarget(e) {
                const t = e?.target;
                if (!t) return false;
                return !!(t.closest('input') || t.closest('textarea') || t.closest('select') || t.closest('button') || t.closest('a'));
            }

            function handleSwipeEnd(dx, dy) {
                if (Math.abs(dx) >= minDx && Math.abs(dy) <= maxDy && Math.abs(dx) > Math.abs(dy) * ratio) {
                    dismissHint();
                    if (dx < 0) gotoDelta(+1);
                    else gotoDelta(-1);
                }
            }

            const hasPointer = typeof window !== 'undefined' && 'PointerEvent' in window;

            showHintOnce();

            if (hasPointer) {
                root.addEventListener('pointerdown', (e) => {
                    if (!canHandle(e)) return;
                    if (isInteractiveTarget(e)) return;
                    if (!container.contains(e.target)) return;
                    if (e.isPrimary === false) return;
                    if (e.pointerType === 'mouse' && e.button !== 0) return;
                    startX = e.clientX;
                    startY = e.clientY;
                    moved = false;
                    tracking = true;
                    pointerId = e.pointerId;
                    pointerCaptured = false;
                }, { capture: true });

                root.addEventListener('pointermove', (e) => {
                    if (!tracking) return;
                    if (pointerId !== null && e.pointerId !== pointerId) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    if (Math.abs(dx) > 8 || Math.abs(dy) > 8) moved = true;

                    if (!pointerCaptured && Math.abs(dx) > Math.abs(dy) * ratio && Math.abs(dx) > 10) {
                        try { container.setPointerCapture(e.pointerId); pointerCaptured = true; } catch (err) { /* ignore */ }
                    }

                    if (Math.abs(dy) > Math.abs(dx) * ratio) {
                        tracking = false;
                        pointerId = null;
                        if (pointerCaptured) {
                            try { container.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                            pointerCaptured = false;
                        }
                        return;
                    }

                    if (Math.abs(dx) > Math.abs(dy) * ratio) {
                        e.preventDefault();
                    }
                }, { capture: true });

                const pointerUpOrCancel = (e) => {
                    if (!tracking) return;
                    if (pointerId !== null && e.pointerId !== pointerId) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    const shouldHandle = tracking && moved && canHandle(e) && !isInteractiveTarget(e);

                    tracking = false;
                    pointerId = null;
                    if (pointerCaptured) {
                        try { container.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                        pointerCaptured = false;
                    }

                    if (shouldHandle) handleSwipeEnd(dx, dy);
                };

                root.addEventListener('pointerup', pointerUpOrCancel, { capture: true });
                root.addEventListener('pointercancel', pointerUpOrCancel, { capture: true });
                return;
            }

            root.addEventListener('touchstart', (e) => {
                if (!canHandle(e)) return;
                if (!container.contains(e.target)) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                startX = t.clientX;
                startY = t.clientY;
                moved = false;
                tracking = true;
            }, { passive: true, capture: true });

            root.addEventListener('touchmove', (e) => {
                if (!tracking) return;
                const t = e.touches && e.touches[0];
                if (!t) return;
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                if (Math.abs(dx) > 8 || Math.abs(dy) > 8) moved = true;
                if (Math.abs(dy) > Math.abs(dx) * ratio) {
                    tracking = false;
                }
            }, { passive: true, capture: true });

            root.addEventListener('touchend', (e) => {
                if (!tracking || !moved) { tracking = false; return; }
                if (!canHandle(e)) { tracking = false; return; }
                const t = e.changedTouches && e.changedTouches[0];
                if (!t) { tracking = false; return; }
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                tracking = false;

                handleSwipeEnd(dx, dy);
            }, { passive: true, capture: true });
        }

        function toggleFundCard(code, event) {
            event.stopPropagation();
            if (event.target.closest('.fund-actions')) return;
            const fund = funds.find(f => f.code === code);
            if (!fund) return;
            const body = document.getElementById('body_' + code);
            const arrow = document.getElementById('arrow_' + code);
            if (!body) return;
            const wasCollapsed = body.classList.contains('collapsed');
            body.classList.toggle('collapsed');
            if (arrow) arrow.classList.toggle('collapsed');
            fund._cardCollapsed = !wasCollapsed;
            const root = event.currentTarget?.closest('.fund-item');
            if (root) {
                root.classList.toggle('card-collapsed', fund._cardCollapsed !== false);
                root.classList.toggle('card-expanded', fund._cardCollapsed === false);
            }
            // å±•å¼€æ—¶é‡æ–°åˆå§‹åŒ–è¿·ä½ å›¾
            if (wasCollapsed) {
                setTimeout(() => {
                    if (miniCharts[code]) { miniCharts[code].dispose(); delete miniCharts[code]; }
                    initMiniChart(fund);
                }, 50);
            }
            // åŒæ—¶é€‰ä¸­è¯¥åŸºé‡‘
            selectFund(fund);
        }


        function initMiniChart(fund) {
            const chartDom = document.getElementById(`miniChart_${fund.code}`);
            if (!chartDom) return;
            // renderFundList ä¼šé‡å»º DOMï¼šè‹¥ç¼“å­˜å®ä¾‹ç»‘å®šçš„æ˜¯æ—§èŠ‚ç‚¹ï¼Œä¼šå¯¼è‡´â€œç‚¹ä¸€ä¸‹å°±æ¶ˆå¤±/ä¸ä¸€è‡´â€
            const cached = miniCharts[fund.code];
            if (cached) {
                const dom0 = (typeof cached.getDom === 'function') ? cached.getDom() : null;
                if (dom0 && dom0 !== chartDom) {
                    cached.dispose();
                    delete miniCharts[fund.code];
                } else {
                    return;
                }
            }
            const miniChart = echarts.init(chartDom);
            miniCharts[fund.code] = miniChart;
            const { xData, yData } = getRealtimeChartData(fund);
            const isUp = getDisplayDayGrowth(fund) >= 0;
            miniChart.setOption({
                grid: { left: 0, right: 0, top: 5, bottom: 5 },
                xAxis: { type: 'category', data: xData, show: false, boundaryGap: false },
                yAxis: { type: 'value', show: false, scale: true },
                series: [{ type: 'line', data: yData, smooth: true, symbol: 'none', connectNulls: true, lineStyle: { width: 2, color: isUp ? '#ef4444' : '#10b981' }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: isUp ? 'rgba(239, 68, 68, 0.3)' : 'rgba(16, 185, 129, 0.3)' }, { offset: 1, color: 'rgba(255,255,255,0)' }]) } }]
            });
            window.addEventListener('resize', () => miniChart.resize());
        }

        function updateMiniChart(fund) {
            const chartDom = document.getElementById(`miniChart_${fund.code}`);
            if (!chartDom) return;
            const status = getMarketStatus();
            if (!status.canRealtimeUpdate && status.reason !== 'åˆé—´ä¼‘å¸‚') {
                // ä¼‘å¸‚/ä¸å¼€ç›˜ï¼šä¿æŒæœ€åä¸€å¸§ï¼Œé¿å…åå¤ setOption å¯¼è‡´é—ªè·³
                return;
            }
            const c = miniCharts[fund.code];
            if (!c) { initMiniChart(fund); return; }
            const dom0 = (typeof c.getDom === 'function') ? c.getDom() : null;
            if (dom0 && dom0 !== chartDom) {
                c.dispose();
                delete miniCharts[fund.code];
                initMiniChart(fund);
                return;
            }
            const { xData, yData } = getRealtimeChartData(fund);
            const isUp = getDisplayDayGrowth(fund) >= 0;
            c.setOption({
                xAxis: { data: xData },
                series: [{
                    data: yData,
                    connectNulls: true,
                    lineStyle: { width: 2, color: isUp ? '#ef4444' : '#10b981' },
                    areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: isUp ? 'rgba(239, 68, 68, 0.3)' : 'rgba(16, 185, 129, 0.3)' }, { offset: 1, color: 'rgba(255,255,255,0)' }]) }
                }]
            }, { lazyUpdate: true });
        }

        function getMiniRealtimeSeries(fund) {
            const series = getRealtimeSeriesForChart(fund);
            let end = getEffectiveRealtimeEndIndex(series);
            if (end < 0) end = series.length - 1;
            return series.slice(0, end + 1);
        }

        function findLastFiniteIndex(arr) {
            if (!Array.isArray(arr)) return -1;
            for (let i = arr.length - 1; i >= 0; i--) {
                if (Number.isFinite(arr[i])) return i;
            }
            return -1;
        }

        function getEffectiveRealtimeEndIndex(series) {
            const timeEnd = getRealtimeEndIndex();
            const lastKnown = findLastFiniteIndex(series);
            if (timeEnd < 0) return lastKnown;
            if (lastKnown < 0) return timeEnd;
            return Math.min(timeEnd, lastKnown);
        }

        function getRealtimeSeriesForChart(fund) {
            const baseValue = parseFloat(fund.estimatedNav || fund.currentNav || 1.5);
            const stable = (Number.isFinite(baseValue) && baseValue > 0) ? baseValue : 1.5;
            const raw = Array.isArray(fund.realtimeHistory) ? fund.realtimeHistory : [];
            const out = new Array(242);
            // ä¸è¦æŠŠâ€œæœªæ¥æ—¶é—´æ®µâ€ç”¨ last å€¼ç¡¬å¡«æ»¡ï¼Œå¦åˆ™åˆä¼‘/ç›˜å‰ä¼šçœ‹èµ·æ¥åƒç”»åˆ°äº† 15:00ã€‚
            // æœªæ¥éƒ¨åˆ†ç”¨ nullï¼Œè®©æŠ˜çº¿åœ¨æœ€åä¸€ä¸ªå·²çŸ¥ç‚¹å¤„è‡ªç„¶åœæ­¢ã€‚
            let firstKnown = -1;
            let lastKnown = -1;
            for (let i = 0; i < raw.length; i++) {
                if (Number.isFinite(raw[i])) { firstKnown = i; break; }
            }
            for (let i = raw.length - 1; i >= 0; i--) {
                if (Number.isFinite(raw[i])) { lastKnown = i; break; }
            }
            for (let i = 0; i < 242; i++) {
                const v = raw[i];
                // å…³é”®ï¼šé¦–ä¸ªå·²çŸ¥ç‚¹ä¹‹å‰ä¸è¦å›å¡«ï¼Œé¿å…æŠŠ 10:30 çš„é¦–æ¡æ•°æ®æ˜ å°„æˆ 09:30-10:30
                if (firstKnown >= 0 && i < firstKnown) {
                    out[i] = null;
                } else {
                    // é¦–ä¸ªå·²çŸ¥ç‚¹ä¹‹åï¼šä»…åœ¨æ¥å£å®é™…è¿”å›è¯¥åˆ†é’Ÿæ—¶ç»˜åˆ¶ï¼Œå¦åˆ™ç”¨ null æ–­çº¿ï¼ˆä¸è¦ç”¨ä¸Šä¸€åˆ†é’Ÿå€¼è¡¥é½ï¼‰
                    out[i] = (lastKnown >= 0 && i <= lastKnown && Number.isFinite(v)) ? v : null;
                }
            }
            return out;
        }

        function getOfficialDayGrowthFromHistory(fund) {
            const raw = historyCache[fund.code];
            if (!Array.isArray(raw) || raw.length < 2) return NaN;
            const a = raw[raw.length - 2]?.y;
            const b = raw[raw.length - 1]?.y;
            if (!Number.isFinite(a) || !Number.isFinite(b) || a === 0) return NaN;
            return ((b - a) / a) * 100;
        }

        function getDisplayDayGrowth(fund) {
            const status = getMarketStatus();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const est = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
            const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(est);

            // å¤œé—´å®˜æ–¹å‡€å€¼å·²æ›´æ–°ï¼šä¼˜å…ˆå®˜æ–¹å£å¾„ï¼ˆé¿å…ç»§ç»­æ˜¾ç¤ºâ€œä»Šæ—¥ä¼°ç®—â€é€ æˆè¯¯è§£ï¼‰
            if (navDateStr === todayStr) {
                const off0 = getOfficialDayGrowthFromHistory(fund);
                if (Number.isFinite(off0)) return off0;
            }

            // ä»Šæ—¥å®˜æ–¹å‡€å€¼æœªå‡ºï¼šä¼˜å…ˆå±•ç¤ºâ€œä»Šæ—¥ä¼°ç®—æ¶¨è·Œå¹…â€ï¼ˆç›˜åç‚¹å‡»å¡ç‰‡ä¹Ÿä¸å›é€€åˆ°æ˜¨å¤©ï¼‰
            if (navDateStr !== todayStr && hasTodayEst) {
                return est;
            }

            // äº¤æ˜“ä¸­/åˆä¼‘/ç›˜åè¡¥å…¨ï¼šå±•ç¤ºä¼°ç®—æ—¥æ¶¨è·Œ
            if (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚' || status.reason === 'ç›˜åè¡¥å…¨') {
                const v = parseFloat(fund.dayGrowth);
                return Number.isFinite(v) ? v : 0;
            }
            // å…¶ä»–ï¼šæ˜¾ç¤ºå®˜æ–¹æ—¥æ¶¨è·Œï¼ˆå†å²å‡€å€¼è®¡ç®—ï¼‰
            const off = getOfficialDayGrowthFromHistory(fund);
            if (Number.isFinite(off)) return off;
            const fallback = parseFloat(fund.dayGrowth);
            return Number.isFinite(fallback) ? fallback : 0;
        }

        function getDisplayNav(fund) {
            const status = getMarketStatus();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const estNavNum = parseFloat(fund.estimatedNav);
            const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(estNavNum) && estNavNum > 0;

            // ä»Šæ—¥å®˜æ–¹å‡€å€¼æœªå‡ºï¼šä¼˜å…ˆå±•ç¤ºâ€œä»Šæ—¥æœ€åä¸€æ¬¡ä¼°ç®—å€¼â€ï¼ˆç›˜åä¹Ÿè¦ä¿ç•™ï¼‰
            if (navDateStr !== todayStr && hasTodayEst) {
                return fund.estimatedNav;
            }

            // äº¤æ˜“ä¸­/åˆä¼‘/ç›˜åè¡¥å…¨ï¼šå±•ç¤ºä¼°ç®—å‡€å€¼ï¼ˆè‹¥æœ‰ï¼‰ï¼Œå¦åˆ™å›é€€å®˜æ–¹å‡€å€¼
            if (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚' || status.reason === 'ç›˜åè¡¥å…¨') {
                return fund.estimatedNav || fund.currentNav || '--';
            }
            return fund.currentNav || '--';
        }

        function getShanghaiTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Asia/Shanghai', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), second: parseInt(map.second), dow };
        }

        function getNewYorkTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'America/New_York', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), second: parseInt(map.second), dow };
        }

        function isUsMarketOpenNow() {
            const ny = getNewYorkTimeParts();
            // å‘¨ä¸€~å‘¨äº”
            if (ny.dow === 0 || ny.dow === 6) return false;
            const min = ny.hour * 60 + ny.minute;
            // ç¾è‚¡å¸¸è§„äº¤æ˜“æ—¶æ®µï¼š09:30-16:00ï¼ˆçº½çº¦æ—¶é—´ï¼Œè‡ªåŠ¨å¤„ç†å¤ä»¤æ—¶ï¼‰
            return min >= 9 * 60 + 30 && min <= 16 * 60;
        }

        function formatLastGzTimeForAshare(gztime) {
            if (!gztime || typeof gztime !== 'string') return gztime;
            let m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return gztime;
            const minutes = parseInt(m[4]) * 60 + parseInt(m[5]);
            const date = `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
            return minutes > 15 * 60 ? `${date} 15:00` : `${date} ${m[4].padStart(2,'0')}:${m[5].padStart(2,'0')}`;
        }

        function getDateStr(dateTimeStr) {
            if(!dateTimeStr) return '';
            const m = dateTimeStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
            if(!m) return '';
            return `${m[1]}-${m[2].padStart(2,'0')}-${m[3].padStart(2,'0')}`;
        }

        function getGzDelayMinutes(gztime) {
            if (!gztime || typeof gztime !== 'string') return null;
            const m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return null;
            const gzDate = `${m[1]}-${String(m[2]).padStart(2,'0')}-${String(m[3]).padStart(2,'0')}`;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (gzDate !== todayStr) return null;
            const gzMin = parseInt(m[4]) * 60 + parseInt(m[5]);
            const nowMinRaw = sh.hour * 60 + sh.minute;

            // å»¶è¿Ÿæ˜¾ç¤ºå£å¾„ï¼šä¼‘å¸‚æ—¶ä¸åº”æŠŠâ€œéäº¤æ˜“æ—¶é—´â€ç®—è¿›å»¶è¿Ÿ
            // - ç›˜å‰ï¼šæŒ‰ 09:30 å°é¡¶
            // - åˆé—´ä¼‘å¸‚ï¼šæŒ‰ 11:30 å°é¡¶
            // - ç›˜åï¼šæŒ‰ 15:00 å°é¡¶ï¼ˆç›˜åè¡¥å…¨æœŸé™¤å¤–ï¼‰
            const status = getMarketStatus();
            let capMin = 900;
            if (status.reason === 'ç›˜å‰') capMin = 570;
            else if (status.reason === 'åˆé—´ä¼‘å¸‚') capMin = 690;
            else if (status.reason === 'ç›˜å') capMin = 900;
            else if (status.reason === 'ç›˜åè¡¥å…¨') capMin = nowMinRaw;
            const nowMin = Math.min(nowMinRaw, capMin);
            const gzMinCapped = Math.min(gzMin, 900);

            // è§„åˆ™ï¼šåªè¦å·²ç»æ‹¿åˆ°æ”¶ç›˜(15:00)æ•°æ®ï¼Œå°±ä¸å†å±•ç¤ºâ€œå»¶è¿Ÿxxåˆ†é’Ÿâ€
            if (gzMinCapped >= 900) return 0;
            const d = nowMin - gzMinCapped;
            if (!Number.isFinite(d) || d < 0) return null;
            return d;
        }

        async function fetchFundData(fund, options = {}) {
            try {
                const data = await (fundgzQueue = fundgzQueue.then(() => fetchWithFallback(fund.code)));
                fund.name = data.name;
                fund.currentNav = data.dwjz;
                // ç»Ÿä¸€å£å¾„ï¼šfund.dayGrowth ä»£è¡¨â€œä¼°ç®—æ—¥æ¶¨è·Œå¹…â€ï¼ˆäº¤æ˜“ä¸­ï¼‰ï¼Œæ¥æºå¯èƒ½æ˜¯ fundgz æˆ–æŒä»“ä¼°ç®—
                // é˜²å›é€€ï¼šå¦‚æœæ¥å£è¿”å›äº†æ›´æ—©çš„ gztimeï¼ˆæ—§æ•°æ®ï¼‰ï¼Œä¸è¦è¦†ç›–æœ€æ–°æ˜¾ç¤ºä¸æ›²çº¿
                const sh0 = getShanghaiTimeParts();
                const todayStr0 = `${sh0.year}-${String(sh0.month).padStart(2,'0')}-${String(sh0.day).padStart(2,'0')}`;
                const gzDateStr = getDateStr(data.gztime);
                // æ–°äº¤æ˜“æ—¥/è·¨å¤©ï¼šé‡ç½® last idxï¼Œé¿å…æ˜¨å¤©çš„ idx=241 å¯¼è‡´ä»Šå¤©æ—©ç›˜ acceptGz æ°¸è¿œä¸º false
                if (gzDateStr && gzDateStr !== (fund._lastGzDate || '')) {
                    fund._lastGzDate = gzDateStr;
                    if (gzDateStr === todayStr0) {
                        fund._lastGzIdx = -1;
                    }
                }
                const gzIdx = getRealtimeMinuteIndexFromGzTime(data.gztime);
                const lastIdx = Number.isFinite(fund._lastGzIdx) ? fund._lastGzIdx : -1;
                const acceptGz = (gzIdx < 0) ? true : (gzIdx >= lastIdx);
                if (acceptGz && gzIdx >= 0) fund._lastGzIdx = gzIdx;

                if (acceptGz) {
                    fund._fundgzDayGrowth = data.gszzl;
                    // é»˜è®¤å…ˆç”¨ fundgzï¼›è‹¥åç»­æœ‰æŒä»“ä¼°ç®—ï¼Œä¼šåœ¨ updateDayGrowthDisplay ä¸­è¦†ç›–
                    fund.dayGrowth = data.gszzl;
                    fund.estimatedNav = data.gsz;
                    fund.estimatedTime = data.gztime;
                }
                fund.navDate = data.jzrq;
                const status = getMarketStatus();
                const gszNum0 = parseFloat(data.gsz);
                const dwjzNum0 = parseFloat(data.dwjz);
                const seed = status.canRealtimeUpdate
                    ? ((Number.isFinite(gszNum0) && gszNum0 > 0) ? gszNum0 : dwjzNum0)
                    : dwjzNum0;
                if (!Array.isArray(fund.realtimeHistory)) fund.realtimeHistory = [];
                const allowRealtimeWrite = (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚' || status.reason === 'ç›˜åè¡¥å…¨');
                if (allowRealtimeWrite && acceptGz) {
                    const v0 = parseFloat(data.gsz);
                    const v = (Number.isFinite(v0) && v0 > 0) ? v0 : seed;
                    if (Number.isFinite(v) && v > 0) {
                        // å¯¹é½åˆ°â€œåˆ†é’Ÿæ§½ä½â€ï¼Œé¿å… push å¯¼è‡´æ—¶é—´è½´æ¼‚ç§»åˆ° 14:53 ä¹‹ç±»
                        // ä½¿ç”¨ gztime è®¡ç®—æ§½ä½ï¼Œé¿å…â€œæ›´æ–°äº13:51ä½†å›¾ç”»åˆ°13:55â€è¿™ç§è¶…å‰
                        const idx = gzIdx >= 0 ? gzIdx : getRealtimeMinuteIndex();
                        if (idx >= 0) {
                            if (fund.realtimeHistory.length < 242) fund.realtimeHistory.length = 242;
                            fund.realtimeHistory[idx] = v;
                        }
                    }
                }
                if (acceptGz) {
                    fund.lastUpdateTime = formatLastGzTimeForAshare(data.gztime) || '';
                }
                saveFunds();
                if (!options.suppressRender) renderFundList();
                // åŒæ­¥è¿·ä½ å›¾ä¸ä¸»å›¾ï¼ˆåŒä¸€ä»½ realtimeHistoryï¼‰
                // ä¼‘å¸‚/ä¸å¼€ç›˜æ—¶ä¸åˆ·æ–°è¿·ä½ å›¾ï¼Œé¿å…é—ªè·³ï¼›ä½†å…è®¸é¦–æ¬¡åˆå§‹åŒ–
                if (allowRealtimeWrite && acceptGz) {
                    updateMiniChart(fund);
                } else {
                    if (!miniCharts[fund.code]) initMiniChart(fund);
                }
                if (selectedFund?.code === fund.code) { updateMainDisplay(fund); if (currentTimeRange === 'realtime') updateRealtimeChart(); }
            } catch (e) { console.error('è·å–åŸºé‡‘æ•°æ®å¤±è´¥:', e); showToast('æ•°æ®è·å–å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error'); }
        }

        function getShanghaiTimeParts() {
            const now = new Date();
            const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Asia/Shanghai', hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).formatToParts(now);
            const map = {}; parts.forEach(p => map[p.type] = p.value);
            const dow = new Date(Date.UTC(map.year, map.month - 1, map.day)).getUTCDay();
            return { year: parseInt(map.year), month: parseInt(map.month), day: parseInt(map.day), hour: parseInt(map.hour), minute: parseInt(map.minute), dow };
        }

        function formatLastGzTimeForAshare(gztime) {
            if (!gztime || typeof gztime !== 'string') return gztime;
            let m = gztime.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2}):(\d{2})/);
            if (!m) return gztime;
            const minutes = parseInt(m[4]) * 60 + parseInt(m[5]);
            const date = `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
            return minutes > 15 * 60 ? `${date} 15:00` : `${date} ${m[4].padStart(2,'0')}:${m[5].padStart(2,'0')}`;
        }

        function getDateStr(dateTimeStr) {
            if(!dateTimeStr) return '';
            const m = dateTimeStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
            if(!m) return '';
            return `${m[1]}-${m[2].padStart(2,'0')}-${m[3].padStart(2,'0')}`;
        }

        function updateMainDisplay(fund) {
            document.getElementById('selectedFundName').textContent = fund.name || 'æœªçŸ¥åŸºé‡‘';
            document.getElementById('selectedFundCode').textContent = fund.code;
            document.getElementById('currentNav').textContent = fund.currentNav || '--';
            document.getElementById('navDateLabel').textContent = fund.navDate ? fund.navDate.substring(5) : '--';

            const sh0 = getShanghaiTimeParts();
            const todayStr0 = `${sh0.year}-${String(sh0.month).padStart(2,'0')}-${String(sh0.day).padStart(2,'0')}`;
            const navDateStr0 = getDateStr(fund.navDate);
            const navChangeEl = document.getElementById('navChange');
            if (navChangeEl) {
                if (navDateStr0 === todayStr0) {
                    const raw = historyCache[fund.code];
                    const prev = Array.isArray(raw) && raw.length >= 2 ? raw[raw.length - 2] : null;
                    const prevNav = prev ? Number(prev.y) : NaN;
                    const prevDate = prev ? tsToDateStr(prev.x) : '';
                    if (Number.isFinite(prevNav)) {
                        navChangeEl.textContent = `å‰æ—¥å‡€å€¼ ${prevNav.toFixed(4)}${prevDate ? `ï¼ˆ${prevDate.slice(5)}ï¼‰` : ''}`;
                        navChangeEl.className = 'stat-change';
                    } else {
                        navChangeEl.textContent = 'å‰æ—¥å‡€å€¼ --';
                        navChangeEl.className = 'stat-change';
                    }
                } else if (navDateStr0) {
                    navChangeEl.textContent = `æŠ«éœ²æ—¶é—´ ${navDateStr0.slice(5)} 15:00`;
                    navChangeEl.className = 'stat-change';
                } else {
                    navChangeEl.textContent = 'ç­‰å¾…å‡€å€¼æ›´æ–°';
                    navChangeEl.className = 'stat-change';
                }
            }

            // æ—¥æ¶¨è·Œå¹… â€” ç”± updateDayGrowthDisplay è´Ÿè´£æ¸²æŸ“
            updateDayGrowthDisplay(fund);
            
            const status = getMarketStatus();
            const shProfit = getShanghaiTimeParts();
            const todayProfitStr = `${shProfit.year}-${String(shProfit.month).padStart(2,'0')}-${String(shProfit.day).padStart(2,'0')}`;
            const navDateProfitStr = getDateStr(fund.navDate);
            const officialNav0 = parseFloat(fund.currentNav);
            const profitNav0 = parseFloat(getDisplayNav(fund));
            const profitNav = (navDateProfitStr === todayProfitStr && Number.isFinite(officialNav0))
                ? officialNav0
                : (Number.isFinite(profitNav0)
                    ? profitNav0
                    : ((status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚' || status.reason === 'ç›˜åè¡¥å…¨')
                        ? parseFloat(fund.estimatedNav || fund.currentNav)
                        : parseFloat(fund.currentNav)));
            const pos = getPosition(fund);
            if (pos.has && Number.isFinite(profitNav)) {
                const m = calcPositionMetrics(pos, profitNav);
                if (m.ok) {
                    document.getElementById('totalProfit').textContent = 'Â¥' + m.profit.toFixed(2);
                    document.getElementById('totalProfit').className = `stat-value ${m.profit>=0?'positive':'negative'}`;
                    const ppEl = document.getElementById('profitPercent');
                    ppEl.textContent = 'æŒä»“é‡‘é¢ Â¥' + m.value.toFixed(2);
                    ppEl.className = 'stat-change';
                    ppEl.style.color = '';
                } else {
                    document.getElementById('totalProfit').textContent = '--';
                    document.getElementById('totalProfit').className = 'stat-value';
                    const ppEl = document.getElementById('profitPercent');
                    ppEl.textContent = 'æŒä»“é‡‘é¢ --';
                    ppEl.className = 'stat-change';
                    ppEl.style.color = '#000';
                }
            } else {
                document.getElementById('totalProfit').textContent = '--';
                document.getElementById('totalProfit').className = 'stat-value';
                const ppEl = document.getElementById('profitPercent');
                const buy = getFundBuyInfo(fund);
                if (buy.amount && buy.date) {
                    const buyPoint = getFirstHistoryPointOnOrAfter(fund.code, buy.date);
                    const effDate = buyPoint?.date;
                    const detail = effDate ? `${buy.date} ä¹°å…¥ï¼Œé¢„è®¡ ${effDate} ç”Ÿæ•ˆ` : `${buy.date} ä¹°å…¥ï¼Œå¾…å‡€å€¼æŠ«éœ²åç”Ÿæ•ˆ`;
                    ppEl.textContent = '';
                    ppEl.appendChild(document.createTextNode(`æŒä»“é‡‘é¢ Â¥${buy.amount.toFixed(2)}`));
                    const tag = document.createElement('span');
                    tag.className = 'prebuy-tag';
                    tag.textContent = 'é¢„ä¹°å…¥';
                    tag.setAttribute('data-tooltip', detail);
                    tag.setAttribute('tabindex', '0');
                    ppEl.appendChild(tag);
                } else {
                    ppEl.textContent = 'æœªè®¾ç½®æŒä»“';
                }
                ppEl.className = 'stat-change';
                ppEl.style.color = '#000';
            }

            // ç”¨ä¸Šæµ·æ—¶åŒºåˆ¤æ–­å‘¨æœ«
            const sh = getShanghaiTimeParts();
            const isWeekend = (sh.dow === 0 || sh.dow === 6);
            if (isWeekend) {
                document.getElementById('estimatedNav').textContent = '--';
                document.getElementById('estimatedChange').textContent = 'å‘¨æœ«ä¼‘å¸‚';
                document.getElementById('estimatedChange').className = 'stat-change';
                document.getElementById('estLabel').textContent = 'ä¼°ç®—å‡€å€¼';
            } else {
                const navDateStr = getDateStr(fund.navDate);
                // ä»Šæ—¥æ—¥æœŸï¼ˆä¸Šæµ·ï¼‰
                const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;

                // ä»Šæ—¥å·²å‡ºå®˜æ–¹å‡€å€¼ï¼šä¸å†å±•ç¤ºä¼°ç®—ï¼ˆé¿å…è¯¯è§£ï¼‰ï¼Œä½†ä¿ç•™â€œä¼°ç®—å‡€å€¼â€æ ‡ç­¾
                if (navDateStr === todayStr) {
                    document.getElementById('estimatedNav').textContent = fund.currentNav || '--';
                    document.getElementById('estimatedChange').textContent = 'å·²æ›´æ–°ä»Šæ—¥å‡€å€¼';
                    document.getElementById('estimatedChange').className = 'stat-change';
                    document.getElementById('estLabel').textContent = 'ä¼°ç®—å‡€å€¼';
                } else {
                    // ä»Šæ—¥å°šæœªå‡ºå®˜æ–¹å‡€å€¼ï¼šç›˜åä¹Ÿå±•ç¤ºâ€œä»Šæ—¥æœ€åä¸€æ¬¡ä¼°ç®—å€¼â€
                    const estDateStr = getDateStr(fund.estimatedTime);
                    const estNavNum = parseFloat(fund.estimatedNav);
                    const hasTodayEst = (estDateStr === todayStr) && Number.isFinite(estNavNum) && estNavNum > 0;

                    if (hasTodayEst) {
                        const estChgNum = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
                        document.getElementById('estimatedNav').textContent = estNavNum.toFixed(4);
                        document.getElementById('estimatedChange').textContent = Number.isFinite(estChgNum)
                            ? ((estChgNum >= 0 ? '+' : '') + estChgNum.toFixed(2) + '%')
                            : '--';
                        document.getElementById('estimatedChange').className = `stat-change ${Number.isFinite(estChgNum) && estChgNum >= 0 ? 'positive' : 'negative'}`;
                        document.getElementById('estLabel').textContent = 'ä¼°ç®—å‡€å€¼';
                    } else {
                        document.getElementById('estimatedNav').textContent = '--';
                        document.getElementById('estimatedChange').textContent = 'ç­‰å¾…ä»Šæ—¥ä¼°å€¼æ›´æ–°';
                        document.getElementById('estimatedChange').className = 'stat-change';
                        document.getElementById('estLabel').textContent = 'ä¼°ç®—å‡€å€¼';
                    }
                }
            }
            const sh2 = getShanghaiTimeParts();
            const todayStr2 = `${sh2.year}-${String(sh2.month).padStart(2,'0')}-${String(sh2.day).padStart(2,'0')}`;
            const navDateStr2 = getDateStr(fund.navDate);
            let showUpdateTime = fund.lastUpdateTime || '--';
            let useDelay = true;
            // æ”¶ç›˜æ•°æ®å·²åˆ°ï¼šåªè¦å±•ç¤ºä¸º 15:00ï¼Œå°±ä¸å†æ˜¾ç¤ºâ€œå»¶è¿Ÿxxåˆ†é’Ÿâ€ï¼ˆé¿å…ç›˜åè¡¥å…¨/å£å¾„å·®å¼‚é€ æˆè¯¯å¯¼ï¼‰
            if (/\b15:00$/.test(showUpdateTime)) {
                useDelay = false;
            }
            // è‹¥ä»Šæ—¥å®˜æ–¹å‡€å€¼å·²å‡ºï¼Œä½†ä¼°å€¼æº(gztime)æ»ååˆ°æ—§æ—¥æœŸï¼Œé¿å…â€œæ›´æ–°äº 01-30â€è¿™ç§è¯¯å¯¼
            if (navDateStr2 === todayStr2) {
                const lastDateStr = getDateStr(showUpdateTime);
                if (lastDateStr && lastDateStr !== todayStr2) {
                    showUpdateTime = `${todayStr2} 15:00`;
                    useDelay = false;
                }
            }
            const delayMin = useDelay ? getGzDelayMinutes(showUpdateTime) : null;
            const delayText = (useDelay && Number.isFinite(delayMin) && delayMin >= 2) ? `ï¼ˆå»¶è¿Ÿ${delayMin}åˆ†é’Ÿï¼‰` : '';
            document.getElementById('updateTime').textContent = 'æ›´æ–°äº ' + showUpdateTime + delayText;
            updateReminderBadge();
            updateLastFiredReminderHint();
            rescheduleReminder();
            updateMarketStatusUI();
            updateAllPositionSummary();
        }

        const REMINDER_STORAGE_KEY = 'fund_reminders_v1';
        const LAST_FIRED_REMINDER_KEY = 'fund_reminders_last_fired_v1';
        let reminderTimer = null;
        let reminderScheduleKey = null;
        let reminderNextAtMs = null;
        let lastFiredHintTimer = null;
        let lastFiredHintIndex = 0;

        function loadReminders() {
            try {
                const raw = localStorage.getItem(REMINDER_STORAGE_KEY);
                const obj = raw ? JSON.parse(raw) : null;
                return (obj && typeof obj === 'object') ? obj : {};
            } catch { return {}; }
        }

        function saveReminders(map) {
            try { localStorage.setItem(REMINDER_STORAGE_KEY, JSON.stringify(map || {})); } catch {}
        }

        function getSelectedReminder() {
            if (!selectedFund?.code) return null;
            const all = loadReminders();
            const r = all[selectedFund.code];
            if (!r || !r.time || typeof r.time !== 'string') return null;
            if (!/^\d{2}:\d{2}$/.test(r.time)) return null;
            return r;
        }

        function loadLastFiredReminder() {
            try {
                const raw = localStorage.getItem(LAST_FIRED_REMINDER_KEY);
                const obj = raw ? JSON.parse(raw) : null;
                return (obj && typeof obj === 'object') ? obj : null;
            } catch {
                return null;
            }
        }

        function saveLastFiredReminder(data) {
            try { localStorage.setItem(LAST_FIRED_REMINDER_KEY, JSON.stringify(data || null)); } catch {}
        }

        function updateLastFiredReminderHint() {
            const el = document.getElementById('remindFiredHint');
            if (!el) return;
            const last = loadLastFiredReminder();
            if (lastFiredHintTimer) { clearInterval(lastFiredHintTimer); lastFiredHintTimer = null; }
            lastFiredHintIndex = 0;
            if (!last || !last.date || (!Array.isArray(last.items) && (!last.code || !last.time))) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (last.date !== todayStr) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const items0 = Array.isArray(last.items) ? last.items : [{ code: last.code, name: last.name, time: last.time }];
            const items = items0
                .filter(x => x && x.code && x.time)
                .map(x => ({ code: x.code, name: x.name || x.code, time: x.time }));
            const visibleItems = selectedFund?.code ? items.filter(x => x.code !== selectedFund.code) : items;
            if (visibleItems.length === 0) {
                el.innerHTML = '';
                el.classList.remove('show');
                return;
            }
            const listHtml = visibleItems
                .concat(visibleItems.length > 1 ? [visibleItems[0]] : [])
                .map(x => `<div class="rfh-item" data-code="${x.code}">æœ€è¿‘æé†’ï¼š${x.name}ï¼ˆ${x.code}ï¼‰${x.time}</div>`)
                .join('');
            el.innerHTML = `<span class="rfh-viewport"><span class="rfh-inner">${listHtml}</span></span>`;
            el.classList.add('show');

            if (visibleItems.length > 1) {
                const inner = el.querySelector('.rfh-inner');
                const itemH = 18;
                const count = visibleItems.length;
                lastFiredHintTimer = setInterval(() => {
                    lastFiredHintIndex++;
                    if (!inner) return;
                    inner.style.transition = 'transform 0.35s ease';
                    inner.style.transform = `translateY(${-lastFiredHintIndex * itemH}px)`;
                    if (lastFiredHintIndex === count) {
                        setTimeout(() => {
                            if (!inner) return;
                            inner.style.transition = 'none';
                            inner.style.transform = 'translateY(0px)';
                            lastFiredHintIndex = 0;
                        }, 380);
                    }
                }, 2200);
            }
        }

        function jumpToLastFiredReminder(e) {
            e?.stopPropagation?.();
            const code = e?.target?.closest?.('[data-code]')?.getAttribute?.('data-code');
            const targetCode = code || loadLastFiredReminder()?.code;
            if (!targetCode) return;
            const target = funds.find(f => f.code === targetCode);
            if (target) selectFund(target);
        }

        function updateReminderBadge() {
            const el = document.getElementById('remindChip');
            if (!el) return;
            // è§¦å‘æé†’åçš„ 1 åˆ†é’ŸæŠ¥è­¦æ€ç”± fireReminder æ§åˆ¶ï¼Œé¿å…è¢«åˆ·æ–°é€»è¾‘è¦†ç›–
            if (el.classList.contains('alert')) return;
            const r = getSelectedReminder();
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (r) {
                el.classList.remove('alert');
                if (hasFiredTodayForThisTime(r, todayStr)) {
                    el.classList.remove('active');
                    el.classList.add('fired');
                    el.textContent = `â° å·²æé†’ ${r.time}`;
                } else {
                    el.classList.remove('fired');
                    el.classList.add('active');
                    el.textContent = `â° ${r.time}`;
                }
            } else {
                el.classList.remove('active');
                el.classList.remove('fired');
                el.classList.remove('alert');
                el.classList.remove('ring');
                el.textContent = 'æé†’';
            }
        }

        function hasFiredTodayForThisTime(r, todayStr) {
            if (!r) return false;
            if (r.lastFiredDate !== todayStr) return false;
            // å…¼å®¹æ—§æ•°æ®ï¼šè‹¥æ²¡æœ‰ lastFiredTimeï¼Œåˆ™è§†ä¸ºå½“æ—¥å·²æé†’ï¼ˆä½†ä¿®æ”¹æ—¶é—´æ—¶ä¼šæ¸…ç©º lastFiredDateï¼‰
            if (!r.lastFiredTime) return true;
            return r.lastFiredTime === r.time;
        }

        function getReminderTargetMin(r) {
            if (!r?.time || typeof r.time !== 'string') return null;
            const m = r.time.match(/^(\d{2}):(\d{2})$/);
            if (!m) return null;
            const hh = parseInt(m[1], 10);
            const mm = parseInt(m[2], 10);
            if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
            return hh * 60 + mm;
        }

        function getShanghaiDateStrOffset(days) {
            const sh = getShanghaiTimeParts();
            const d = new Date(Date.UTC(sh.year, sh.month - 1, sh.day + (days || 0)));
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth() + 1).padStart(2, '0');
            const dd = String(d.getUTCDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        function checkReminderDue() {
            const r = getSelectedReminder();
            if (!r || !selectedFund?.code) return false;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (hasFiredTodayForThisTime(r, todayStr)) return false;
            const targetMin = getReminderTargetMin(r);
            if (!Number.isFinite(targetMin)) return false;
            const nowMin = sh.hour * 60 + sh.minute;
            // åªåœ¨åˆ°ç‚¹è¿™ä¸€åˆ†é’Ÿè§¦å‘ï¼›è‹¥è®¾ç½®æ—¶é—´æ—©äºå½“å‰æ—¶é—´ï¼Œåˆ™è§†ä¸ºä¸‹ä¸€å¤©ï¼ˆä¸ç«‹åˆ»è¡¥è§¦å‘ï¼‰
            if (nowMin === targetMin) return true;
            return false;
        }

        function openReminderPrompt(e) {
            e?.stopPropagation?.();
            if (!selectedFund?.code) return;
            const r = getSelectedReminder();
            const current = r?.time || '';
            const input = prompt('è®¾ç½®æé†’æ—¶é—´(HH:MM)ï¼Œç•™ç©ºå–æ¶ˆ', current || '14:55');
            if (input === null) return;
            const all = loadReminders();
            const v = (input || '').trim();
            if (!v) {
                delete all[selectedFund.code];
                saveReminders(all);
                updateReminderBadge();
                rescheduleReminder();
                showToast(`${selectedFund.name || selectedFund.code} å·²å–æ¶ˆæé†’`);
                return;
            }
            if (!/^\d{1,2}:\d{2}$/.test(v)) {
                alert('æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥ HH:MMï¼Œä¾‹å¦‚ 14:55');
                return;
            }
            const [hhRaw, mmRaw] = v.split(':');
            const hh = String(Math.min(23, Math.max(0, parseInt(hhRaw, 10)))).padStart(2,'0');
            const mm = String(Math.min(59, Math.max(0, parseInt(mmRaw, 10)))).padStart(2,'0');
            const nextTime = `${hh}:${mm}`;
            const prev = all[selectedFund.code];
            const prevTime = prev?.time || null;
            const keepFired = prevTime && prevTime === nextTime;
            all[selectedFund.code] = {
                time: nextTime,
                lastFiredDate: keepFired ? (prev?.lastFiredDate || null) : null,
                lastFiredTime: keepFired ? (prev?.lastFiredTime || prevTime || null) : null
            };
            saveReminders(all);
            updateReminderBadge();
            rescheduleReminder();
            showToast(`${selectedFund.name || selectedFund.code} å·²è®¾ç½®æé†’ ${hh}:${mm}`);
        }

        function rescheduleReminder() {
            // è¯´æ˜ï¼šè¯¥å‡½æ•°ä¼šåœ¨åˆ·æ–°å¾ªç¯ä¸­è¢«é¢‘ç¹è°ƒç”¨ã€‚
            // è‹¥æ¯æ¬¡éƒ½ clearTimeout + é‡è®¾ï¼Œä¼šåœ¨ä¸´ç•Œ 1 åˆ†é’Ÿå†…ä¸æ–­æ”¹å†™å®šæ—¶å™¨ï¼Œæç«¯æƒ…å†µä¸‹ä¼šé”™è¿‡è§¦å‘ã€‚
            const r = getSelectedReminder();
            if (!r) return;

            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            if (hasFiredTodayForThisTime(r, todayStr)) return;

            // è‹¥å·²åˆ°ç‚¹/è¿‡ç‚¹ï¼Œç«‹åˆ»è¡¥è§¦å‘ä¸€æ¬¡ï¼ˆä¿®å¤â€œè®¾ç½®äº†ä½†æ²¡æé†’/å·²è¿‡ç‚¹ä»æ˜¾ç¤ºå·²è®¾ç½®â€ï¼‰
            if (checkReminderDue()) {
                // æ³¨æ„ï¼šé¡µé¢å¯èƒ½åœ¨è½®è¯¢åˆ·æ–°æ—¶é¢‘ç¹è°ƒç”¨ rescheduleReminderï¼Œè‹¥ä½¿ç”¨çŸ­ setTimeout ä¼šè¢«ä¸æ–­ clearTimeout å¯¼è‡´æ°¸ä¸è§¦å‘
                // è¿™é‡Œç›´æ¥è§¦å‘ï¼Œç”± lastFiredDate/lastFiredTime è´Ÿè´£é˜²é‡
                fireReminder();
                return;
            }

            const [hh, mm] = r.time.split(':').map(x => parseInt(x, 10));
            const sh2 = getShanghaiTimeParts();
            const nowMin = sh2.hour * 60 + sh2.minute;
            const targetMin = hh * 60 + mm;
            let minutesLeft = targetMin - nowMin;
            const targetOffsetDays = minutesLeft < 0 ? 1 : 0;
            if (minutesLeft < 0) minutesLeft += 1440;
            const targetDateStr = getShanghaiDateStrOffset(targetOffsetDays);
            const scheduleKey = `${selectedFund.code}|${r.time}|${targetDateStr}`;

            // å¦‚æœå½“å‰å·²æœ‰åŒä¸€ä¸ª scheduleKey çš„è®¡æ—¶å™¨ï¼Œå°±ä¸è¦é‡å¤ clear/re-schedule
            if (reminderTimer && reminderScheduleKey === scheduleKey && Number.isFinite(reminderNextAtMs)) {
                return;
            }
            if (reminderTimer) { clearTimeout(reminderTimer); reminderTimer = null; }

            // è‹¥å·²ç»è¿›å…¥ç›®æ ‡åˆ†é’Ÿï¼ˆå¯èƒ½ seconds ä¸åŒï¼‰ï¼Œç›´æ¥è§¦å‘
            if (minutesLeft === 0) {
                reminderScheduleKey = scheduleKey;
                reminderNextAtMs = Date.now();
                fireReminder();
                return;
            }

            const delay = Math.max(200, minutesLeft * 60000 - ((sh2.second || 0) * 1000));
            reminderScheduleKey = scheduleKey;
            reminderNextAtMs = Date.now() + delay;
            reminderTimer = setTimeout(() => fireReminder(), delay);
        }

        async function fireReminder() {
            const r = getSelectedReminder();
            if (!r || !selectedFund?.code) return;
            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            // é˜²æŠ–ï¼šæœªåˆ°ç›®æ ‡æ—¶é—´ä¸è§¦å‘ï¼ˆä¿®å¤ 15:39 è®¾ç½® 15:40 å´æå‰è§¦å‘ï¼‰
            const targetMin = getReminderTargetMin(r);
            const nowMin = sh.hour * 60 + sh.minute;
            if (Number.isFinite(targetMin) && nowMin < targetMin) {
                rescheduleReminder();
                return;
            }
            const all = loadReminders();
            const curr = all[selectedFund.code];
            if (curr) {
                curr.lastFiredDate = todayStr;
                curr.lastFiredTime = r.time;
                all[selectedFund.code] = curr;
                saveReminders(all);
            }

            const prevLast = loadLastFiredReminder();
            const prevItems0 = (prevLast && Array.isArray(prevLast.items))
                ? prevLast.items
                : (prevLast && prevLast.code && prevLast.time ? [{ code: prevLast.code, name: prevLast.name, time: prevLast.time }] : []);
            const sameBucket = prevLast && prevLast.date === todayStr && prevLast.time === r.time;
            const nextItems = (sameBucket ? prevItems0.slice() : []);
            const idx = nextItems.findIndex(x => x && x.code === selectedFund.code);
            const nextItem = { code: selectedFund.code, name: selectedFund.name || selectedFund.code, time: r.time };
            if (idx >= 0) nextItems[idx] = nextItem; else nextItems.push(nextItem);
            saveLastFiredReminder({ date: todayStr, time: r.time, items: nextItems });
            updateLastFiredReminderHint();

            const title = 'FundFlow æé†’';
            const body = `${selectedFund.name || selectedFund.code}ï¼ˆ${r.time}ï¼‰è¯·å…³æ³¨ç›˜ä¸­å˜åŒ–`;
            try {
                if ('Notification' in window) {
                    if (Notification.permission === 'granted') {
                        new Notification(title, { body });
                    } else if (Notification.permission !== 'denied') {
                        const p = await Notification.requestPermission();
                        if (p === 'granted') new Notification(title, { body });
                    } else {
                        // denied: do nothing
                    }
                }
            } catch {
                // ignore
            }
            const chip = document.getElementById('remindChip');
            if (chip) {
                chip.classList.add('alert');
                chip.classList.add('ring');
                chip.classList.remove('active');
                chip.classList.remove('fired');
                chip.textContent = `â° ${r.time}`;
                setTimeout(() => {
                    chip.classList.remove('alert');
                    chip.classList.remove('ring');
                    updateReminderBadge();
                }, 60000);
            }
            showToast(body, 'error', 60000, true);
            // æŠ¥è­¦æ€ä¸‹ä¸æ›´æ–° badgeï¼Œé¿å…ç«‹åˆ»å˜æˆâ€œå·²æé†’â€è€Œçœ‹ä¸åˆ°çº¢è‰²æç¤º
            rescheduleReminder();
        }

        // ============================================================
        // æ—¥æ¶¨è·Œå¹…æ¸²æŸ“ â€” å¼€ç›˜ä¸­ç”¨æŒä»“åŠ æƒä¼°ç®—ï¼Œæœªå¼€ç›˜ç”¨å®˜æ–¹æ•°æ®
        // ============================================================
        function updateDayGrowthDisplay(fund) {
            const el = document.getElementById('dayGrowth');
            const chgEl = document.getElementById('dayGrowthChange');
            const status = getMarketStatus();
            const cache = holdingsCache[fund.code];

            const sh = getShanghaiTimeParts();
            const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
            const navDateStr = getDateStr(fund.navDate);
            const estDateStr = getDateStr(fund.estimatedTime);
            const fundgzEst = parseFloat((fund._fundgzDayGrowth !== undefined && fund._fundgzDayGrowth !== null) ? fund._fundgzDayGrowth : fund.dayGrowth);
            const hasFundgzToday = (estDateStr === todayStr) && Number.isFinite(fundgzEst);

            // å¤œé—´å®˜æ–¹å‡€å€¼å·²æ›´æ–°ï¼šå¼ºåˆ¶å±•ç¤ºå®˜æ–¹å£å¾„ï¼ˆå¹¶æ ‡æ³¨æ—¥æœŸæ—¶é—´ï¼‰
            if (navDateStr === todayStr) {
                const off = getOfficialDayGrowthFromHistory(fund);
                if (Number.isFinite(off)) {
                    if (Number.isFinite(off)) fund.dayGrowth = off;
                    el.innerHTML = (off >= 0 ? '+' : '') + off.toFixed(2) + '%';
                    el.className = `stat-value ${off >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        const offDate = navDateStr ? navDateStr.slice(5) : '';
                        chgEl.innerHTML = `å½“æ—¥æ¶¨å¹…${offDate ? ' ' + offDate + ' 15:00' : ''} <span class="day-growth-source official">å®˜æ–¹</span>`;
                    }
                    return;
                }
            }

            // ä½¿ç”¨ä¼°ç®—æ¡ä»¶:
            //   å¸‚åœºæ­£åœ¨äº¤æ˜“ æˆ– åˆé—´ä¼‘å¸‚ï¼ˆä¸Šåˆå·²æœ‰æ•°æ®ï¼‰
            //   ä¸” holdingsCache ä¸­æœ‰æ–°é²œæ•°æ®ï¼ˆ< 5åˆ†é’Ÿï¼‰
            const cacheAge = cache ? (Date.now() - cache.timestamp) : Infinity;
            const useHoldingsEstimation = (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚') 
                                          && cache 
                                          && cacheAge < 300000;
            const useEstimation = useHoldingsEstimation || (navDateStr !== todayStr && hasFundgzToday);

            if (useEstimation) {
                if (useHoldingsEstimation) {
                    const est = cache.estDayChg;
                    if (Number.isFinite(est)) fund.dayGrowth = est;
                    el.innerHTML = (est >= 0 ? '+' : '') + est.toFixed(2) + '%';
                    el.className = `stat-value ${est >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        chgEl.innerHTML = `TOP10æƒé‡ ${cache.top10Weight.toFixed(2)}% <span class="day-growth-source est">ä¼°ç®—</span>`;
                    }
                } else {
                    const est = fundgzEst;
                    if (Number.isFinite(est)) fund.dayGrowth = est;
                    el.innerHTML = (est >= 0 ? '+' : '') + est.toFixed(2) + '%';
                    el.className = `stat-value ${est >= 0 ? 'positive' : 'negative'}`;
                    if (chgEl) {
                        const t = (fund.estimatedTime && typeof fund.estimatedTime === 'string') ? (fund.estimatedTime.match(/\b\d{1,2}:\d{2}\b/)?.[0] || '') : '';
                        chgEl.innerHTML = `ä»Šæ—¥ä¼°ç®—${t ? ' ' + t : ''} <span class="day-growth-source est">ä¼°ç®—</span>`;
                    }
                }
            } else {
                // â”€â”€ æœªå¼€ç›˜ / ç¼“å­˜è¿‡æœŸ: æ˜¾ç¤ºå®˜æ–¹æ—¥æ¶¨è·Œï¼ˆå†å²å‡€å€¼å£å¾„ï¼‰ â”€â”€
                const dg = getDisplayDayGrowth(fund);
                // éäº¤æ˜“æ—¶ä¹Ÿä¿æŒ dayGrowth ä¸å±•ç¤ºä¸€è‡´ï¼ˆé¿å…å·¦ä¾§/å³ä¾§ä¸åŒæ­¥ï¼‰
                if (Number.isFinite(dg)) fund.dayGrowth = dg;
                el.innerHTML = !isNaN(dg) ? (dg >= 0 ? '+' : '') + dg.toFixed(2) + '%' : '--';
                el.className = `stat-value ${!isNaN(dg) && dg >= 0 ? 'positive' : 'negative'}`;
                if (chgEl) {
                    const offDate = navDateStr ? navDateStr.slice(5) : '';
                    chgEl.innerHTML = !isNaN(dg)
                        ? `å½“æ—¥æ¶¨å¹…${offDate ? ' ' + offDate + ' 15:00' : ''} <span class="day-growth-source official">å®˜æ–¹</span>`
                        : '--';
                }
            }
        }

        function getRealtimeMinuteIndex() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (min < 570) return -1;
            if (min <= 690) return min - 570;
            if (min < 780) return -1;
            if (min <= 900) return 121 + (min - 780);
            return -1;
        }

        function getRealtimeMinuteIndexFromGzTime(gztime) {
            if (!gztime || typeof gztime !== 'string') return -1;
            const m = gztime.match(/\b(\d{1,2}):(\d{2})\b/);
            if (!m) return -1;
            const hour = parseInt(m[1]);
            const minute = parseInt(m[2]);
            if (!Number.isFinite(hour) || !Number.isFinite(minute)) return -1;
            const min = hour * 60 + minute;
            if (min < 570) return -1;
            if (min <= 690) return min - 570;
            if (min < 780) return -1;
            if (min <= 900) return 121 + (min - 780);
            return -1;
        }

        function getRealtimeEndIndex() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (t.dow === 0 || t.dow === 6) return -1;
            // ç›˜å‰
            if (min < 570) return -1;
            // ä¸Šåˆ 09:30 - 11:30
            if (min <= 690) return min - 570;
            // åˆä¼‘ï¼šå›ºå®šåˆ° 11:30
            if (min < 780) return 120;
            // ä¸‹åˆ 13:00 - 15:00
            if (min <= 900) return 121 + (min - 780);
            // ç›˜åï¼šå›ºå®šåˆ° 15:00
            return 241;
        }

        function updateMarketStatusUI() {
            const s = getMarketStatus();
            const el = document.getElementById('marketStatus');
            el.className = `market-status ${s.isOpen?'open':'closed'}`;
            const displayReason = (s.reason === 'ç›˜åè¡¥å…¨') ? 'ç›˜å' : s.reason;
            el.innerHTML = `<span>${s.isOpen?'â–¶':'â¸'}</span><span>${s.isOpen?'äº¤æ˜“ä¸­':displayReason}</span>`;
        }

        function getMarketStatus() {
            const t = getShanghaiTimeParts();
            const min = t.hour * 60 + t.minute;
            if (t.dow === 0 || t.dow === 6) return { isOpen: false, reason: 'å‘¨æœ«ä¼‘å¸‚', canRealtimeUpdate: false };
            if ((min >= 570 && min < 690) || (min >= 780 && min < 900)) return { isOpen: true, reason: 'äº¤æ˜“ä¸­', canRealtimeUpdate: true };
            // ç›˜åè¡¥å…¨æœŸï¼š15:00 åæ•°æ®æºå¯èƒ½ä»åœ¨è¡¥æœ€åå‡ åˆ†é’Ÿï¼ˆä¾‹å¦‚ 14:55 æ‰åˆ°ï¼‰ï¼Œå…è®¸çŸ­æ—¶é—´ç»§ç»­æ‹‰å–ä¼°å€¼
            if (min >= 900 && min < 915) return { isOpen: false, reason: 'ç›˜åè¡¥å…¨', canRealtimeUpdate: true };
            return { isOpen: false, reason: min < 570 ? 'ç›˜å‰' : (min >= 900 ? 'ç›˜å' : 'åˆé—´ä¼‘å¸‚'), canRealtimeUpdate: false };
        }

        function saveFunds() { localStorage.setItem('funds', JSON.stringify(funds)); }

        function getFundBuyInfo(fund) {
            const amount = Number(fund?.buyAmount);
            const date = (fund?.buyDate || '').toString();
            if (!Number.isFinite(amount) || amount <= 0 || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                return { amount: null, date: null };
            }
            return { amount, date };
        }

        function getFirstHistoryPointOnOrAfter(code, dateStr) {
            const all = historyCache[code];
            if (!Array.isArray(all) || all.length === 0 || !dateStr) return null;
            for (let i = 0; i < all.length; i++) {
                const d = tsToDateStr(all[i].x);
                if (d >= dateStr) return { i, x: all[i].x, y: Number(all[i].y), date: d };
            }
            return null;
        }

        function getHistoryPointByDate(code, dateStr) {
            const all = historyCache[code];
            if (!Array.isArray(all) || all.length === 0 || !dateStr) return null;
            for (let i = all.length - 1; i >= 0; i--) {
                const d = tsToDateStr(all[i].x);
                if (d === dateStr) return { i, x: all[i].x, y: Number(all[i].y), date: d };
                if (d < dateStr) break;
            }
            return null;
        }

        function getPrevHistoryPoint(code, dateStr) {
            const p = getHistoryPointByDate(code, dateStr);
            if (!p) return null;
            const all = historyCache[code];
            const i = p.i - 1;
            if (!Array.isArray(all) || i < 0) return null;
            return { i, x: all[i].x, y: Number(all[i].y), date: tsToDateStr(all[i].x) };
        }

        function getPositionFromBuy(fund) {
            const buy = getFundBuyInfo(fund);
            if (!buy.amount || !buy.date) return { has: false };
            const buyPoint = getFirstHistoryPointOnOrAfter(fund.code, buy.date);
            const buyNav = buyPoint ? Number(buyPoint.y) : NaN;
            if (!Number.isFinite(buyNav) || buyNav <= 0) return { has: false };
            const shares = buy.amount / buyNav;
            if (!Number.isFinite(shares) || shares <= 0) return { has: false };
            return { has: true, amount: buy.amount, buyDate: buy.date, buyNav, shares };
        }

        function getPositionFromLegacy(fund) {
            const cost = Number(fund?.holdingCost);
            const shares = Number(fund?.holdingShares);
            if (!Number.isFinite(cost) || cost <= 0 || !Number.isFinite(shares) || shares <= 0) return { has: false };
            const amount = cost * shares;
            return { has: true, amount, buyDate: null, buyNav: cost, shares };
        }

        function getPosition(fund) {
            const p = getPositionFromBuy(fund);
            if (p.has) return p;
            return getPositionFromLegacy(fund);
        }

        function calcPositionMetrics(pos, nav) {
            if (!pos || !pos.has || !Number.isFinite(nav) || nav <= 0) return { ok: false };
            const invested = Number(pos.amount);
            const buyNav = Number(pos.buyNav);
            const shares = Number(pos.shares);
            if (!Number.isFinite(invested) || invested <= 0 || !Number.isFinite(buyNav) || buyNav <= 0) return { ok: false };

            // å¤åˆ©å£å¾„ï¼šå¸‚å€¼éšå‡€å€¼æ¯”ä¾‹å˜åŒ–ï¼ˆç­‰ä»·äº shares*navï¼‰
            const value = invested * (nav / buyNav);
            const profit = value - invested;
            const profitPct = invested ? (profit / invested * 100) : NaN;
            return { ok: true, invested, value, profit, profitPct };
        }

        function updateAllPositionSummary() {
            const amountEl = document.getElementById('allPositionAmount');
            const profitEl = document.getElementById('allPositionProfit');
            if (!amountEl || !profitEl) return;

            amountEl.className = '';
            profitEl.className = '';
            amountEl.style.color = 'rgba(255,255,255,0.95)';
            profitEl.style.color = 'rgba(255,255,255,0.95)';

            let totalValue = 0;
            let totalProfit = 0;
            let hasAny = false;

            for (const f of funds) {
                const pos = getPosition(f);
                if (!pos.has) continue;
                const shProfit = getShanghaiTimeParts();
                const todayProfitStr = `${shProfit.year}-${String(shProfit.month).padStart(2,'0')}-${String(shProfit.day).padStart(2,'0')}`;
                const navDateProfitStr = getDateStr(f.navDate);
                const officialNav0 = parseFloat(f.currentNav);
                const dispNav0 = parseFloat(getDisplayNav(f));
                const nav = (navDateProfitStr === todayProfitStr && Number.isFinite(officialNav0)) ? officialNav0 : dispNav0;
                if (!Number.isFinite(nav)) continue;
                hasAny = true;
                const m = calcPositionMetrics(pos, nav);
                if (!m.ok) continue;
                totalValue += m.value;
                totalProfit += m.profit;
            }

            if (!hasAny) {
                amountEl.textContent = '--';
                profitEl.textContent = '--';
                return;
            }

            amountEl.textContent = 'Â¥' + totalValue.toFixed(2);
            profitEl.textContent = 'Â¥' + totalProfit.toFixed(2);
        }
        
        async function addFund() {
            const code = document.getElementById('fundCode').value.trim();
            if (!/^\d{6}$/.test(code)) return showToast('è¯·è¾“å…¥6ä½æ•°å­—åŸºé‡‘ä»£ç ', 'error');
            if (funds.some(f => f.code === code)) return showToast('è¯¥åŸºé‡‘å·²å­˜åœ¨', 'error');
            const buyAmount = parseFloat(document.getElementById('buyAmount').value);
            const buyDate = (document.getElementById('buyDate').value || '').trim();
            const fund = { code, buyAmount: Number.isFinite(buyAmount) && buyAmount > 0 ? buyAmount : null, buyDate: buyDate !== '' ? buyDate : null, name: 'åŠ è½½ä¸­...', currentNav: '--', dayGrowth: '--' };
            funds.push(fund); saveFunds(); renderFundList();
            document.getElementById('fundCode').value = ''; document.getElementById('buyAmount').value = ''; document.getElementById('buyDate').value = '';
            await fetchFundData(fund); showToast('æ·»åŠ æˆåŠŸ');
            if (window.innerWidth <= 768) { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); }
        }
        
        function deleteFund(code) {
            if (!confirm('ç¡®è®¤åˆ é™¤è¯¥åŸºé‡‘ï¼Ÿ')) return;
            funds = funds.filter(f => f.code !== code); saveFunds();
            if (miniCharts[code]) { miniCharts[code].dispose(); delete miniCharts[code]; }
            if (selectedFund?.code === code) selectedFund = funds[0] || null;
            renderFundList(); if(selectedFund) selectFund(selectedFund);
        }

        function selectFund(fund) {
            selectedFund = fund; renderFundList(); updateMainDisplay(fund); loadHoldingsAndSectors(fund);
            fetchHistoryData(fund.code, currentTimeRange !== 'realtime');
            if (currentTimeRange === 'realtime') { updateRealtimeChart(); startRealtimeUpdate(); }
            if (window.innerWidth <= 768) { mobileMenuBtn.classList.remove('active'); sidebar.classList.remove('open'); sidebarOverlay.classList.remove('active'); }
        }

        function getSecId(code) {
            if (!code) return "";
            // è¿‡æ»¤æ‰å¯èƒ½å­˜åœ¨çš„å­—æ¯å‰ç¼€ï¼ˆå¦‚ sh601228 æå–ä¸º 601228ï¼‰
            let pureCode = String(code).match(/\d{6}/);
            if (pureCode) {
                return pureCode[0];
            }
            return String(code).trim().substring(0, 6);
        }

        function getEastmoneySecId(code) {
            const c = getSecId(code);
            if (!/^\d{6}$/.test(c)) return c;
            // ä¸Šäº¤æ‰€: 6xxxxx / æ·±äº¤æ‰€&åŒ—äº¤æ‰€ç­‰: 0xxxxx/3xxxxx/8xxxxx...
            return (c.startsWith('6') ? `1.${c}` : `0.${c}`);
        }

        function openStockDetail(code) {
            if (!code) return;
            const stockCode = getSecId(code);
            if (!/^\d{6}$/.test(stockCode)) {
                console.warn("è‚¡ç¥¨ä»£ç æ ¼å¼éæ³•:", stockCode);
                return;
            }
            // æ„å»ºç™¾åº¦å°ç¨‹åºé“¾æ¥
            const url = `https://pqa9p2.smartapps.baidu.com/pages/quote/quote?code=${stockCode}`;
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        function normalizeStockChg(chg, status) {
            const v = (typeof chg === 'number') ? chg : Number(chg);
            if (!Number.isFinite(v)) return 0;
            // ç›˜å‰/å‘¨æœ«ï¼šæ¶¨è·Œå¹…æ²¡æœ‰æ„ä¹‰
            // ç›˜åï¼šä»åº”å±•ç¤ºæ”¶ç›˜æ¶¨è·Œå¹…ï¼ˆæ¥å£è¿”å›çš„æ˜¯å½“æ—¥æ”¶ç›˜å£å¾„ï¼‰ï¼Œä¸è¦å½’é›¶
            if (status && status.canRealtimeUpdate === false) {
                const reason = status.reason;
                if (reason === 'ç›˜å‰' || reason === 'å‘¨æœ«ä¼‘å¸‚') return 0;
            }
            // é˜²å¾¡ï¼šä¸œè´¢éƒ¨åˆ†åœºæ™¯ä¼šè¿”å› -100 ä½œä¸ºç¼ºå¤±å€¼
            if (Math.abs(v) >= 99.99) return 0;
            return v;
        }

        // ============================================================
        // æŒä»“åŠ è½½ - å« gushitong.baidu.com æ–°æ•°æ®æºï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        // ============================================================
        async function loadHoldingsAndSectors(fund, options = {}) {
            const tbody = document.getElementById('holdingsTableBody');
            const tags = document.getElementById('sectorTags');
            const status0 = getMarketStatus();

            // updateOnly: åªæ›´æ–°æ¶¨è·Œå¹…ï¼Œä¸è¦é‡ç»˜ DOMï¼ˆé¿å…é—ªè·³ï¼‰
            if (options.updateOnly) {
                await updateHoldingsChgOnly(fund);
                return;
            }

            // silent: å·²ç»æœ‰å†…å®¹æ—¶ä¸è¦å†™â€œåŠ è½½ä¸­...â€è¦†ç›–é€ æˆé—ªè·³
            if (!options.silent) {
                if (tbody) tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">åŠ è½½ä¸­...</td></tr>`;
                if (tags) tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">åŠ è½½ä¸­...</span>`;
            }

            // --- æ•°æ®æº1 (ä¼˜å…ˆ): gushitong.baidu.com â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            // è¿”å›çš„JSONç»“æ„:
            //   Result[0].DisplayData.resultData.tplData.result.content.tabs[0 (æŒä»“tab)]
            //     .content.heavyStock.body[]  â†’ TOP 10 æŒä»“è‚¡ç¥¨
            //     .content.industryPositon.list[] â†’ è¡Œä¸šæ¿å—å æ¯”
            const baiduTargetUrl = `https://gushitong.baidu.com/opendata?resource_id=5803&query=${fund.code}&new_need_di=1&source=qieman`;
            const baiduProxyOff = (localStorage.getItem('BAIDU_PROXY_OFF') || '') === '1';
            const baiduCorsProxy = ((localStorage.getItem('BAIDU_CORS_PROXY') || '').trim() || 'https://api.allorigins.win/get?url=');
            const baiduAllowDirect = (localStorage.getItem('BAIDU_DIRECT') || '') === '1';

            async function fetchBaiduViaProxy(targetUrl, proxyPrefix) {
                const proxyUrl = `${proxyPrefix}${encodeURIComponent(targetUrl)}`;
                const res = await fetch(proxyUrl, { signal: AbortSignal.timeout(12000) });
                if (!res.ok) throw new Error(`proxy http ${res.status}`);
                let payload;
                try {
                    payload = await res.json();
                } catch {
                    const text = await res.text();
                    payload = JSON.parse(text);
                }
                const raw = payload && typeof payload === 'object' && typeof payload.contents === 'string'
                    ? payload.contents
                    : payload;
                if (typeof raw === 'string') return JSON.parse(raw);
                return raw;
            }

            const baiduSources = [];
            // ç›´è¿æ–¹æ¡ˆï¼šè‹¥ç™¾åº¦æ¥å£æ”¯æŒ JSONPï¼ˆcb/callbackï¼‰ï¼Œå¯ç»•è¿‡ CORS ä¸”æ›´å¿«
            // æ³¨æ„ï¼šå¦‚æœæ¥å£ä¸æ”¯æŒ JSONPï¼Œè¿™é‡Œä¼šå¾ˆå¿«è¶…æ—¶å¹¶è‡ªåŠ¨å›é€€åˆ°ä»£ç†/ä¸œè´¢å¤‡ç”¨æº
            baiduSources.push({
                name: 'gushitong_jsonp',
                fetch: async () => {
                    try {
                        return await fetchJsonp(baiduTargetUrl, 'cb', 2500);
                    } catch {
                        return await fetchJsonp(baiduTargetUrl, 'callback', 2500);
                    }
                }
            });
            if (!baiduProxyOff && baiduCorsProxy) {
                baiduSources.push({
                    name: 'gushitong_proxy',
                    fetch: async () => await fetchBaiduViaProxy(baiduTargetUrl, baiduCorsProxy)
                });
            }
            if (baiduAllowDirect) {
                baiduSources.push({
                    name: 'gushitong_direct',
                    fetch: async () => {
                        const res = await fetch(baiduTargetUrl, { signal: AbortSignal.timeout(10000) });
                        return await res.json();
                    }
                });
            }

            let baiduData = null; // è§£æåçš„ç»“æ„åŒ–æ•°æ®: { holdings: [...], sectors: [...] }

            for (const source of baiduSources) {
                try {
                    console.log(`ğŸ”„ [æŒä»“-${source.name}] å°è¯•è·å–...`);
                    const json = await runWithSourceStat(`holdings_${source.name}`, async () => await source.fetch());

                    // æ·±å±‚è§£æè·¯å¾„
                    const result = json?.Result?.[0];
                    const tplData = result?.DisplayData?.resultData?.tplData?.result;
                    const tabs = tplData?.content?.tabs;

                    // tabs[0] æ˜¯ "æŒä»“" tab (type: "position")
                    const positionTab = tabs?.find(t => t.type === 'position') || tabs?.[0];
                    const posContent = positionTab?.content;

                    // heavyStock.body â†’ TOP 10 è‚¡ç¥¨
                    const heavyStockBody = posContent?.heavyStock?.body;
                    // industryPositon.list â†’ è¡Œä¸šæ¿å—
                    const industryList = posContent?.industryPositon?.list;
                    // heavyStock æ›´æ–°æ—¥æœŸ
                    const holdingDate = posContent?.heavyStock?.titleHeader?.[1] || '';

                    if (!heavyStockBody || heavyStockBody.length === 0) {
                        throw new Error('heavyStock.body ä¸ºç©º');
                    }

                    // æ˜ å°„æŒä»“æ•°æ®
                    const holdings = heavyStockBody.map(item => ({
                        name: item.name,                          // è‚¡ç¥¨åç§°
                        code: item.code,                          // è‚¡ç¥¨ä»£ç 
                        ratio: parseFloat(item.positionProportion?.replace('%', '')) || 0  // å å‡€å€¼æ¯”ä¾‹
                    }));

                    // æ˜ å°„è¡Œä¸šæ¿å—æ•°æ®
                    const sectors = (industryList || []).map(item => ({
                        name: item.text,                          // è¡Œä¸šåç§°
                        weight: parseFloat(item.value?.replace('%', '')) || 0  // å æ¯”
                    }));

                    baiduData = { holdings, sectors, holdingDate };
                    console.log(`âœ… [æŒä»“-${source.name}] æˆåŠŸ! æŒä»“${holdings.length}æ¡, æ¿å—${sectors.length}æ¡, æ—¥æœŸ: ${holdingDate}`);
                    break;

                } catch (error) {
                    console.warn(`âŒ [æŒä»“-${source.name}] å¤±è´¥:`, error.message);
                    continue;
                }
            }

            // --- æ•°æ®æº2 (å¤‡ç”¨): eastmoney HTML çˆ¬å– â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            if (!baiduData) {
                console.log('âš ï¸ Baiduæ•°æ®æºå…¨éƒ¨å¤±è´¥ï¼Œå°è¯•eastmoneyå¤‡ç”¨æº...');
                try {
                    const url = `https://fundf10.eastmoney.com/FundArchivesDatas.aspx?type=jjcc&topline=10&code=${fund.code}&year=&month=&rt=${Date.now()}`;
                    const apidata = await fetchApidataViaScript(url, 'holdings_eastmoney_apidata');
                    const html = (apidata?.content || '').toString().replace(/\\r\\n/g, '').replace(/\\n/g, '').replace(/\\t/g, '').replace(/\\\//g, '/').replace(/\\\"/g, '"');
                    const doc = new DOMParser().parseFromString(html, 'text/html');
                    const tables = Array.from(doc.querySelectorAll('table'));
                    const table = tables.find(t => {
                        const thText = (t.querySelector('thead')?.textContent || t.textContent || '').replace(/\s+/g, '');
                        return thText.includes('è‚¡ç¥¨ä»£ç ') && thText.includes('è‚¡ç¥¨åç§°') && thText.includes('å å‡€å€¼');
                    }) || tables[0];

                    let holdings = [];
                    if (table) {
                        const ths = Array.from(table.querySelectorAll('thead th'));
                        const norm = (s) => (s || '').replace(/\s+/g, '').replace(/\u00a0/g, '');
                        const idxCode = ths.findIndex(th => norm(th.textContent).includes('è‚¡ç¥¨ä»£ç '));
                        const idxName = ths.findIndex(th => norm(th.textContent).includes('è‚¡ç¥¨åç§°'));
                        const idxRatio = ths.findIndex(th => {
                            const t = norm(th.textContent);
                            return t.includes('å å‡€å€¼') || t.includes('å å‡€å€¼æ¯”ä¾‹');
                        });

                        const rows = Array.from(table.querySelectorAll('tbody tr'));
                        holdings = rows.map(tr => {
                            const tds = Array.from(tr.querySelectorAll('td'));
                            if (tds.length === 0) return null;
                            const code = (tds[idxCode]?.textContent || '').trim();
                            const name = (tds[idxName]?.textContent || '').trim();
                            const ratioText = (tds[idxRatio]?.textContent || '').trim();
                            let ratio = 0;
                            const m = ratioText.match(/(\d+(\.\d+)?)/);
                            if (m) ratio = parseFloat(m[1]);
                            return { code, name, ratio };
                        }).filter(x => x && x.code && x.name).slice(0, 10);
                    }

                    if (holdings.length > 0) {
                        baiduData = { holdings, sectors: [], holdingDate: '' };
                        console.log(`âœ… eastmoneyå¤‡ç”¨æºè§£æäº† ${holdings.length} æ¡æŒä»“`);
                    }
                } catch (e) {
                    console.error('è§£æeastmoneyæŒä»“å¤±è´¥:', e);
                }
            }

            // --- æ— æ•°æ®é€€å‡º â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            if (!baiduData || baiduData.holdings.length === 0) {
                console.error('ğŸ’¥ æ‰€æœ‰æŒä»“æ•°æ®æºå‡å¤±è´¥æˆ–æ— æ•°æ®');
                tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500);">æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</td></tr>`;
                tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">åŠ è½½å¤±è´¥</span>`;
                return;
            }

            // --- æ¸²æŸ“æ¿å—æ ‡ç­¾ï¼ˆè¡Œä¸šå æ¯”ï¼‰â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            // å¦‚æœæœ‰Baiduè¡Œä¸šæ•°æ®ç›´æ¥ç”¨ï¼›å¦åˆ™åé¢ä»eastmoneyè‚¡ç¥¨è¡Œæƒ…é‡Œå½’å¹¶
            let sectorSource = 'baidu'; // æ ‡è®°æ•°æ®æ¥æº
            if (baiduData.sectors.length > 0) {
                tags.innerHTML = baiduData.sectors.slice(0, 6).map(s =>
                    `<span class="sector-tag">${s.name} ${s.weight.toFixed(1)}%</span>`
                ).join('');
            } else {
                sectorSource = 'eastmoney'; // åç»­ä»è¡Œæƒ…å½’å¹¶
                tags.innerHTML = `<span style="font-size: 0.8125rem; color: var(--gray-500);">æ¿å—æ•°æ®åŠ è½½ä¸­...</span>`;
            }

            // --- è·å–è‚¡ç¥¨å®æ—¶è¡Œæƒ…ï¼ˆæ¶¨è·Œå¹…ï¼‰â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            const quoteSources = [
                (secid) => `https://push2.eastmoney.com/api/qt/stock/get?secid=${secid}&fields=f2,f3,f4,f43,f60,f100&ut=fa5fd1943c7b386f172d6893dbfba10b&_=${Date.now()}`
            ];

            console.log('ğŸ“ˆ å¼€å§‹è·å–è‚¡ç¥¨è¡Œæƒ…...');
            const quotes = await Promise.all(baiduData.holdings.map(async h => {
                const secid = getEastmoneySecId(h.code);
                for (const getUrl of quoteSources) {
                    try {
                        let qjson;
                        try {
                            qjson = await runWithSourceStat('quote_stock_get_jsonp', async () => await fetchJsonp(getUrl(secid), 'cb', 8000));
                        } catch {
                            qjson = await runWithSourceStat('quote_stock_get_jsonp_callback', async () => await fetchJsonp(getUrl(secid), 'callback', 8000));
                        }
                        if (qjson?.data) {
                            const d = qjson.data;
                            const last = Number(d.f43 ?? d.f2);
                            const prevClose = Number(d.f60);
                            const chgRaw = d.f3;
                            let chg = (typeof chgRaw === 'number') ? chgRaw : Number(chgRaw);
                            if (!Number.isFinite(chg)) {
                                if (Number.isFinite(last) && Number.isFinite(prevClose) && prevClose !== 0) {
                                    chg = ((last - prevClose) / prevClose) * 100;
                                } else {
                                    chg = 0;
                                }
                            }
                            chg = normalizeStockChg(chg, status0);
                            return { ...h, chg, price: Number.isFinite(last) ? last : 0, industry: d.f100 || 'å…¶ä»–' };
                        }
                    } catch (err) { continue; }
                }
                return { ...h, chg: 0, price: 0, industry: 'å…¶ä»–' };
            }));

            // ç»Ÿä¸€å˜é‡ï¼šTOP10 æƒé‡/å‰åæŒä»“å æ¯”åˆè®¡ç”¨åŒä¸€ä¸ª top10Weightï¼Œé¿å…ä¸¤å¤„å„ç®—å„çš„å¯¼è‡´é”™ä¹±
            const top10Weight = quotes.reduce((sum, h) => sum + (parseFloat(h.ratio) || 0), 0);
            const top10WeightTag = `<span class="sector-tag top10-weight">å‰åæŒä»“å æ¯”åˆè®¡ï¼š${top10Weight.toFixed(2)}%ï¼ˆè‚¡ç¥¨æŒä»“ï¼‰</span>`;
            if (tags) {
                tags.innerHTML = top10WeightTag + tags.innerHTML;
            }

            // --- æ¸²æŸ“æŒä»“è¡¨æ ¼ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            let holdingDateLabel = '';
            if (baiduData.holdingDate) {
                holdingDateLabel = ` <span style="font-size:0.7rem;color:var(--gray-500);font-weight:500;">(${baiduData.holdingDate})</span>`;
            }
            document.querySelector('.table-header').innerHTML = `åŸºé‡‘æŒä»“ï¼ˆTOP 10ï¼‰${holdingDateLabel}`;

            // ç¼“å­˜å½“å‰ TOP10 åˆ—è¡¨ï¼Œåç»­ updateHoldingsChgOnly åªæ›´æ–°æ¶¨è·Œå¹…
            fund._topHoldings = quotes.map(h => ({ code: h.code, name: h.name, ratio: h.ratio || 0 }));

            tbody.innerHTML = quotes.map(h => `
                <tr data-code="${h.code}" onclick="openStockDetail('${h.code}')">
                    <td>${h.name}</td>
                    <td style="font-family:'JetBrains Mono',monospace;font-size:0.8125rem;">${h.code}</td>
                    <td><strong>${h.ratio ? h.ratio.toFixed(2) + '%' : '--'}</strong></td>
                    <td class="holding-chg ${h.chg >= 0 ? 'positive' : 'negative'}"><strong>${(h.chg > 0 ? '+' : '') + h.chg.toFixed(2) + '%'}</strong></td>
                </tr>
            `).join('');

            // --- å¦‚æœæ¿å—æ•°æ®æ¥è‡ªeastmoneyï¼Œä»è¡Œæƒ…é‡Œå½’å¹¶è¡Œä¸šä¿¡æ¯ â€”â€”â€”â€”â€”â€”â€”â€”
            if (sectorSource === 'eastmoney') {
                const sectors = {};
                quotes.forEach(h => {
                    const ind = h.industry || 'å…¶ä»–';
                    if (!sectors[ind]) sectors[ind] = { name: ind, weight: 0, chg: [] };
                    sectors[ind].weight += (h.ratio || 0);
                    if (h.chg !== undefined) sectors[ind].chg.push(h.chg);
                });
                const sortedSectors = Object.values(sectors).map(s => ({ ...s, avgChg: s.chg.length > 0 ? s.chg.reduce((a, b) => a + b, 0) / s.chg.length : 0 })).sort((a, b) => b.weight - a.weight).slice(0, 6);
                const filteredSectors = sortedSectors.filter(s => s.name !== 'å…¶ä»–');
                const sectorHtml = filteredSectors.map(s =>
                    `<span class="sector-tag ${s.avgChg >= 0 ? 'positive' : 'negative'}">${s.name} ${s.weight.toFixed(1)}% ${s.avgChg !== 0 ? '(' + (s.avgChg >= 0 ? '+' : '') + s.avgChg.toFixed(2) + '%)' : ''}</span>`
                ).join('');
                tags.innerHTML = top10WeightTag + (sectorHtml || '');
            }

            // --- è®¡ç®—æ—¥æ¶¨è·Œå¹…ä¼°ç®—ï¼ˆæ ¸å¿ƒç®—æ³•ï¼‰â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            // å…¬å¼: estimatedDayChg = Î£(w_i Ã— chg_i) + (1 - W_top) Ã— residual_rate
            //   w_i         = ç¬¬iä¸ªè‚¡ç¥¨å å‡€å€¼æ¯”ä¾‹ (%)ï¼Œå¦‚ 9.32 è¡¨ç¤º 9.32%
            //   chg_i       = ç¬¬iä¸ªè‚¡ç¥¨ä»Šæ—¥å®æ—¶æ¶¨è·Œå¹… (%)
            //   W_top       = TOP10 æ€»æƒé‡ä¹‹å’Œ (%)ï¼Œå¦‚ 62.86
            //   residual_rate = å‰©ä½™ä»“ä½çš„ä¼°ç®—æ¶¨è·Œç‡
            //                   å½“ fundgz gszzl å¯ç”¨æ—¶åæ¨: residual = (gszzl - top10_contribution) / (100 - W_top)
            //                   å½“ gszzl ä¸å¯ç”¨æˆ–å‰©ä½™æƒé‡ä¸º0æ—¶: residual = top10 åŠ æƒå¹³å‡æ¶¨è·Œç‡
            // æ³¨æ„: w_i æ˜¯ç™¾åˆ†æ¯”å€¼ (å¦‚9.32)ï¼Œæ‰€ä»¥ Î£(w_i Ã— chg_i) çš„å•ä½æ˜¯ %Ã—%ï¼Œéœ€è¦ /100 å½’ä¸€åŒ–
            {
                const status = getMarketStatus();
                if (status.canRealtimeUpdate || status.reason === 'åˆé—´ä¼‘å¸‚') {
                    // è®¡ç®— TOP10 åŠ æƒè´¡çŒ®
                    let top10Contribution = 0; // TOP10 å¯¹æ¶¨è·Œçš„è´¡çŒ® (%)
                    quotes.forEach(h => {
                        const w = h.ratio || 0;   // å å‡€å€¼æ¯”ä¾‹ (%)
                        const c = h.chg || 0;     // ä»Šæ—¥æ¶¨è·Œå¹… (%)
                        top10Contribution += (w / 100) * c; // w/100 æŠŠç™¾åˆ†æ¯”è½¬ä¸ºæ¯”ä¾‹ï¼Œä¹˜ä»¥chg(%)å¾—åˆ°è´¡çŒ®(%)
                    });

                    let residualWeight = 100 - top10Weight; // å‰©ä½™ä»“ä½æƒé‡ (%)
                    let residualRate = 0;                    // å‰©ä½™ä»“ä½ä¼°ç®—æ¶¨è·Œç‡ (%)

                    const fundgzGszzl = parseFloat(fund._fundgzDayGrowth); // fundgz æä¾›çš„æ•´ä½“ä¼°ç®—æ¶¨è·Œå¹… (%)
                    if (!isNaN(fundgzGszzl) && residualWeight > 0.01) {
                        // ç”¨ fundgz ä¼°ç®—åæ¨å‰©ä½™ä»“ä½æ¶¨è·Œç‡
                        // gszzl â‰ˆ top10_contribution + (residualWeight/100) Ã— residualRate
                        // âŸ¹ residualRate = (gszzl - top10_contribution) / (residualWeight/100)
                        residualRate = (fundgzGszzl - top10Contribution) / (residualWeight / 100);
                        // å®‰å…¨é™åˆ¶ï¼šå‰©ä½™ä¼°ç®—ä¸èƒ½è¶…è¿‡ TOP10 å‡å€¼çš„ 3å€ï¼Œé˜²æ­¢å¼‚å¸¸å€¼
                        const top10AvgRate = top10Weight > 0 ? top10Contribution / (top10Weight / 100) : 0;
                        if (Math.abs(residualRate) > Math.abs(top10AvgRate) * 3 + 5) {
                            residualRate = top10AvgRate; // å›é€€åˆ°TOP10å‡å€¼
                        }
                    } else if (top10Weight > 0) {
                        // gszzl ä¸å¯ç”¨æ—¶ï¼Œç”¨ TOP10 åŠ æƒå‡å€¼è¿‘ä¼¼å‰©ä½™éƒ¨åˆ†
                        residualRate = top10Contribution / (top10Weight / 100);
                    }

                    // æœ€ç»ˆä¼°ç®—æ¶¨è·Œå¹…ï¼šä¼˜å…ˆä½¿ç”¨ fundgz çš„æ•´ä½“ä¼°ç®—ï¼ˆå¸‚åœºé€šç”¨å£å¾„ï¼‰ï¼Œé¿å…å› é™å¹…/è¯¯å·®å¯¼è‡´æ•´ä½“è·‘å
                    const fallbackEst = top10Contribution + (residualWeight / 100) * residualRate;
                    const estDayChg = (!isNaN(fundgzGszzl)) ? fundgzGszzl : fallbackEst;

                    // å­˜å…¥ç¼“å­˜ä¾› updateMainDisplay ä½¿ç”¨
                    holdingsCache[fund.code] = {
                        top10Weight: top10Weight,
                        top10Contribution: top10Contribution,
                        residualWeight: residualWeight,
                        residualRate: residualRate,
                        estDayChg: estDayChg,
                        timestamp: Date.now()
                    };
                }
            }
        }

        async function updateHoldingsChgOnly(fund) {
            const tbody = document.getElementById('holdingsTableBody');
            if (!tbody) return;
            const list = Array.isArray(fund?._topHoldings) ? fund._topHoldings : [];
            if (list.length === 0) return;

            const status0 = getMarketStatus();

            // æ‰¹é‡è¡Œæƒ…ï¼šä¸€æ¬¡è¯·æ±‚æ‹¿åˆ° TOP10 å…¨éƒ¨è‚¡ç¥¨æ¶¨è·Œå¹…ï¼Œé¿å… 1 ç§’å†…å¤šæ¬¡è¯·æ±‚
            const secids = list.map(h => getEastmoneySecId(h.code)).filter(Boolean).join(',');
            if (!secids) return;
            const url = `https://push2.eastmoney.com/api/qt/ulist.np/get?fltt=2&invt=2&secids=${secids}&fields=f12,f3&ut=fa5fd1943c7b386f172d6893dbfba10b&_=${Date.now()}`;

            let qjson;
            try {
                qjson = await runWithSourceStat('quote_ulist_np_get_jsonp', async () => await fetchJsonp(url, 'cb', 8000));
            } catch {
                qjson = await runWithSourceStat('quote_ulist_np_get_jsonp_callback', async () => await fetchJsonp(url, 'callback', 8000));
            }

            const diff = qjson?.data?.diff;
            const chgMap = {};
            if (Array.isArray(diff)) {
                diff.forEach(item => {
                    const code = (item?.f12 || '').toString();
                    const chg = Number(item?.f3);
                    if (code && Number.isFinite(chg)) chgMap[code] = chg;
                });
            }

            const quotes = list.map(h => ({
                code: h.code,
                chg: normalizeStockChg(Number.isFinite(chgMap[h.code]) ? chgMap[h.code] : 0, status0)
            }));

            quotes.forEach(q => {
                const tr = tbody.querySelector(`tr[data-code="${q.code}"]`);
                if (!tr) return;
                const td = tr.querySelector('td.holding-chg');
                if (!td) return;
                td.className = `holding-chg ${q.chg >= 0 ? 'positive' : 'negative'}`;
                td.innerHTML = `<strong>${(q.chg > 0 ? '+' : '') + q.chg.toFixed(2) + '%'}</strong>`;
            });

            // åŒæ­¥æ›´æ–°â€œæ—¥æ¶¨è·Œå¹…â€çš„ä¼°ç®—ç¼“å­˜ï¼ˆè®©æŒä»“å®æ—¶æ¶¨è·Œä¸æ—¥æ¶¨è·Œå¹…è”åŠ¨ï¼‰

            const top10Weight = list.reduce((sum, h) => sum + (parseFloat(h.ratio) || 0), 0);
            let top10Contribution = 0;
            list.forEach(h => {
                const w = parseFloat(h.ratio) || 0;
                const c = normalizeStockChg(Number.isFinite(chgMap[h.code]) ? chgMap[h.code] : 0, status0);
                top10Contribution += (w / 100) * c;
            });

            const residualWeight = 100 - top10Weight;
            let residualRate = 0;
            const fundgzGszzl = parseFloat(fund._fundgzDayGrowth);
            if (!isNaN(fundgzGszzl) && residualWeight > 0.01) {
                residualRate = (fundgzGszzl - top10Contribution) / (residualWeight / 100);
                const top10AvgRate = top10Weight > 0 ? top10Contribution / (top10Weight / 100) : 0;
                if (Math.abs(residualRate) > Math.abs(top10AvgRate) * 3 + 5) {
                    residualRate = top10AvgRate;
                }
            } else if (top10Weight > 0) {
                residualRate = top10Contribution / (top10Weight / 100);
            }

            const fallbackEst = top10Contribution + (residualWeight / 100) * residualRate;
            const estDayChg = (!isNaN(fundgzGszzl)) ? fundgzGszzl : fallbackEst;

            holdingsCache[fund.code] = {
                top10Weight,
                top10Contribution,
                residualWeight,
                residualRate,
                estDayChg,
                timestamp: Date.now()
            };
            if (Number.isFinite(estDayChg)) fund.dayGrowth = estDayChg;
        }

        function initChart() {
            const dom = document.getElementById('klineChart');
            chart = echarts.init(dom);
            chart.setOption({
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: 'rgba(255,255,255,0.95)', padding: 12 },
                grid: { left: '3%', right: '4%', bottom: '20', top: '20', containLabel: true },
                xAxis: { type: 'category', boundaryGap: false, axisLine: { lineStyle: { color: '#e5e5e5' } }, axisLabel: { color: '#737373' } },
                yAxis: { type: 'value', scale: true, splitLine: { lineStyle: { color: '#f5f5f5' } }, axisLabel: { color: '#737373' } },
                series: [{ name: 'å‡€å€¼', type: 'line', smooth: true, symbol: 'none', connectNulls: true, lineStyle: { width: 3, color: '#3b82f6' }, areaStyle: { color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(59,130,246,0.3)'},{offset:1,color:'rgba(59,130,246,0.05)'}]) }, emphasis: { focus: 'series' } }]
            });
            initTurningPointMagnet();
            window.addEventListener('resize', () => chart.resize());
        }

        let _turningPointIdxs = [];
        let _turningPointLabels = [];
        let _magnetLock = false;

        function setTurningPointMagnetData(labels, values, maxPoints) {
            const idxs = pickTurningPoints(values, maxPoints);
            _turningPointIdxs = Array.isArray(idxs) ? idxs.slice().sort((a, b) => a - b) : [];
            _turningPointLabels = Array.isArray(labels) ? labels : [];
        }

        function findNearestIdx(sortedIdxs, target) {
            if (!Array.isArray(sortedIdxs) || sortedIdxs.length === 0) return -1;
            let lo = 0;
            let hi = sortedIdxs.length - 1;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const v = sortedIdxs[mid];
                if (v === target) return v;
                if (v < target) lo = mid + 1;
                else hi = mid - 1;
            }
            const candA = hi >= 0 ? sortedIdxs[hi] : null;
            const candB = lo < sortedIdxs.length ? sortedIdxs[lo] : null;
            if (candA === null) return candB ?? -1;
            if (candB === null) return candA ?? -1;
            return (Math.abs(candA - target) <= Math.abs(candB - target)) ? candA : candB;
        }

        function axisValueToIndex(val) {
            if (typeof val === 'number' && Number.isFinite(val)) return val;
            if (!val) return -1;
            const s = String(val);
            const idx = _turningPointLabels.indexOf(s);
            return idx >= 0 ? idx : -1;
        }

        function initTurningPointMagnet() {
            if (!chart) return;
            chart.off('updateAxisPointer');
            chart.on('updateAxisPointer', (e) => {
                if (_magnetLock) return;
                const info = e?.axesInfo?.[0];
                if (!info) return;
                const curIdx = axisValueToIndex(info.value);
                if (curIdx < 0) return;
                const nearest = findNearestIdx(_turningPointIdxs, curIdx);
                if (nearest < 0) return;

                const threshold = 2; // ç¦»è½¬æŠ˜ç‚¹ 2 ä¸ªç‚¹ä»¥å†…è§¦å‘â€œç£å¸â€
                if (Math.abs(nearest - curIdx) <= threshold && nearest !== curIdx) {
                    _magnetLock = true;
                    try {
                        chart.dispatchAction({ type: 'showTip', seriesIndex: 0, dataIndex: nearest });
                    } finally {
                        setTimeout(() => { _magnetLock = false; }, 0);
                    }
                }
            });
        }

        function pickTurningPoints(values, maxPoints = 12) {
            if (!Array.isArray(values) || values.length < 3) return [];
            const pts = [];
            let lastFinite = -1;
            for (let i = 0; i < values.length; i++) {
                if (Number.isFinite(values[i])) { lastFinite = i; break; }
            }
            if (lastFinite < 0) return [];
            let prev = values[lastFinite];
            let prevDiff = 0;
            for (let i = lastFinite + 1; i < values.length; i++) {
                const v = values[i];
                if (!Number.isFinite(v)) continue;
                const diff = v - prev;
                if (prevDiff !== 0 && diff !== 0 && (prevDiff > 0) !== (diff > 0)) {
                    // è½¬æŠ˜ç‚¹å‡ºç°åœ¨ prev å¯¹åº”çš„ç´¢å¼•é™„è¿‘
                    pts.push({ idx: i - 1, score: Math.abs(prevDiff) + Math.abs(diff) });
                }
                if (diff !== 0) prevDiff = diff;
                prev = v;
            }
            if (pts.length <= maxPoints) return pts.map(p => p.idx);
            pts.sort((a, b) => b.score - a.score);
            const top = pts.slice(0, maxPoints).map(p => p.idx).sort((a, b) => a - b);
            return top;
        }

        function changeTimeRange(range) {
            currentTimeRange = range;
            document.querySelectorAll('.time-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            if (range === 'realtime') {
                updateRealtimeChart();
                startRealtimeUpdate();
                if (selectedFund) fetchHistoryData(selectedFund.code, false);
            }
            else {
                stopRealtimeUpdate();
                if (!selectedFund) return;
                if (historyCache[selectedFund.code]) { renderHistoryChart(selectedFund.code); }
                else { fetchHistoryData(selectedFund.code, true); }
            }
        }

        function getRealtimeChartData(fund) {
            const labels = [];
            for (let m=570; m<=690; m++) labels.push(`${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`);
            for (let m=780; m<=900; m++) labels.push(`${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`);
            const history = getRealtimeSeriesForChart(fund);
            let end = getEffectiveRealtimeEndIndex(history);
            if (end < 0) end = history.length - 1;
            const xData = labels.slice(0, end + 1);
            const yData = history.slice(0, end + 1);
            return { labels, history, end, xData, yData };
        }

        function updateRealtimeChart() {
            if (!selectedFund) return;
            document.getElementById('chartTypeLabel').innerHTML = `å®æ—¶ä¼°å€¼èµ°åŠ¿`;
            const { xData, yData } = getRealtimeChartData(selectedFund);

            setTurningPointMagnetData(xData, yData, 16);

            const baseNav = parseFloat(selectedFund.currentNav);
            chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: (params) => {
                        const pNav = params?.[0];
                        const t = pNav?.axisValueLabel || '';
                        const rawNav = pNav?.data;
                        const nav = (rawNav === null || rawNav === undefined) ? NaN : Number(rawNav);
                        const navText = Number.isFinite(nav) ? nav.toFixed(4) : '--';

                        let pct = NaN;
                        if (Number.isFinite(baseNav) && baseNav > 0 && Number.isFinite(nav)) {
                            pct = ((nav - baseNav) / baseNav) * 100;
                        }
                        const pctText = Number.isFinite(pct) ? ((pct >= 0 ? '+' : '') + pct.toFixed(2) + '%') : '--';
                        const pctColor = Number.isFinite(pct) ? (pct >= 0 ? '#ef4444' : '#10b981') : '#737373';
                        return `${t}<br/>å‡€å€¼ï¼š${navText}<br/>æ¶¨è·Œå¹…ï¼š<span style="color:${pctColor};font-weight:700;">${pctText}</span>`;
                    }
                },
                xAxis: {
                    data: xData,
                    axisTick: { show: false },
                    minorTick: { show: false },
                    axisLabel: {
                        color: '#737373',
                        interval: 0,
                        formatter: (value) => {
                            if (value === '09:30') return '09:30';
                            if (value === '11:30') return '11:30/13:00';
                            if (value === '15:00') return '15:00';
                            return '';
                        }
                    }
                },
                series: [{ name: 'å‡€å€¼', data: yData }]
            });
        }

        // æ ¹æ®æ—¶é—´èŒƒå›´è®¡ç®—æˆªæ–­æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
        function getCutoffTimestamp(range) {
            const t = getShanghaiTimeParts();
            const today = new Date(Date.UTC(t.year, t.month - 1, t.day)); // ä¸Šæµ·"ä»Šå¤©"00:00 UTC
            let cutoff;
            switch (range) {
                case '5d':  cutoff = new Date(today); cutoff.setUTCDate(cutoff.getUTCDate() - 7); break;
                case '1m':  cutoff = new Date(today); cutoff.setUTCMonth(cutoff.getUTCMonth() - 1); break;
                case '3m':  cutoff = new Date(today); cutoff.setUTCMonth(cutoff.getUTCMonth() - 3); break;
                case '1y':  cutoff = new Date(today); cutoff.setUTCFullYear(cutoff.getUTCFullYear() - 1); break;
                case 'all': return 0; // æˆç«‹æ¥ä¸æˆªæ–­
                default:    cutoff = new Date(today); cutoff.setUTCDate(cutoff.getUTCDate() - 7); break;
            }
            return cutoff.getTime();
        }

        // å°†æ—¶é—´æˆ³è½¬ä¸º YYYY-MM-DDï¼ˆä¸Šæµ·æ—¶åŒº +8ï¼‰
        function tsToDateStr(ts) {
            const d = new Date(ts + 8 * 3600000); // åŠ 8å°æ—¶åæŒ‰UTCè¯»
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth() + 1).padStart(2, '0');
            const dd = String(d.getUTCDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        // ä»ç¼“å­˜æ•°æ®æ¸²æŸ“å›¾è¡¨ + å†å²è¡¨æ ¼ï¼ˆä¸å‘ç½‘ç»œè¯·æ±‚ï¼‰
        function renderHistoryChart(code) {
            const all = historyCache[code];
            if (!all || all.length === 0) return;

            const cutoff = getCutoffTimestamp(currentTimeRange);
            const data = all.filter(p => p.x >= cutoff); // æŒ‰æ—¶é—´æˆ³æˆªæ–­

            const labels = data.map(p => tsToDateStr(p.x));
            const values = data.map(p => p.y);

            setTurningPointMagnetData(labels, values, 18);

            const rangeLabel = { '5d':'1å‘¨', '1m':'1æœˆ', '3m':'3æœˆ', '1y':'1å¹´', 'all':'æˆç«‹æ¥' };
            document.getElementById('chartTypeLabel').innerHTML = `${rangeLabel[currentTimeRange] || ''}å‡€å€¼èµ°åŠ¿`;

            chart.setOption({
                tooltip: { axisPointer: { type: 'cross' } },
                xAxis: {
                    data: labels,
                    axisTick: { show: true },
                    minorTick: { show: false },
                    axisLabel: {
                        color: '#737373',
                        interval: 'auto',
                        formatter: null
                    }
                },
                series: [{ name: 'å‡€å€¼', data: values }]
            });
        }

        function resetHistoryTable(code) {
            historyTableState.code = code;
            historyTableState.rendered = 0;
            const tbody = document.getElementById('historyTableBody');
            if (tbody) tbody.innerHTML = '';
            appendHistoryTableRows();
        }

        function appendHistoryTableRows() {
            const code = historyTableState.code;
            const all = code ? historyCache[code] : null;
            const tbody = document.getElementById('historyTableBody');
            if (!tbody) return;
            if (!all || all.length === 0) {
                if (historyTableState.rendered === 0) {
                    tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: var(--gray-500); padding: 40px;">æš‚æ— æ•°æ®</td></tr>`;
                }
                return;
            }

            const start = historyTableState.rendered;
            const end = Math.min(start + historyTableState.pageSize, all.length);
            if (start >= end) return;

            const rows = [];
            for (let k = start; k < end; k++) {
                const i = all.length - 1 - k;
                if (i < 0) break;
                const date = tsToDateStr(all[i].x);
                const val = all[i].y;
                const pct = i > 0 ? (((all[i].y - all[i - 1].y) / all[i - 1].y) * 100) : 0;

                let dayProfitText = '--';
                let dayProfitClass = '';
                const fund = funds.find(f => f.code === code);
                if (fund && i > 0) {
                    let shares = NaN;
                    let buyDate = null;
                    let effectiveBuyDate = null;
                    const buyInfo = getFundBuyInfo(fund);
                    if (buyInfo.amount && buyInfo.date) {
                        const buyPoint = getFirstHistoryPointOnOrAfter(code, buyInfo.date);
                        const buyNav = buyPoint ? Number(buyPoint.y) : NaN;
                        if (Number.isFinite(buyNav) && buyNav > 0) {
                            shares = buyInfo.amount / buyNav;
                            buyDate = buyInfo.date;
                            effectiveBuyDate = buyPoint.date;
                        }
                    }
                    if (!Number.isFinite(shares) || shares <= 0) {
                        const legacy = getPositionFromLegacy(fund);
                        if (legacy.has) {
                            shares = legacy.shares;
                            buyDate = legacy.buyDate;
                            effectiveBuyDate = null;
                        }
                    }
                    if (Number.isFinite(shares) && shares > 0) {
                        // ä¹°å…¥ç”Ÿæ•ˆæ—¥ï¼ˆ>=buyDate çš„é¦–ä¸ªäº¤æ˜“æ—¥ï¼‰ä¹‹å‰ä¸å±•ç¤ºæ—¥å‡€æ”¶ç›Šï¼Œé¿å…è¯¯è§£ä¸ºæ—©å·²æŒæœ‰ä¸”æ”¶ç›Šä¸º0
                        const isBeforeEffectiveBuy = effectiveBuyDate ? (date < effectiveBuyDate) : (buyDate ? (date < buyDate) : true);
                        if (!isBeforeEffectiveBuy) {
                            const dayProfit = (effectiveBuyDate && date === effectiveBuyDate)
                                ? 0
                                : ((all[i].y - all[i - 1].y) * shares);
                            dayProfitText = 'Â¥' + dayProfit.toFixed(2);
                            dayProfitClass = dayProfit >= 0 ? 'positive' : 'negative';
                        }
                    }
                }

                const pctText = (i > 0)
                    ? ((pct >= 0 ? '+' : '') + pct.toFixed(2) + '%')
                    : '--';
                rows.push(`<tr><td>${date}</td><td>${val.toFixed(4)}</td><td class="${i > 0 ? (pct>=0?'positive':'negative') : ''}">${pctText}</td><td class="${dayProfitClass}">${dayProfitText}</td></tr>`);
            }

            if (historyTableState.rendered === 0) tbody.innerHTML = '';
            tbody.insertAdjacentHTML('beforeend', rows.join(''));
            historyTableState.rendered = end;
        }

        // æ‹‰å– pingzhongdata å…¨å†å²å¹¶ç¼“å­˜ï¼Œç„¶åæ¸²æŸ“
        async function fetchHistoryData(code, renderChart = true) {
            if (historyCache[code]) {
                if (renderChart) renderHistoryChart(code);
                resetHistoryTable(code);
                return;
            }

            try {
                console.log(`ğŸ”„ [å†å²-pingzhongdata] æ‹‰å– ${code}...`);
                await loadScript(`https://fund.eastmoney.com/pingzhongdata/${code}.js?rt=${Date.now()}`, 12000);
                const raw = window.Data_netWorthTrend;
                if (!Array.isArray(raw) || raw.length === 0) throw new Error('Data_netWorthTrend ä¸ºç©º');

                // ç¼“å­˜å…¨éƒ¨æ•°æ®ï¼ˆæ¯æ¡ {x: æ—¶é—´æˆ³, y: å‡€å€¼}ï¼‰
                historyCache[code] = raw.map(item => ({ x: item.x, y: item.y }));
                console.log(`âœ… [å†å²-pingzhongdata] ${code} å…± ${raw.length} æ¡ï¼Œå·²ç¼“å­˜`);

                // ç”¨æœ€æ–°ä¸€æ¡åŒæ­¥å‡€å€¼
                if (selectedFund && selectedFund.code === code) {
                    const latest = raw[raw.length - 1];
                    const prev   = raw.length >= 2 ? raw[raw.length - 2] : null;
                    const jzrq   = tsToDateStr(latest.x);
                    if (jzrq > (selectedFund.navDate || '')) {
                        selectedFund.navDate  = jzrq;
                        selectedFund.currentNav = latest.y;
                        saveFunds();
                        updateMainDisplay(selectedFund);
                    }
                }

                if (renderChart) renderHistoryChart(code);
                resetHistoryTable(code);
            } catch(e) {
                console.error('ğŸ’¥ å†å²æ•°æ®åŠ è½½å¤±è´¥:', e);
                document.getElementById('historyTableBody').innerHTML = `<tr><td colspan="4" style="text-align:center;color:var(--gray-500);padding:40px;">æ•°æ®åŠ è½½å¤±è´¥</td></tr>`;
            }
        }

        document.getElementById('historyScroll')?.addEventListener('scroll', (e) => {
            const el = e.target;
            if (!el) return;
            if (el.scrollTop + el.clientHeight >= el.scrollHeight - 20) {
                appendHistoryTableRows();
            }
        });

        function startRealtimeUpdate() { startUnifiedRefreshLoop(); }
        function stopRealtimeUpdate() { /* unified loop handles stop */ }
        function startAutoUpdate() { startUnifiedRefreshLoop(); }

        function startUnifiedRefreshLoop() {
            if (refreshInterval) return;
            refreshInterval = setInterval(() => {
                refreshLock = refreshLock.then(async () => {
                    const status = getMarketStatus();
                    const now = Date.now();

                    // ä¼‘å¸‚æœŸé—´ï¼šæš‚åœæ‰€æœ‰è½®è¯¢ä»»åŠ¡ï¼Œé™¤â€œéœ€è¦è¡¥å…¨â€çš„ä¼°å€¼æº
                    // - äº¤æ˜“ä¸­/ç›˜åè¡¥å…¨ï¼šç…§å¸¸åˆ·æ–°ï¼ˆä¼°å€¼/æŒä»“/æŒ‡æ•°ï¼‰
                    // - åˆé—´ä¼‘å¸‚ï¼šä»…ä½é¢‘åˆ·æ–°â€œé€‰ä¸­åŸºé‡‘â€çš„ä¼°å€¼ï¼Œå…¶ä»–æ¨¡å—æš‚åœ
                    // - ç›˜å‰/ç›˜å/å‘¨æœ«ç­‰ï¼šå…¨éƒ¨æš‚åœ
                    if (!status.canRealtimeUpdate) {
                        if (status.reason !== 'åˆé—´ä¼‘å¸‚') return;
                        const minMiddayFundInterval = 15000;
                        if (!selectedFund) return;
                        // åˆä¼‘è¡¥å…¨ï¼šå¦‚æœå·²ç»æ‹¿åˆ° 11:30ï¼ˆä¸Šåˆæ”¶ç›˜ï¼‰æ•°æ®ï¼Œå°±ä¸å†é‡å¤è¯·æ±‚ï¼Œç­‰ 13:00 åå†æ¢å¤
                        const sh = getShanghaiTimeParts();
                        const todayStr = `${sh.year}-${String(sh.month).padStart(2,'0')}-${String(sh.day).padStart(2,'0')}`;
                        const middayEndIdx = getRealtimeMinuteIndexFromGzTime(`${todayStr} 11:30`);
                        const curIdx = getRealtimeMinuteIndexFromGzTime(selectedFund.estimatedTime);
                        if (middayEndIdx >= 0 && curIdx >= middayEndIdx) return;
                        if (now - lastFundRefreshAt < minMiddayFundInterval) return;
                        lastFundRefreshAt = now;
                        await fetchFundData(selectedFund, { suppressRender: true });
                        renderFundList();
                        updateMainDisplay(selectedFund);
                        if (currentTimeRange === 'realtime') updateRealtimeChart();
                        return;
                    }

                    const minFundInterval = 2900;
                    const minIndicesInterval = 2900;

                    // å…¨å±€é™æµï¼šæ¯ç§’æœ€å¤šä¸€æ¬¡â€œç½‘ç»œä»»åŠ¡â€ï¼Œç”¨è½®è¯¢è°ƒåº¦ä¿è¯å„æ¨¡å—éƒ½èƒ½æ›´æ–°
                    // tick%4:
                    //   0/1: è½®è¯¢åˆ·æ–°ä¸€åªåŸºé‡‘ä¼°å€¼ï¼ˆé¿å…å¤šåŸºé‡‘åŒç§’å¤šè¯·æ±‚ï¼‰
                    //   2:   åˆ·æ–°é€‰ä¸­åŸºé‡‘æŒä»“æ¶¨è·Œï¼ˆæ‰¹é‡æ¥å£ä¸€æ¬¡è¯·æ±‚ï¼‰
                    //   3:   åˆ·æ–°æŒ‡æ•°
                    refreshTick = (refreshTick + 1) % 4;

                    if ((refreshTick === 0 || refreshTick === 1) && funds.length > 0 && now - lastFundRefreshAt >= minFundInterval) {
                        lastFundRefreshAt = now;
                        fundRefreshCursor = fundRefreshCursor % funds.length;
                        const f = funds[fundRefreshCursor];
                        fundRefreshCursor++;
                        await fetchFundData(f, { suppressRender: true });
                        renderFundList();
                        if (selectedFund?.code === f.code) {
                            updateMainDisplay(selectedFund);
                            if (currentTimeRange === 'realtime') updateRealtimeChart();
                        }
                        return;
                    }

                    if (refreshTick === 2 && selectedFund) {
                        // äº¤æ˜“æ—¶æ¯ç§’ä»…æ›´æ–°â€œæŒä»“æ¶¨è·Œå¹…â€ï¼Œä¸é‡ç»˜æŒä»“/æ¿å—ï¼ˆæ‰¹é‡ä¸€æ¬¡è¯·æ±‚ï¼‰
                        await loadHoldingsAndSectors(selectedFund, { updateOnly: true });
                        updateDayGrowthDisplay(selectedFund);
                        return;
                    }

                    if (refreshTick === 3 && now - lastIndicesRefreshAt >= minIndicesInterval) {
                        lastIndicesRefreshAt = now;
                        await fetchMarketIndices();
                        return;
                    }

                    // ç»“æ„æ€§æŒä»“/æ¿å—ï¼šç»´æŒä½é¢‘ï¼ˆä¸å ç”¨æ¯ç§’é¢„ç®—ï¼Œåªæœ‰è½®åˆ°ä¸”è¶…æ—¶æ‰åˆ·æ–°ï¼‰
                    if (selectedFund && now - lastHoldingsRefreshAt >= 30000) {
                        lastHoldingsRefreshAt = now;
                        await loadHoldingsAndSectors(selectedFund, { silent: true });
                        return;
                    }
                }).catch(err => console.warn('unified refresh loop error:', err));
            }, 3000);
        }

        function stopUnifiedRefreshLoop() {
            if (!refreshInterval) return;
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
        function showToast(msg, type='success', durationMs=3000, closable=false) {
            let container = document.getElementById('toastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toastContainer';
                container.className = 'toast-container';
                document.body.appendChild(container);
            }
            const t = document.createElement('div');
            t.className = `toast ${type}`;
            const row = document.createElement('div');
            row.className = 'toast-row';
            const m = document.createElement('div');
            m.className = 'toast-msg';
            m.textContent = msg;
            row.appendChild(m);
            let timer = null;
            const remove = () => {
                if (timer) clearTimeout(timer);
                t.remove();
                const c = document.getElementById('toastContainer');
                if (c && c.children.length === 0) c.remove();
            };
            if (closable) {
                const btn = document.createElement('button');
                btn.className = 'toast-close';
                btn.type = 'button';
                btn.textContent = 'Ã—';
                btn.onclick = remove;
                row.appendChild(btn);
            }
            t.appendChild(row);
            container.appendChild(t);
            const d = Number(durationMs);
            if (Number.isFinite(d) && d > 0) timer = setTimeout(remove, d);
        }

        let _suggestTimer = null;
        let _suggestItems = [];
        let _suggestActive = -1;

        async function fetchFundSuggest(keyword) {
            const key = (keyword || '').trim();
            if (!key) return [];
            const url = `https://fundsuggest.eastmoney.com/FundSearch/api/FundSearchAPI.ashx?m=1&key=${encodeURIComponent(key)}`;
            const json = await runWithSourceStat('fund_suggest_jsonp', async () => await fetchJsonp(url, 'callback', 8000));
            const arr = json?.Datas || json?.data || [];
            if (!Array.isArray(arr)) return [];
            return arr.map(x => {
                const code = (x.CODE || x.FCODE || x.code || '').toString();
                const name = (x.NAME || x.SHORTNAME || x.name || '').toString();
                const type = (x.JJType || x.type || '').toString();
                return { code, name, type };
            }).filter(x => /^\d{6}$/.test(x.code) && x.name);
        }

        function renderFundSuggest(items) {
            const box = document.getElementById('fundSuggest');
            if (!box) return;
            _suggestItems = Array.isArray(items) ? items.slice(0, 12) : [];
            _suggestActive = -1;
            if (_suggestItems.length === 0) {
                box.style.display = 'none';
                box.innerHTML = '';
                return;
            }
            box.style.display = 'block';
            box.innerHTML = _suggestItems.map((it, idx) => {
                const meta = it.type ? it.type : 'åŸºé‡‘';
                return `<div class="fund-suggest-item" data-idx="${idx}" onclick="selectSuggestItem(${idx})"><div class="fund-suggest-left"><div class="fund-suggest-name">${it.name}</div><div class="fund-suggest-meta">${meta}</div></div><div class="fund-suggest-code">${it.code}</div></div>`;
            }).join('');
        }

        function selectSuggestItem(idx) {
            const it = _suggestItems[idx];
            if (!it) return;
            const input = document.getElementById('fundCode');
            if (input) input.value = it.code;
            const box = document.getElementById('fundSuggest');
            if (box) { box.style.display = 'none'; box.innerHTML = ''; }
            _suggestItems = [];
            _suggestActive = -1;
            input?.focus();
        }

        function moveSuggestActive(delta) {
            const box = document.getElementById('fundSuggest');
            if (!box || box.style.display === 'none') return;
            const items = box.querySelectorAll('.fund-suggest-item');
            if (!items || items.length === 0) return;
            _suggestActive += delta;
            if (_suggestActive < 0) _suggestActive = items.length - 1;
            if (_suggestActive >= items.length) _suggestActive = 0;
            items.forEach((el, i) => el.classList.toggle('active', i === _suggestActive));
            const activeEl = items[_suggestActive];
            if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
        }

        document.getElementById('fundCode')?.addEventListener('input', (e) => {
            const v = (e.target.value || '').trim();
            clearTimeout(_suggestTimer);
            if (v.length < 2 || /^\d{6}$/.test(v)) { renderFundSuggest([]); return; }
            _suggestTimer = setTimeout(async () => {
                try {
                    const items = await fetchFundSuggest(v);
                    renderFundSuggest(items);
                } catch {
                    renderFundSuggest([]);
                }
            }, 220);
        });

        document.getElementById('fundCode')?.addEventListener('keydown', (e) => {
            const box = document.getElementById('fundSuggest');
            const visible = box && box.style.display !== 'none';
            if (!visible) {
                if (e.key === 'Enter') { addFund(); e.preventDefault(); }
                return;
            }
            if (e.key === 'ArrowDown') { moveSuggestActive(1); e.preventDefault(); return; }
            if (e.key === 'ArrowUp') { moveSuggestActive(-1); e.preventDefault(); return; }
            if (e.key === 'Enter') {
                if (_suggestActive >= 0) { selectSuggestItem(_suggestActive); }
                else if (_suggestItems.length > 0) { selectSuggestItem(0); }
                e.preventDefault();
                return;
            }
            if (e.key === 'Escape') { renderFundSuggest([]); return; }
        });

        document.addEventListener('click', (e) => {
            const box = document.getElementById('fundSuggest');
            const input = document.getElementById('fundCode');
            if (!box || !input) return;
            if (e.target === input || box.contains(e.target)) return;
            renderFundSuggest([]);
        });
    </script>
</body>
</html>
